# 基础语法结构

## 1 go程序结构

- 每个go文件都已packge子句开头，标记文件所属的包名

```go
package main //直接从终端运行代码，必须使用“main”包名
```

- import语句用于导入其他包，包名用双引号括起来，可借助括号一次导入多个包

```go
import "fmt"
import (
	"main"
    "strings"
)
```

- go文件的最后一部分是代码，可定义多个函数func，其中main函数是程序的入口函数

- 典型文件结构布局如下

```go
//package 子句
//import 语句
//函数、代码
```

## 2 函数调用

```go
包名.函数名(参数)
```

- fmt.println()函数，可传递多个参数，语句会在同一行打印，完成后换行

```go
fmt.println("A","B");
```

- 函数返回值

```go
math.floor(2.75)//参数为一个小数，返回向下取整后的值
string.Title("hello world")//参数为字符串，函数将每个单词首字母替换成大写再返回新的字符串
```

------------------

## 3.字符串

- 使用字符串字面量来i定义字符串

```go
"This is a string"
```

- 字符串中可使用转义字符表达控制含义

```go
"name \t price \t number \n"
```

--------------

## 4.符文rune

- 用于表示单个字符，单引号括起来

```go
's'
```

- go语言使用Unicode编码储存字符

- 直接将rune传入fmt.Println函数，会打印出其编码值，而不是字符

```go
fmt.Println('1')
//输出 49
```

--------

## 5.布尔值

- 取值为true/false

---------

## 6.数字

- 整型/浮点型 使用小数点进行区分

----------

## 7.类型

- 使用reflect.TypeOf()函数可以判断参数类型（返回字符串）

```go
reflect.TypeOf(42)
//int
reflect.Typeof(3.1415)
//float64
//其他类型还有bool string float32(不常用)
```

------------

## 8.变量声明

- 格式

  var 变量名 变量类型

  var 变量名 变量类型 = 初始化赋值

  var 变量名 = 初始化赋值

```go
var v1 int
var v2 float64
var v3 string = "helloworld"
var v4 = 13 //省略变量类型，根据赋值类型自动匹配类型为int型
var v5 = v4+1 //可使用运算结果进行赋值
```

- 可在同一个语句中为多个变量赋值，类似“分别等于“

```go
length,width = 1.2,2.4
```

- 声明但未赋值的变量会自动初始化为”0“值

```go
int -- 0
float64 -- 0.0
bool -- false
string -- ""	//空串
```

- 变量声明可以放在package、import语句之后的任何位置，声明在不同位置代表着不同作用域
- go要求声明的每个变量必须在程序中使用，否则就会报错
- go允许变量名与某些类型名相同，但这会遮盖掉其他名字，导致原本的类型无法使用。命名变量时要避免**遮盖**

```go
import "fmt"
var int int = 12;	//变量名int会遮盖掉int类型名，但不会报错
var fmt string = "ss" //遮盖了包名fmt，即使导入后也不能使用，后续使用fmt的函数会报错，因为此时的fmt为一个变量，而不是一个包
```

- go有一个名为error的内置类型

-----------

## 9.短变量声明

- 不使用var关键字声明变量，用”:="同时声明变量和进行赋值

```go
v1 := 1
v2,v3 := 2.1,3.3
v4,v5 := 2.3,"string"	//甚至可以分别为不同类型
```

-----

## 10.命名规则

- 变量、函数、类型名
- **一个包中的变量、函数或类型名若为大写，则视为“导出的”，可在其它包中导入并访问之，否则视为“未导出”，只能在当前包使用**

- 命名约定
  - 驼峰命名法、帕斯卡命名法
  - 虽然合法，但不使用蛇形命名法

----

## 11.强制类型转换

- 不同类型之间不可以赋值、运算和比较，可使用强制类型转换转换相关字面值后再进行操作

```go
vInt := 20
vFloat := float64(vInt)
```

--------------

# 控制语句结构

## 1.控制台输入

- bufio/os包 io缓冲和系统包 常用于读取控制台输入

```go
import(
	"bufio"
    "os"
)
// bufio.Reader 类型，用于输入
func main(){
    reader:=bufio.NewReader(os.Stdin) //创建一个读取键盘输入的Reader对象
    input : err= reader.ReadString('\n') //读取用户输入的字符串，直到读到换行符时后停下,返回两个参数，后一个参数用于判断函数运行是否出错
}
```

* go语言可以返回多个值，经常会返回一个额外的错误值，用于确定方式是否运行正确

```go
vBool,err:=strconv.ParseBool("true")	//如果字符串不能转换为bool类型，则返回一个错误
file,err:=os.open("myFile.txt") //若文件无法打开，则返回一个错误
response,err:=thhp.Get("http://golang.org")//若无法检索网页，则返回一个错误
```

- 可以使用空白标识符 "_" 忽略错误返回值，常常用于接受不需要使用的返回值

```go
input, _ = reader.ReadString('\n')
```

- 在使用多个变量同时接受一个函数的返回值时，可以使用":="符号赋值已经定义的变量，但使用的多个变量中必须至少有一个未定义的

```go
var str string
reader := bufio.NewReader(os.Stdin)
str,err := reader.ReadString('\n') //err未定义，即使str已经定义了，使用:=也不会报错
```

```go
var str string
var err error
str,err:=reader.ReadString('\n') //str、err都已经定义了再使用:=符号会报错，这里应该使用”=“赋值符号
```





------

## 2.错误处理

- 接受函数返回的err后，可使用log包的Fetal()函数记录错误信息并终止程序

```go
input,err = reader.ReadString('\n')
log.Fatal(err)	//打印错误信息并退出程序
```

- 即使没有出现错误，Fatal函数执行后也会退出程序，可使用条件控制语句控制程序的条件

```go
if err != nil {
    log.Fatal(err)
}
```



----------

## 3.条件控制语句

- 条件语句结构、

  if 条件语句 { 语句块 }

```go
if true {
    ...
}
if false {
    ...
}
if 1 > 2 {
    ...
}

if grade == 100 {
    ...
}else if grade == 90 {
    
}else {
    
}
```

- go的条件不需要圆括号括起来，使用go fmt处理后的代码会删去相关括号，除非括号用于改变运算顺序
- 逻辑运算符

|  ！  |  非  |
| :--: | :--: |
|  &&  |  与  |
| \|\| |  或  |

------

## 4.字符串转换为数字

- strings包有一个TrimSpace函数，用于去除掉字符串的开头和结尾的空白字符（包括换行、制表、空格等），参数是字符串，返回值是新的字符串

```go
s:= "\n\t shot! \t \n"
fmt.Println(strings.TrimSpace(s))
```

- 通常输入后去掉空白符的串

```go
input := reader.ReadString('\n')
input = strings.TrimSpace(input)
```

- strconv包的ParseFloat函数可将字符串转化为float64值

```go
grade,err:=strconv.ParseFloat(input,64)	//参数为要转换的字符串和结果的精度位数
```

- ParseInt将字符串转化为int值

```go
num,_ := strcnov.Parsr.Int(input,10,32)//前一个参数为按某进制转换，后一个为精确位数
```

-----------

## 5.块和变量作用域

- 代码块通常用大括号包围，变量定义的位置决定了变量的作用域
- if-else if -else三个代码块中同时使用的变量通常要定义在代码块之外

- go支持变量的嵌套定义，要注意正确使用赋值符号"="，和定义初始化符号":="

```go
var status int = 20
if 1 > 2 {
	status := 30 //定义了新的变量，不是原来的变量
	fmt.Println(status)
} else {
	status := 40	//定义了新的变量
	fmt.Println(status)
}
fmt.Println(status)	//if块内的status已经超出作用域，这里的status结果为20
```





# 常用包、类型、方法总结

- time包

```go
time.Time //类型，用于表示日期和时间
time.Time.Year() //Time值的方法，返回年份信息
```

- strings包

```go
strings.Replacer //类型，用于字符串中相关字符的替换
strings.Replacer.replace() //方法，字符替换
strings.NewReplace('1','2') //创建Replacer类型的对象
	//用法	
	replacer := strings.NewReplacer("1","2");
	newString := replacer.Replace(oldString)
```

- bufio/os包 io缓冲和系统包 常用于读取控制台输入

```go
import(
	"bufio"
    "os"
)
// bufio.Reader 类型，用于输入
func main(){
    reader:=bufio.NewReader(os.Stdin) //创建一个读取键盘输入的Reader对象
    input := reader.ReadString('\n') //读取用户输入的字符串，直到按下enter后停下
}
//os.Stat() 打开一个文件，返回一个FileInfo对象
fileInfo,_ :=os.Stat("my.txt")
fileInfo.Size() //返回文件大小
```



