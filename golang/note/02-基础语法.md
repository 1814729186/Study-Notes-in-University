# 基础

## 1 go程序结构

- 每个go文件都已packge子句开头，标记文件所属的包名

```go
package main //直接从终端运行代码，必须使用“main”包名
```

- import语句用于导入其他包，包名用双引号括起来，可借助括号一次导入多个包

```go
import "fmt"
import (
	"main"
    "strings"
)
```

- go文件的最后一部分是代码，可定义多个函数func，其中main函数是程序的入口函数

- 典型文件结构布局如下

```go
//package 子句
//import 语句
//函数、代码
```

## 2 函数调用

```go
包名.函数名(参数)
```

- fmt.println()函数，可传递多个参数，语句会在同一行打印，完成后换行

```go
fmt.println("A","B");
```

- 函数返回值

```go
math.floor(2.75)//参数为一个小数，返回向下取整后的值
string.Title("hello world")//参数为字符串，函数将每个单词首字母替换成大写再返回新的字符串
```

------------------

## 3.字符串

- 使用字符串字面量来i定义字符串

```go
"This is a string"
```

- 字符串中可使用转义字符表达控制含义

```go
"name \t price \t number \n"
```

--------------

## 4.符文rune

- 用于表示单个字符，单引号括起来

```go
's'
```

- go语言使用Unicode编码储存字符

- 直接将rune传入fmt.Println函数，会打印出其编码值，而不是字符

```go
fmt.Println('1')
//输出 49
```

--------

## 5.布尔值

- 取值为true/false

---------

## 6.数字

- 整型/浮点型 使用小数点进行区分

----------

## 7.类型

- 使用reflect.TypeOf()函数可以判断参数类型（返回字符串）

```go
reflect.TypeOf(42)
//int
reflect.Typeof(3.1415)
//float64
//其他类型还有bool string float32(不常用)
```

------------

## 8.变量声明

- 格式

  var 变量名 变量类型

  var 变量名 变量类型 = 初始化赋值

  var 变量名 = 初始化赋值

```go
var v1 int
var v2 float64
var v3 string = "helloworld"
var v4 = 13 //省略变量类型，根据赋值类型自动匹配类型为int型
var v5 = v4+1 //可使用运算结果进行赋值
```

- 可在同一个语句中为多个变量赋值，类似“分别等于“

```go
length,width = 1.2,2.4
```

- 声明但未赋值的变量会自动初始化为”0“值

```go
int -- 0
float64 -- 0.0
bool -- false
string -- ""	//空串
```

- 变量声明可以放在package、import语句之后的任何位置，声明在不同位置代表着不同作用域
- go要求声明的每个变量必须在程序中使用，否则就会报错
- go允许变量名与某些类型名相同，但这会遮盖掉其他名字，导致原本的类型无法使用。命名变量时要避免**遮盖**

```go
import "fmt"
var int int = 12;	//变量名int会遮盖掉int类型名，但不会报错
var fmt string = "ss" //遮盖了包名fmt，即使导入后也不能使用，后续使用fmt的函数会报错，因为此时的fmt为一个变量，而不是一个包
```

- go有一个名为error的内置类型

-----------

## 9.短变量声明

- 不使用var关键字声明变量，用”:="同时声明变量和进行赋值

```go
v1 := 1
v2,v3 := 2.1,3.3
v4,v5 := 2.3,"string"	//甚至可以分别为不同类型
```

-----

## 10.命名规则

- 变量、函数、类型名
- **一个包中的变量、函数或类型名若为大写，则视为“导出的”，可在其它包中导入并访问之，否则视为“未导出”，只能在当前包使用**

- 命名约定
  - 驼峰命名法、帕斯卡命名法
  - 虽然合法，但不使用蛇形命名法

----

## 11.强制类型转换

- 不同类型之间不可以赋值、运算和比较，可使用强制类型转换转换相关字面值后再进行操作

```go
vInt := 20
vFloat := float64(vInt)
```

--------------

# 条件、循环

## 1.控制台输入

- bufio/os包 io缓冲和系统包 常用于读取控制台输入

```go
import(
	"bufio"
    "os"
)
// bufio.Reader 类型，用于输入
func main(){
    reader:=bufio.NewReader(os.Stdin) //创建一个读取键盘输入的Reader对象
    input : err= reader.ReadString('\n') //读取用户输入的字符串，直到读到换行符时后停下,返回两个参数，后一个参数用于判断函数运行是否出错
}
```

* go语言可以返回多个值，经常会返回一个额外的错误值，用于确定方式是否运行正确

```go
vBool,err:=strconv.ParseBool("true")	//如果字符串不能转换为bool类型，则返回一个错误
file,err:=os.open("myFile.txt") //若文件无法打开，则返回一个错误
response,err:=thhp.Get("http://golang.org")//若无法检索网页，则返回一个错误
```

- 可以使用空白标识符 "_" 忽略错误返回值，常常用于接受不需要使用的返回值

```go
input, _ = reader.ReadString('\n')
```

- 在使用多个变量同时接受一个函数的返回值时，可以使用":="符号赋值已经定义的变量，但使用的多个变量中必须至少有一个未定义的（短变量声明中只有一个变量必须是新的）

```go
var str string
reader := bufio.NewReader(os.Stdin)
str,err := reader.ReadString('\n') //err未定义，即使str已经定义了，使用:=也不会报错
```

```go
var str string
var err error
str,err:=reader.ReadString('\n') //str、err都已经定义了再使用:=符号会报错，这里应该使用”=“赋值符号
```





------

## 2.错误处理

- 接受函数返回的err后，可使用log包的Fetal()函数记录错误信息并终止程序

```go
input,err = reader.ReadString('\n')
log.Fatal(err)	//打印错误信息并退出程序
```

- 即使没有出现错误，Fatal函数执行后也会退出程序，可使用条件控制语句控制程序的条件

```go
if err != nil {
    log.Fatal(err)
}
```



----------

## 3.条件控制语句

- 条件语句结构、

  if 条件语句 { 语句块 }

```go
if true {
    ...
}
if false {
    ...
}
if 1 > 2 {
    ...
}

if grade == 100 {
    ...
}else if grade == 90 {
    
}else {
    
}
```

- go的条件不需要圆括号括起来，使用go fmt处理后的代码会删去相关括号，除非括号用于改变运算顺序
- 逻辑运算符

|  ！  |  非  |
| :--: | :--: |
|  &&  |  与  |
| \|\| |  或  |

------

## 4.字符串转换为数字

- strings包有一个TrimSpace函数，用于去除掉字符串的开头和结尾的空白字符（包括换行、制表、空格等），参数是字符串，返回值是新的字符串

```go
s:= "\n\t shot! \t \n"
fmt.Println(strings.TrimSpace(s))
```

- 通常输入后去掉空白符的串

```go
input := reader.ReadString('\n')
input = strings.TrimSpace(input)
```

- strconv包的ParseFloat函数可将字符串转化为float64值

```go
grade,err:=strconv.ParseFloat(input,64)	//参数为要转换的字符串和结果的精度位数
```

- ParseInt将字符串转化为int值

```go
num,_ := strcnov.Parsr.Int(input,10,32)//前一个参数为按某进制转换，后一个为精确位数
```

-----------

## 5.块和变量作用域

- 代码块通常用大括号包围，变量定义的位置决定了变量的作用域
- if-else if -else三个代码块中同时使用的变量通常要定义在代码块之外

- go支持变量的嵌套定义，要注意正确使用赋值符号"="，和定义初始化符号":="

```go
var status int = 20
if 1 > 2 {
	status := 30 //定义了新的变量，不是原来的变量
	fmt.Println(status)
} else {
	status := 40	//定义了新的变量
	fmt.Println(status)
}
fmt.Println(status)	//if块内的status已经超出作用域，这里的status结果为20
```

-----

## 6.随机数生成

- math/rand包中的rand.Intn(max)可生成int随机数，范围为[0,max-1]
- 使用time包中的Now().Unix()函数设置随机数种子，增强随机性

```go
import "math/rand"
rand.seed(time.Now().Unix())//Now()函数获得现在的时间，Unix()函数将时间转化为整数时间戳
rand.Intn(100) //生成0-99之间的随机数
```

---

## 7.循环

- for循环

```go
for i:=0;i<10;i++{
    ...
}
```

- 运算符 +=、-=等也可用于for循环中用于增量计数。使用时注意i的作用于范围
- 初始化和标志post语句是可选的，但条件表达式必须有

```go
for ;true;{ //死循环
    ...
}
```

- continue / break语句可控制循环的执行可跳出

---

# 调用、函数

## 1.格式化输出

- fmt.Printf()函数常用于格式化输出，用法基本同C

```go
fmt.Printf("About one-three: %.2\n",1.0/3.0)
```

| 格式化动词 | 输出                                           |
| ---------- | ---------------------------------------------- |
| %f         | 浮点数                                         |
| %d         | 十进制整数                                     |
| %s         | 字符串                                         |
| %t         | 布尔值（true、false）                          |
| %v         | 任何值（根据所提供的值的类型选择适当的格式）   |
| %#v        | 任何值，按其在Go程序代码中显示的格式进行格式化 |
| %T         | 所提供值的类型（int、string等）                |
| %%         | 百分号输出                                     |

- %#v可将不可见的空字符按照Go语言中显示的形式打印出来

```go
fmt.Printf("%#v","\t") //输出 "\t"
fmt.Printf("%v","\t")	//输出不可见
//注意，若使用%#v输出字符，会输出其编码
fmt.Printf("%#v",'\t') //输出 9
```

- 格式化动词基本形式  % {-} {a}.{b} 类型符
  - 其中 {-} 表示对其方式，默认右对齐，添加“-”号表示采用左对齐
  - 其中{a}表示字段最小显示宽度（若宽度超过a，也会占用超过a的宽度）
  - 其中{b}表示精确度，显示到小数点后b位

- fmt.Sprintf()函数用于格式化字符串，参数传递与Printf相同，返回一个字符

---

## 2.函数声明

- 格式：

  func 函数名 ( 参数列表 )  返回类型{

   函数体 

  } 

- 若函数的首字母大写，则该函数时可导出的，可被其他包访问

- 参数列表格式为：参数名 参数类型 {，参数列表}

---

## 3.函数返回值

- 使用关键字return返回需要的函数返回值
- 若声明了返回类型，则函数体结尾必须有return语句。不声明返回类型，则不能返回值。返回值类型必须与声明类型匹配

- 函数可存在多个返回值，声明时使用括号括起来多个类型，return语句后面的值用逗号隔开

```go
func func1()(int,bool,string){
    return 10,true,"hello"
}
```

- 许多方法会返回一个error对象，函数中可使用error.New()方法创建error对象，并作为返回值

```go
func func2()(string,error){
	err := error.New("My error")
    fmt.Println(err.Error())	//打印错误信息 等同于fmt.Println(err)
	return "func2",err //将创建的err返回
}
```

- 返回值也可以命名，便于增强可读性，格式为：返回值名 返回值类型

```go
func func3()(length float64,width float64){
    return 2.3,3.3
}
```

- go语言函数的形参使用“值传递”方式

---

## 4.指针

- 地址运算符 “&“ ，用于获取变量的地址

* 指针类型用 ”* 类型“ 表示

```go
var myPointer *int
var myInt int = 2
myPointer = &myInt //指针赋值
myPointer2 := &myInt
```

- 对于一个指针，用*符号访问其指向地址的变量

```go
fmt.Print(*myPointer)	//打印myPointer指针指向的位置储存的信息
fmt.Print(myPointer)	//打印地址
*myPointer = 3 //给指针位置变量赋值
```

---

## 5.函数指针

- 可以从函数返回指针，声明函数返回类型为指针类型即可

```go
func createPointer() *float64 {
    var myFloar = 98.5
    return &myFloat
}
```

- go语言中，返回一个指向函数局部变量的指针是可行的，即使该变量不在作用域内，只要仍然拥有该指针，go将确保可访问该值

```go
func main() {
	pointer := createPointer()
	fmt.Println(pointer)
	fmt.Println(*pointer)
}
func createPointer() *float64 {
	myFloat64 := 98.5
	fmt.Println(&myFloat64)
	return &myFloat64
}
/*
0xc000018098
0xc000018098
98.5
*/
```



# 代码集 包

## 1.使用包在程序之间共享代码

工作区目录结构

- go-workspace	工作区目录
  - bin	保存可执行文件
  - pkg    保存已经编译的包代码
  - src  ——保存源代码
    - package1
      - test.go

包命名规范 —— 全部小写

包使用目录结构进行划分，可以嵌套，导入时也需要嵌套按级导入

---

## 2.常量

- 常量使用const关键字进行赋值，不能使用短变量声明法

```go
const 变量名 类型 = 值
const 变量名 = 值
```

- 赋值后，常量的值不能再改变

---

## 3.go install命令安装程序可执行文件

- 使用go run命令会编译程序以及它所依赖的所有包，然后才执行，编译完成后，会丢弃掉编译的代码
- go build命令进行编译并把可执行文件保存在当前目录中（不常使用）

```ssh
$ go build -o 输出文件 go文件  //也可将文件输出到特定目录
```

- go install命令会将可执行文件保存在易于访问的特定位置（通常为bin目录）

---

## 4.使用GOPATH环境变量更改工作区

- 定义GOPATH环境变量后可以在当前终端中更方便地访问GOPATH中的已有代码

---

## 5.使用go get命令下载安装包

- 使用URL作为导入路径，则可使用go get命令自动下载和安装云端的包

```go
import(
	"github.com/headfirstgo/greeting"
)
```







# 常用包、类型、方法总结

- time包

```go
time.Time //类型，用于表示日期和时间
time.Time.Year() //Time值的方法，返回年份信息
```

- strings包

```go
strings.Replacer //类型，用于字符串中相关字符的替换
strings.Replacer.replace() //方法，字符替换
strings.NewReplace('1','2') //创建Replacer类型的对象
	//用法	
	replacer := strings.NewReplacer("1","2");
	newString := replacer.Replace(oldString)
```

- bufio/os包 io缓冲和系统包 常用于读取控制台输入

```go
import(
	"bufio"
    "os"
)
// bufio.Reader 类型，用于输入
func main(){
    reader:=bufio.NewReader(os.Stdin) //创建一个读取键盘输入的Reader对象
    input := reader.ReadString('\n') //读取用户输入的字符串，直到按下enter后停下
}
//os.Stat() 打开一个文件，返回一个FileInfo对象
fileInfo,_ :=os.Stat("my.txt")
fileInfo.Size() //返回文件大小
```



