# 基础

## 1 go程序结构

- 每个go文件都已packge子句开头，标记文件所属的包名

```go
package main //直接从终端运行代码，必须使用“main”包名
```

- import语句用于导入其他包，包名用双引号括起来，可借助括号一次导入多个包

```go
import "fmt"
import (
	"main"
    "strings"
)
```

- go文件的最后一部分是代码，可定义多个函数func，其中main函数是程序的入口函数

- 典型文件结构布局如下

```go
//package 子句
//import 语句
//函数、代码
```

## 2 函数调用

```go
包名.函数名(参数)
```

- fmt.println()函数，可传递多个参数，语句会在同一行打印，完成后换行

```go
fmt.println("A","B");
```

- 函数返回值

```go
math.floor(2.75)//参数为一个小数，返回向下取整后的值
string.Title("hello world")//参数为字符串，函数将每个单词首字母替换成大写再返回新的字符串
```

------------------

## 3.字符串

- 使用字符串字面量来i定义字符串

```go
"This is a string"
```

- 字符串中可使用转义字符表达控制含义

```go
"name \t price \t number \n"
```

--------------

## 4.符文rune

- 用于表示单个字符，单引号括起来

```go
's'
```

- go语言使用Unicode编码储存字符

- 直接将rune传入fmt.Println函数，会打印出其编码值，而不是字符

```go
fmt.Println('1')
//输出 49
```

--------

## 5.布尔值

- 取值为true/false

---------

## 6.数字

- 整型/浮点型 使用小数点进行区分

----------

## 7.类型

- 使用reflect.TypeOf()函数可以判断参数类型（返回字符串）

```go
reflect.TypeOf(42)
//int
reflect.Typeof(3.1415)
//float64
//其他类型还有bool string float32(不常用)
```

------------

## 8.变量声明

- 格式

  var 变量名 变量类型

  var 变量名 变量类型 = 初始化赋值

  var 变量名 = 初始化赋值

```go
var v1 int
var v2 float64
var v3 string = "helloworld"
var v4 = 13 //省略变量类型，根据赋值类型自动匹配类型为int型
var v5 = v4+1 //可使用运算结果进行赋值
```

- 可在同一个语句中为多个变量赋值，类似“分别等于“

```go
length,width = 1.2,2.4
```

- 声明但未赋值的变量会自动初始化为”0“值

```go
int -- 0
float64 -- 0.0
bool -- false
string -- ""	//空串
```

- 变量声明可以放在package、import语句之后的任何位置，声明在不同位置代表着不同作用域
- go要求声明的每个变量必须在程序中使用，否则就会报错
- go允许变量名与某些类型名相同，但这会遮盖掉其他名字，导致原本的类型无法使用。命名变量时要避免**遮盖**

```go
import "fmt"
var int int = 12;	//变量名int会遮盖掉int类型名，但不会报错
var fmt string = "ss" //遮盖了包名fmt，即使导入后也不能使用，后续使用fmt的函数会报错，因为此时的fmt为一个变量，而不是一个包
```

- go有一个名为error的内置类型

-----------

## 9.短变量声明

- 不使用var关键字声明变量，用”:="同时声明变量和进行赋值

```go
v1 := 1
v2,v3 := 2.1,3.3
v4,v5 := 2.3,"string"	//甚至可以分别为不同类型
```

-----

## 10.命名规则

- 变量、函数、类型名
- **一个包中的变量、函数或类型名若为大写，则视为“导出的”，可在其它包中导入并访问之，否则视为“未导出”，只能在当前包使用**

- 命名约定
  - 驼峰命名法、帕斯卡命名法
  - 虽然合法，但不使用蛇形命名法

----

## 11.强制类型转换

- 不同类型之间不可以赋值、运算和比较，可使用强制类型转换转换相关字面值后再进行操作

```go
vInt := 20
vFloat := float64(vInt)
```

--------------

# 条件、循环

## 1.控制台输入

- bufio/os包 io缓冲和系统包 常用于读取控制台输入

```go
import(
	"bufio"
    "os"
)
// bufio.Reader 类型，用于输入
func main(){
    reader:=bufio.NewReader(os.Stdin) //创建一个读取键盘输入的Reader对象
    input : err= reader.ReadString('\n') //读取用户输入的字符串，直到读到换行符时后停下,返回两个参数，后一个参数用于判断函数运行是否出错
}
```

* go语言可以返回多个值，经常会返回一个额外的错误值，用于确定方式是否运行正确

```go
vBool,err:=strconv.ParseBool("true")	//如果字符串不能转换为bool类型，则返回一个错误
file,err:=os.open("myFile.txt") //若文件无法打开，则返回一个错误
response,err:=thhp.Get("http://golang.org")//若无法检索网页，则返回一个错误
```

- 可以使用空白标识符 "_" 忽略错误返回值，常常用于接受不需要使用的返回值

```go
input, _ = reader.ReadString('\n')
```

- 在使用多个变量同时接受一个函数的返回值时，可以使用":="符号赋值已经定义的变量，但使用的多个变量中必须至少有一个未定义的（短变量声明中只有一个变量必须是新的）

```go
var str string
reader := bufio.NewReader(os.Stdin)
str,err := reader.ReadString('\n') //err未定义，即使str已经定义了，使用:=也不会报错
```

```go
var str string
var err error
str,err:=reader.ReadString('\n') //str、err都已经定义了再使用:=符号会报错，这里应该使用”=“赋值符号
```





------

## 2.错误处理

- 接受函数返回的err后，可使用log包的Fetal()函数记录错误信息并终止程序

```go
input,err = reader.ReadString('\n')
log.Fatal(err)	//打印错误信息并退出程序
```

- 即使没有出现错误，Fatal函数执行后也会退出程序，可使用条件控制语句控制程序的条件

```go
if err != nil {
    log.Fatal(err)
}
```



----------

## 3.条件控制语句

- 条件语句结构、

  if 条件语句 { 语句块 }

```go
if true {
    ...
}
if false {
    ...
}
if 1 > 2 {
    ...
}

if grade == 100 {
    ...
}else if grade == 90 {
    
}else {
    
}
```

- go的条件不需要圆括号括起来，使用go fmt处理后的代码会删去相关括号，除非括号用于改变运算顺序
- 逻辑运算符

|  ！  |  非  |
| :--: | :--: |
|  &&  |  与  |
| \|\| |  或  |

------

## 4.字符串转换为数字

- strings包有一个TrimSpace函数，用于去除掉字符串的开头和结尾的空白字符（包括换行、制表、空格等），参数是字符串，返回值是新的字符串

```go
s:= "\n\t shot! \t \n"
fmt.Println(strings.TrimSpace(s))
```

- 通常输入后去掉空白符的串

```go
input := reader.ReadString('\n')
input = strings.TrimSpace(input)
```

- strconv包的ParseFloat函数可将字符串转化为float64值

```go
grade,err:=strconv.ParseFloat(input,64)	//参数为要转换的字符串和结果的精度位数
```

- ParseInt将字符串转化为int值

```go
num,_ := strcnov.Parsr.Int(input,10,32)//前一个参数为按某进制转换，后一个为精确位数
```

-----------

## 5.块和变量作用域

- 代码块通常用大括号包围，变量定义的位置决定了变量的作用域
- if-else if -else三个代码块中同时使用的变量通常要定义在代码块之外

- go支持变量的嵌套定义，要注意正确使用赋值符号"="，和定义初始化符号":="

```go
var status int = 20
if 1 > 2 {
	status := 30 //定义了新的变量，不是原来的变量
	fmt.Println(status)
} else {
	status := 40	//定义了新的变量
	fmt.Println(status)
}
fmt.Println(status)	//if块内的status已经超出作用域，这里的status结果为20
```

-----

## 6.随机数生成

- math/rand包中的rand.Intn(max)可生成int随机数，范围为[0,max-1]
- 使用time包中的Now().Unix()函数设置随机数种子，增强随机性

```go
import "math/rand"
rand.seed(time.Now().Unix())//Now()函数获得现在的时间，Unix()函数将时间转化为整数时间戳
rand.Intn(100) //生成0-99之间的随机数
```

---

## 7.循环

- for循环

```go
for i:=0;i<10;i++{
    ...
}
```

- 运算符 +=、-=等也可用于for循环中用于增量计数。使用时注意i的作用于范围
- 初始化和标志post语句是可选的，但条件表达式必须有

```go
for ;true;{ //死循环
    ...
}
```

- continue / break语句可控制循环的执行可跳出

---

# 调用、函数

## 1.格式化输出

- fmt.Printf()函数常用于格式化输出，用法基本同C

```go
fmt.Printf("About one-three: %.2\n",1.0/3.0)
```

| 格式化动词 | 输出                                           |
| ---------- | ---------------------------------------------- |
| %f         | 浮点数                                         |
| %d         | 十进制整数                                     |
| %s         | 字符串                                         |
| %t         | 布尔值（true、false）                          |
| %v         | 任何值（根据所提供的值的类型选择适当的格式）   |
| %#v        | 任何值，按其在Go程序代码中显示的格式进行格式化 |
| %T         | 所提供值的类型（int、string等）                |
| %%         | 百分号输出                                     |

- %#v可将不可见的空字符按照Go语言中显示的形式打印出来

```go
fmt.Printf("%#v","\t") //输出 "\t"
fmt.Printf("%v","\t")	//输出不可见
//注意，若使用%#v输出字符，会输出其编码
fmt.Printf("%#v",'\t') //输出 9
```

- 格式化动词基本形式  % {-} {a}.{b} 类型符
  - 其中 {-} 表示对其方式，默认右对齐，添加“-”号表示采用左对齐
  - 其中{a}表示字段最小显示宽度（若宽度超过a，也会占用超过a的宽度）
  - 其中{b}表示精确度，显示到小数点后b位

- fmt.Sprintf()函数用于格式化字符串，参数传递与Printf相同，返回一个字符

---

## 2.函数声明

- 格式：

  func 函数名 ( 参数列表 )  返回类型{

   函数体 

  } 

- 若函数的首字母大写，则该函数时可导出的，可被其他包访问

- 参数列表格式为：参数名 参数类型 {，参数列表}

---

## 3.函数返回值

- 使用关键字return返回需要的函数返回值
- 若声明了返回类型，则函数体结尾必须有return语句。不声明返回类型，则不能返回值。返回值类型必须与声明类型匹配

- 函数可存在多个返回值，声明时使用括号括起来多个类型，return语句后面的值用逗号隔开

```go
func func1()(int,bool,string){
    return 10,true,"hello"
}
```

- 许多方法会返回一个error对象，函数中可使用error.New()方法创建error对象，并作为返回值

```go
func func2()(string,error){
	err := error.New("My error")
    fmt.Println(err.Error())	//打印错误信息 等同于fmt.Println(err)
	return "func2",err //将创建的err返回
}
```

- 返回值也可以命名，便于增强可读性，格式为：返回值名 返回值类型

```go
func func3()(length float64,width float64){
    return 2.3,3.3
}
```

- go语言函数的形参使用“值传递”方式

---

## 4.指针

- 地址运算符 “&“ ，用于获取变量的地址

* 指针类型用 ”* 类型“ 表示

```go
var myPointer *int
var myInt int = 2
myPointer = &myInt //指针赋值
myPointer2 := &myInt
```

- 对于一个指针，用*符号访问其指向地址的变量

```go
fmt.Print(*myPointer)	//打印myPointer指针指向的位置储存的信息
fmt.Print(myPointer)	//打印地址
*myPointer = 3 //给指针位置变量赋值
```

---

## 5.函数指针

- 可以从函数返回指针，声明函数返回类型为指针类型即可

```go
func createPointer() *float64 {
    var myFloar = 98.5
    return &myFloat
}
```

- go语言中，返回一个指向函数局部变量的指针是可行的，即使该变量不在作用域内，只要仍然拥有该指针，go将确保可访问该值

```go
func main() {
	pointer := createPointer()
	fmt.Println(pointer)
	fmt.Println(*pointer)
}
func createPointer() *float64 {
	myFloat64 := 98.5
	fmt.Println(&myFloat64)
	return &myFloat64
}
/*
0xc000018098
0xc000018098
98.5
*/
```

----

# 代码集 包

## 1.使用包在程序之间共享代码

工作区目录结构

- go-workspace	工作区目录
  - bin	保存可执行文件
  - pkg    保存已经编译的包代码
  - src  ——保存源代码
    - package1
      - test.go

包命名规范 —— 全部小写

包使用目录结构进行划分，可以嵌套，导入时也需要嵌套按级导入

---

## 2.常量

- 常量使用const关键字进行赋值，不能使用短变量声明法

```go
const 变量名 类型 = 值
const 变量名 = 值
```

- 赋值后，常量的值不能再改变

---

## 3.go install命令安装程序可执行文件

- 使用go run命令会编译程序以及它所依赖的所有包，然后才执行，编译完成后，会丢弃掉编译的代码
- go build命令进行编译并把可执行文件保存在当前目录中（不常使用）

```ssh
$ go build -o 输出文件 go文件  //也可将文件输出到特定目录
```

- go install命令会将可执行文件保存在易于访问的特定位置（通常为bin目录）

---

## 4.使用GOPATH环境变量更改工作区

- 定义GOPATH环境变量后可以在当前终端中更方便地访问GOPATH中的已有代码

---

## 5.使用go get命令下载安装包

- 使用URL作为导入路径，则可使用go get命令自动下载和安装云端的包

```go
import(
	"github.com/headfirstgo/greeting"
)
```

---

## 6.go doc阅读包文档

- 终端使用go doc + 包导入路径包名 查看包文档

* doc注释可以用于记录包
  * 在package语句前可使用行注释，函数定义语句前使用单行注释可将注释信息置入doc中
  * 包注释应该以Package开头，后跟包名，再跟注释
  * 函数注释应该以函数名开头，注释中可以包含示例代码，doc文档会把注释信息解读为纯文本

- 可以在web浏览器中查看doc文档
- 使用”godoc“指令可生成html格式的doc文档

----

# 列表 数组

## 1.数组创建和使用

- 基本格式：var 数组名 [数量] 类型

```go
var primes [5]int
```

- 创建一个数组时，会默认将所有值都初始化为”0“值

* 数组的定义个初始化：var 数组名[数量] 类型 = [数量] 类型 {字面量列表}
* 数组的短变量声明：数组名 := [数量] 类型 {字面量列表}

```go
var weekdays[7]string = [7]strings{"Monday","Tuesday","Wednesday","Thursday","Friday","Saturday","Sunday"}
notes := [7]string{"do","re","mi","fa","so","la","ti"}	//短变量声明
texts :=[2]string{
    "Hello,everyone!",
    "how are you!",	//这种格式下，末尾的逗号时必须的
}
```

- 直接用变量数组进行打印，可以直接打印出数组中含有的所有值，使用"%v"进行格式化输入亦同
- 使用"%#v"进行格式化输出时，会输出包括长度、类型等更多信息

```gi
fmt.Println(texts)
//[Hello,everyone! how are you!]
fmt.Printf("%#v",texts)
//[2]string{"Hello,everyone!", "how are you!"}
```

---

## 2.使用len函数检查数组长度

- len(数组变量名)

```go
length = len(texts)
```

---

## 3.遍历数组

- 一般遍历

```go
for i=0;i<len(texts);i++{
    fmt.Println(texts[i])
}
```

- for range遍历

```go
for index,value := range texts{
    //每轮遍历中index保存遍历的元素的下标
    //value保存元素的值
}
```

* for range中也可以使用空白标识符

```go
for _ ,value := range texts{    
}
for index,_ := range texts{
}
```

---

## 4.读取文本文件

* os.Open()打开文件	bufio.NewScanner()创建扫描器	scanner.Scan()扫描文件并返回布尔值	scanner.Text()返回扫描内容 file.close()关闭文件	scanner.Err()检查扫描错误信息 

```go
//使用os.Open()打开文件
file,err := os.Open("data.txt")
if err != nil {
    log.Fatal(err)
}
//bufio.NewScanner()创建文件的扫描器
scanner := bufio.NewScanner(file)
//scanner.Scan()从文件中读取一行
for scanner.Scan(){ //sacnner.Scan()返回布尔值
    fmt.Println(scanner.Text())	//使用scanner.Text()访问扫描到的字符串
}
//file.Close()关闭文件
err = file.Close()
if err != nil{
    log.Fatal(err)
}
//scanner.Err()扫描文件时若出现错误，则报告错误并退出
if scanner.Err() != nil{
    log.Fatal(scanner.Err())
}
```

---

## 5.将文本文件读入数组

- strconv.ParseFloat()可将字符串转换成float数

- 可以将读取文件的代码封装成一个函数，返回一个读取后生成的数组

```go
func GetFloats(filePath string) ([3]float64, error) {
	var numbers [3]float64
	file, err := os.Open(filePath)
	if err != nil {
		return numbers, err
	}
	scanner := bufio.NewScanner(file)
	for i := 0; scanner.Scan() && i < 3; i++ {
		numbers[i], err = strconv.ParseFloat(scanner.Text(), 64)
		if err != nil {
			return numbers, err
		}
	}
	err = file.Close()
	if err != nil {
		return numbers, err
	}
	return numbers, scanner.Err()
}
```

----

# 追加问题 切片

## 1.切片

- 声明数组变量时，可不指定数组大小，声明一个**切片变量**

```go
var notes []string
```

- 声明切片变量并不会创建切片，需要使用make函数创建。make([]类型，数量)

```go
notes = make([]string,7)
```

- 也可使用短变量声明，同时声明和创建切片

```go
notes := make([]string,7)
primes := []int{1,2,3}	//直接赋值
```

* 数组的基本用法都可用于切片变量

---

## 2.切片运算符

- 每一个切片都构建于一个底层的数组之上，实际上是底层的数组存储了切片的数据，切片的数据仅仅是数组的一部分
- 当使用make函数或者切片字面量创建一个切片的时候，底层的数组会自动创建出来（只有通过切片才能访问）。也可以自己创建一个数组，然后同通过切片运算符创建一个切片。切片运算符：[a:b]，意义为取切片[a,b)

```go
var myArray [4]int
mySlice:=myArray[1:3]
```

- 切片相当于一个指针，对切片中的元素进行修改会影响到原数组，使用make或者切片字面量来创建切片，就可以不考虑底层数组了
- 切片运算符[a:b]中的a,b均可以是缺省的，甚至可以同时缺省，切片默认会从开始到结束

- 注意

```go
var array [4] int = {1,2,3,4}
mySlice := array[:]	//切片，相当于指针
newArray := array 	//创建了一个新的数组newArray，类型和尺寸同array相同，并将相关数据复制了一遍
```

---

## 3.append函数在切片上添加数据***

- append函数可在已有的切片上添加多个数据

```go
slice := []string{"a","b"}
//添加数据,可添加一个或者多个
slice = append(slice,"c","d")
```

- 底层数组的尺寸不能增大
- 使用append函数增长切片
  - 若底层数组长度足够，则会修改底层数组中排在切片最后一个元素后面的值，并增长切片的长度（返回的切片变量）
  - 若底层数组长度不够，则会创建新的数组，使数组长度满足要求，再复制相应的元素，填充append的元素，返回引用新的数组的切片（元素添加是一次性的，若同时添加两个元素，若原数组还有一个元素的空余，则新的切片不会改变原数组的元素值，会直接创建新的数组）

- 若多个切片指向同一个底层数组，则他们的修改和append操作可能会相互影响

---

## 4.切片与零值

- 切片不同于数组，切片的零值为nil

```go
var slice []int //slice的值为nil
len(slice) == 0	//nil的切片，调用len函数会返回0
```

---

## 5.命令行参数

- 访问os.Args变量可以获得命令行参数的切片，包括执行程序的名称（同C），使用[1:]再次切片可得到仅参数列表

```go
func main(){
    fmt.Println(os.Args)	//打印全部命令行参数，包括执行程序的名称
}
```

---

## 6.可变长参数函数

- 在类型前添加省略号(三个点号)，可定义可变长参数的函数

```go
func myFunc(param1 int,param2 ...string){
    ...
}
```

- 可变长参数函数的最后一个参数接收一个切片类型的变长参数，这个切片参数可以被函数当作普通切片来处理

```go
func SumOfFloats64(param ...float64) float64 {
	sum := float64(0.0)
	for _, elem := range param {
		sum += elem
	}
	return sum
}
```

- 定义函数时，可变长参数仅仅只能放在参数列表的最后

- **可以将切片传递为可变长参数的实参**，在切片变量的后面添加省略号...

```go
float64Slice := []int{1.1,2.2,3.3}
SumOfFloats64(float64Slice...)
```

- 数组不能直接作为实参传递给可变长参数，但可以经过切片转化再传

```go
var floatArray [3]float64 = [3]float64{1.1, 2.2, 3.3}
fmt.Println(util.SumOfMany(floatArray[:]...))	//数组转为切片再传递
```

---

# 标签数据 映射

* 键和值的映射关系，键可使用可比较的多种类型
* map关键字用于创建映射关系：var map [ 键类型 ] 值类型

```go
var myMap [string] float64 //声明一个映射变量，不会创建一个映射
map = make(map[string]float64) //创建一个映射

ranks := make(map[string]int) //创建一个映射，并声明一个用于保存它的变量 
```

- 映射几乎可以选择所有类型来作为键

```go
//赋值
ranks["gold"] = 1
ranks["sliver"] = 2
ranks["bronze"] = 3
//访问
fmt.Println(ranks["gold"])
```

- 可以使用映射字面量来创建映射

```go
myMap := map[string]float64{
	"a":1.2,
	"b",5.6,
}//也可以单行写
emptyMap := map[string]float64 //创建一个空的映射
```

- 映射变量的零值为nil，没有被赋值的键元素默认为“0”值

- 访问映射键的时候可选地获得第二个布尔值，若改键被赋过值，则会返回true，否则会返回false

```go
counters := map[string]int{"a":3,"b",0}
value,ok := counters["b"]	//赋过值，ok会返回true
value,ok = counters["c"]	//未赋过值，value会返回零值，ok会为false

//检测是否赋过值
_,ok = counters["d"]
if ok {
    ...//赋过值
}

```

- delete函数可用于删除键值对：delete ( 映射变量名，键值 ) 

```go
ranks := make(map[string]int)
ranks["bronze"] = 3
//删除
delete(ranks,"bronze")
```

- 可以对映射进行for range循环：for key,value := range myMap { ... } 

---



# 构建存储 struct

## 1.struct结构体

- 构建结构体语法

  struct {

  ​	字段名称1	字段类型1

  ​	字段名称2	字段类型2

  }

- 可以使用一个struct类型作为变量类型，构建结构体的同时创建变量

  var 变量名 struct {

  ​	字段名称	字段类型

  ​	...

  }

- 可以使用%#v格式化直接输出结构体中各个字段的值。每个字段默认赋予“0值”

---

## 2.结构体字段访问

- 用点号访问结构体变量的字段：变量名 . 字段名
- 结构体字段名若首字母大写，则视为可导出的，可以在包外访问；否则不能在包外访问。但包外也可以使用fmt.Println()打印出来

---

## 3.结构体命名

- 使用type关键字对结构体类型进行命名

  type 结构体名 struct{

  ​	字段名	字段类型

  }

- 命名后，可使用结构体名直接定义变量：var 变量名 结构体名

- 结构体类型作为参数传递给函数是，仍旧是值传递；可使用取址符号*定义指针，并利用&传址

```go
type MyStruct struct {
	paramInt     int
	paramFloat64 float64
	str          string
}
func AlterAddrStruct(s *MyStruct) {
	(*s).str = "sss"	//也可以直接用s.str访问字段
	(*s).paramInt = 999
	(*s).paramFloat64 = 3.3
}
func main(){
    var s MyStruct
    util.AlterAddrStruct(&s)	//传址，修改字段值
}
```

- 可以在一个包中定义struct类型，另一个包中使用（类型名需要大写）。此时用 “包名.类型名” 表示结构体类型

- **Struct类型的名称首字母大写才能导出该类型，字段的名称首字母大写才能导出该字段**

---

## 4.使用struct字面量创建struct变量

- struct字面量：struct类型名 { 字段名 : 值 , 字段名 : 值 , ... }

```go
myCar := car{name:"Corvette",topSpeed:337}
```

- 字面量的指定时可以忽略一些字段，此时变量的相关字段会默认设置为“0值”

- struct类型可以作为另一种struct的字段，访问字段时可能需要多级访问

---

## 5.匿名struct字段

- struct匿名字段：字段没有名字，仅仅只有类型。定义时移除字段名称，仅保留字段类型

```go
type Address struct{
    ...
}
type Subscriber struct{
    Name string
    Rate float64
    Active bool
    Address	//仅保留类型，省略字段名
}
```

- 当声明一个匿名字段时，可以使用字段类型名作为该字段的名称进行访问，同一个struct内不能存在两个同类型的匿名字段，（匿名字段时，小写的类型名视为不可导出的）

```go
var p1 Subscriber
p1.Address	//访问匿名字段
```

- 匿名字段不只是使struct定义中省略了字段名称，一个内部struct使用匿名字段的方式储存在外部的struct中，这称为**嵌入**了外部struct，嵌入struct的字段被提升到了外部struct，你可以像访问外部struct字段一样访问他们。就好像没有内嵌一样

```go
type Address struct {
	int
	string
	Code string
	Str  string
}
type MyStruct struct {
	ParamInt     int
	ParamFloat64 float64
	Str          string
	Address		//匿名字段
}
fun main(){
    var s MyStruct
	s.Str = "sss"	//当匿名字段类型中存在相同名称的字段时，会优先访问外层的字段，即访问Mystruct.Str,若要访问内部的Str，则需要用MyStruct.Address.Str
}

```

---

# 定义类型

## 1.具有底层基础类型的定义类型

- 如某些相同物理量的不同单位具有不同的转换进制，如加仑（Gallon）和升（Liter） （1加仑 ≈ 3.785升）

- 油的量都可以用float64表示，但使用不同的单位会表示出不同的量

```go
type Litters float64	//基于float64定义了新的类型Litters，表示油的量，单位为升
type Gallons float64	//基于float64定义了新的类型Gallons，表示油的量，单位为加仑
```

- 可以使用类型转换将float64类型转换为Litters类型，再赋给Litters类型变量

```go
var carFuel Litters		//创建变量
carFuel = Litters(240.0)	//变量赋值
//也可以使用短变量声明
busFeul := Gallons(10.0)
```

- 本类型的字面量不能直接赋给另一个类型的字面量，但基于同一基础类型的字面量可以经过类型转换后赋给另一个类型

```go
carFule = Litters(Gallons(63.0)*3.785)
```

- 一个定义类型提供所有与基础类型相同的运算符，如基于float64类型，提供+，-，*，/，==，<，>运算。基于string类型则提供+，==，>，<运算。
- 一个定义类型可以直接和其对应的基础类型直接运算，但基于同一种基础类型的两种类型不能直接相互运算，需要先转换成相同类型后再进行计算

---

## 2.使用函数进行类型转换

- 可以创建toLitters和toGallons函数来完成单位转换

```go
func ToGollons(l Litters)Gallons{
    return Gollons(l.0.264)
}
func ToLitters(g Gallons)Litters{
    return Litters(g.3.785)
}
```

---

## 3.使用方法完成类型转换

- 方法定义：func ( 接收器参数名称 接收器参数类型 ) 方法名 ( 参数列表 ) { 方法体 }

```go
func (g Gallons)ToLitters() Litters{
    return Litters(g*3.785)
}

func (l Litters)ToGallons() Gallons{
    return Gollons(l*0.264)
}
```

- 方法调用：类型变量/字面量 . 方法名 ( 参数列表 )

```go
busFuel := Litters(4.5)
busFeul.ToGallons() 	//转换为gallon
```

- 方法被定义在某个类型，则他就能被该类型的值调用。可以将接收器参数视作一个参数（相当于其他语言中的this、self）。接收器参数通常使用类型的首字母的小写来命名。
- 方法类似于一个函数。方法名首字母大写，则认为是可导出的，否则不可导出
- 接收器参数同样使用值传递的方式，若想修改接收器的相关值，则需要定义接收器为指针。在调用时，可以直接用类型变量调用之，值类型会自动转为指针。同理，定义为值类型接收器时，使用指针进行调用，也会自动将其转换为值

```go
type MyType string

func (m MyType) method(){	//接收器参数为值类型
    fmt.Println("Method with value receiver")
}
func (m *MyType)pointerMethod(){	//接收器参数类型为指针类型
    fmt.Println("Method with pointer receiver")
}
func main(){
    value := MyType("a value")
    pointer := &value
    value.method()
    value.pointerMethod()	//值类型自动转换为指针
    pointer.method()
    pointer.pointerMethod()	//指针类型自动转换为值
    
}
```

- 完成将值类型转化为指针的操作，需要获取该类型值的指针地址。字面量还未存入变量中，不能用其调用指针类型接收器的方法。而使用值类型接收器的方法没有这种需求

```go
MyType("value").pointerMethod()	//不能获得指针，报错
Mytype("vv").Method()	//不报错，可正常运行
```

---

# 封装、嵌入

- 定义不可导出的struct字段，通过Setter、Getter方法进行赋值和访问操作，防止出现不合法的情况
- **setter方法必须使用指针接收器**

* 通常将setter方法设置为一个error返回值，在不合法的时候返回一个错误

```go
func (d *Date)SetYear(year int) error{
    if year < 0 {
        return errors.New("Invalid year")
    }
    //设置year字段
    d.year = year
    return nil
}
```

* 对于getter方法，为了与setter相一致，同样使用指针接收器

```go
func (d *Date)GetYear() int {
    return d.year
}
```

- 封装：将程序中的数据隐藏在一部分代码中，而对另一部分代码不可见。封装可用于防止无效数据

- 使用类型嵌入时，未导出的字段不会被提升，不能快捷访问
- 匿名嵌入的struct中导出的方法可以像字段样被提升，可以使用方法对字段进行访问

---

# 接口

- go语言中，一个接口被定义为特定值预期具有的一组方法，可以把接口看作需要类型实现的一组行为

## 1.接口定义

- 接口定义关键字：interface

  type 接口名 interface {

  ​	方法名 ( 参数列表 ) 返回值类型

  ​	...

  }

```go
type myInterface interface{
    method1()
    method2(int)int
}
```

- 当一个类型要实现一个接口，则必须实现接口中声明的所有函数（名称、参数列表、返回值必须分别完全相同）
- 一个类型可以实现（满足）多个接口

---

## 2.定义满足接口的类型









# 常用包、类型、方法总结

- time包

```go
time.Time //类型，用于表示日期和时间
time.Time.Year() //Time值的方法，返回年份信息
```

- strings包

```go
strings.Replacer //类型，用于字符串中相关字符的替换
strings.Replacer.replace() //方法，字符替换
strings.NewReplace('1','2') //创建Replacer类型的对象
	//用法	
	replacer := strings.NewReplacer("1","2");
	newString := replacer.Replace(oldString)
```

- bufio/os包 io缓冲和系统包 常用于读取控制台输入

```go
import(
	"bufio"
    "os"
)
// bufio.Reader 类型，用于输入
func main(){
    reader:=bufio.NewReader(os.Stdin) //创建一个读取键盘输入的Reader对象
    input := reader.ReadString('\n') //读取用户输入的字符串，直到按下enter后停下
}
//os.Stat() 打开一个文件，返回一个FileInfo对象
fileInfo,_ :=os.Stat("my.txt")
fileInfo.Size() //返回文件大小
```



