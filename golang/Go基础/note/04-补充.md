## 1.os.OpenFile()

- os.OpenFile()函数用于打开文件，函数原型如下。

```go
func OpenFile(name string,flag int,perm FileMode) (*File,error)
```

- int类型的flag用于表示打开文件使用的标志，标明文件用于读写、创建、追加等。
  - O_RDONLY：只读模式打开文件；
  - O_WRONLY：只写模式打开文件；
  - O_RDWR：读写模式打开文件；
  - O_APPEND：写操作时将数据附加到文件尾部（追加）；
  - O_CREATE：如果不存在将创建一个新文件；
  - O_EXCL：和 O_CREATE 配合使用，文件必须不存在，否则返回一个错误；
  - O_SYNC：当进行一系列写操作时，每次都要等待上次的 I/O 操作完成再进行；
  - O_TRUNC：如果可能，在打开时清空文件。
- 标志量事实上是一个int类型的常量，每位标志量占用不同的二进制位，若需要多个标志，可以使用或运算来复合
- 追加必须和写标志一起传入，否则会报错

```go
option := O_WRONLY | O_APPEND | O_CREATE	//只写、追加、创建方式打开文件.如果没有追加，则会覆盖式地写入。并且追加必须和写标志一起传入，否则会报错
OpenFile("file.txt",option,os.FileMode(0600))
```

- perm类型的FileMode参数表明文件权限

- 每个文件具有三组权限，影响三个不同类型的用户。第一组权限适用于拥有该文件的用户，第二组权限用于分配给该文件的用户组，第三组适用于系统上的其他用户。分别用一位来进行表示

```go
fmt.Println(os.FileMode(0700))	// -rwx------
fmt.Println(os.FileMode(0070))	// ----rwx---
fmt.Println(os.FileMode(0007))	// -------rwx
//7的二进制为 0111 后三个1表示用户组同时具有全部权限,这里的0777是八进制表示法
//os.FileMode(0700) 将八进制数转换为 表示用户权限的字符串（如上的打印结果）
```

- FileMode有一个unit32的基础类型，可以使用类型转换将几乎任何整数转换为FileMode值。
- Unix的chmod指令可用于更改文件权限

## 2.二进制、八进制表示法

- 二进制的格式化动词 **%b**
- 八进制的格式化动词**%o**

---

## 3.位运算符

- 按位与 &
- 按位或 |



---

## 4.if的初始化语句

- if语句可以同时初始化和执行判断分支

```go
/*
if 初始化;条件{
    ...
}
*/
if count:=5;count>4{
    fmt.Println("count is", count)
}
```

- 这里需要注意的是初始化时若定义了变量，变量的作用域只在if的语句块内

```go
if number,err:=strconv.ParseFloat("3.14",64);err!=nil{
    log.Fatal(err)
}
```

---

## 5.switch语句

- **Go语言的break不需要break语句**

- switch 表达式 {

  ​	case 常量：

  ​		...

  ​	case 常量:

  ​		...

  ​	defautl:

  ​		...

  }	

```go
switch rand.Intn(3)+1{
    case 1:
    	fmt.Println("1")
    case 2:
    	fmt.Println("2")
    default:
    	fmt.Println("3")
}
```

---

## 6.更多基本类型

- 整型
  - int8
  - int16
  - int32
  - int64
- 非负整型
  - unit
  - unit8
  - unit16
  - unit32
  - unit64
- 浮点数
  - float32

---

## 7.符文rune和字符串

- Go语言使用utf-8表示字符信息，每个字符使用1-4个字节。
- 每个ASCII字符可使用1字节表示，每个Unicode字符使用2个字符表示

```go
len("ABCDE") = 5	//将字符串传给函数len返回的是字节数而不是字符数
len("阿波吃的哥") = 10
```

- 将宗福传传给函数len()返回的是字节数而不是字符数。utf-8的字符数应该使用函数unicode/utf8包中的utf8.RuneCountInString()函数来进行判断

```go
utf8.RuneInString("阿波吃的个") = 5
```

- ASCII编码的字符串可以转换成 []byte切片进行处理

```go
asciiString := []byte("ABCDE")
```

- 若其他rune编码使用[]byte进行处理可能会造成错误，因为不是一个rune占用一字节
- Go支持将字符串转换为rune的切片或将rune切片转换为字符串（rune切片可根据字符表示方式对字符进行拆分，无论是ASCII编码或者是Unicode编码都可以使用rune切片进行表示）

```go
asciiRunes := []rune("abcde")
utf8Runes := []rune("阿波吃的个")
asciiString := string(asciiRunes)	//转换为字符串
utf8String := string(utf8Runes[3:])	//取一部分切片转换为字符串
```

- 使用for ... range语句对字符串进行处理时，处理单位是rune而不是byte

---

## 8.有缓冲的channel

- Go有两种chennel，有缓冲的和无缓冲的
  - 在无缓冲的channel上发送值时，它会立即阻塞，直到另一个goroutine接收到该值
  - 有缓冲的channel可以在导致发送的goroutine阻塞之前保存一定数量的值，在适当的情况下可以提高程序的性能
- 在创建channel时，可以通过make函数传递第二个参数来创建有缓冲的channel，该参数包含channel应该能够在其缓冲区中保存的值的数量

```go
channel := make(chan string,3)
```

- 当goroutine通过channel发送一个值时，该值被添加到缓冲区中，发送的goroutine将继续运行而不被阻塞
- 发送的goroutine可以继续在channel上发送值，直到缓冲区被填满，此时额外的发送操作才会导致goroutine被阻塞，同样的，当缓存区空时，额外的接收操作也会导致goroutine阻塞
- 带缓冲的channel可以看作一个队列，一个goroutine向队列中添加元素，另一个goroutine从队列中读出元素







