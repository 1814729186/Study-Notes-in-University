# goroutine 和 channel

## 1.检索网页

- go可使用net/http包连接到一个站点，并通过几个函数调用检索一个web页面
- 将站点URL传给http.get函数，将返回一个http.Response对象

- http.Response对象是一个struct，其Body字段表示页面的内容，body满足io包的ReadCloser接口，它有一个Read方法（读取页面数据）和一个Close方法（完成时释放网络连接）

```go
func main(){
    response,err:=http.Get("https://example.com")
    if err !=nil{
        log.Fatal(err)
    }
    defer response.Body.Close()
    body,err:=ioutil.ReadAll(response.Body)
    if err!= nil{
        log.Fatal(err)
    }
    fmt.Println(string(body))
    //存入文件
    //创建文件
	workSpace := "F:\\" //工作目录
	file, err := os.OpenFile(workSpace+"example.html", os.O_WRONLY|os.O_CREATE, 0666)
	if err != nil {
		fmt.Println("文件创建失败")
		log.Fatal(err)
	}
	defer file.Close()
	write := bufio.NewWriter(file)
	write.WriteString(string(body))
	write.Flush()
}
```

---

## 2.多任务

- go中并发任务称为goroutine，其比线程需要更少的计算机内存，启动和停止的时间更少，小号资源更少
- 要启动一个goroutine，仅需要添加关键字go即可

```go
go myFunction()	//goroutine函数调用
```

- 事实上，main函数的运行也是一个goroutine

```go
func a(){
    for i:=0;i < 50;i ++{
        fmt.Print("a")
    }
}
func b(){
    for i:=0;i<50;i++{
        fmt.Print("b")
    }
}
func main(){
    go a()
    go b()
    for i := 0;i < 50;i ++{
        fmt.Print("c")
    }
    time.Sleep(time.Second) //强制停顿1S
    fmt.Println("\nend main")
}
```

- 使用goroutine不能使用返回值，param := go myFunc()	之类的语句会报错
- 由main函数创建的goroutine会在main函数退出后自动强制结束，故应该在main函数中添加同步控制语句

```go
time.Sleep(time.Second) //强制阻塞1s再唤醒
```

- 可使用channel来完成各个goroutine的同步和通信
  - 创建一个channel
  - 编写一个函数，该函数接受一个channel作为参数。我们将在一个单独的goroutine中运行该函数，并使用它通过channel发送值
  - 在初始的goroutine中接受发送的值
- 每个channel尽可以携带特定类型的值，使用chan关键字声明channel变量：var 变量名 chan 类型名

```go
var myChannel chan float64	//声明携带loat64类型值的channel变量
myChannel = make(chan float64) //实际创建一个channel
//也可以使用短变量声明
myChannel := make (chan float64)
```

### 使用channel发送值和接收值

- 发送值，使用 <- 运算符： channe变量 <- 要发送的值

```go
myChannel <- 3.14	//通过channel发送3.14
```

- 接收值： <- channel变量

```go
func greeting(myChannel chan string){
    myChannel <- "hi"	//使用channel发送
}
func main(){
    myChannel := make(chan string)
    go greeting(myChannel)
    fmt.Println(<-myChannel)	//使用channel接收
    //也可以使用变量进行接收
    str := <-myChannel
}
```

- 使用channel时，go会控制并发顺序，确保接收channel值之时，channel值“恰好”准备好
- channel通过阻塞当前goroutine中的所有进一步操作。发送操作阻塞发送goroutine，直到另一个goroutine在同一channel上执行了接收操作。反之，接收操作阻塞接收goroutine，直到另一个goroutine在同一channel上执行了发送操作。
- 同一个channel可以多次传值和接收，每一次阻塞都是按顺序一发一收执行同步操作的。

- channel可携带struct

```go
type Page struct{
    URL string
    Size int
}
func responseSize(url string,channel chan Page){
    channel <- Page(URL:url,Size:len(body))	//发送channel
}
func main(){
    pages:=make(chan Page)
    urls := []string{"https://example.com","https://golang.org","https://golang.org/doc"}
    for _ , url := range urls{
        go responseSize(url,pages)	//循环中创建goroutine
    }
    for i:=0; i<len(urls) ; i ++{
        page:=<- pages	//循环中接收channel
        fmt.Printf("%s:%d\n",page.URL,page.Size)
    }
}
```

---

# 自动化测试

- 利用go的testing包和go test工具编写自动化测试

## 1.一个应该有自动化测试的函数

- 自动化测试使用一组特定的输入运行代码，并寻找特定的结果。只要代码的输出与期望值匹配，则测试将通过。

---

## 2.编写测试

- Go包含一个testing包，可以用来为代码编写自动化测试。go test命令可用于运行这些测试

- 测试文件中的代码由普通的Go函数组成，但需要遵循一定的约定才能使用go test工具

  - go test工具查找测试文件是以_test.go为后缀查找测试文件的，故应创建源代码的副本文件，命名为：

    原名_test.go

    再编写测试代码

  - 不需要将测试代码与正在测试的代码放在同一个包中，除非想从包中访问非导出的函数或类型

  - 测试文件需要使用testing包中的类型，需要导入testing包

  - 测试函数名应该以Test开头

  - 测试函数应该接受单个参数：一个指向testing.T的指针

  - 可以通过对testing.T值调用方法（如Error）来报告测试失败。大多数方法都接受一个字符串，其中包含测试失败的原因

- 测试函数由Test开头，测试函数中对有必要测试的函数进行测试，传入参数，将其返回值与期望值进行比较，如果不符合预期，则调用t.Error()输出错误信息。

- 测试函数中也可以调用其他不以Test开头的函数用来支持测试功能

```go
func TestTwoElements(t *testing.T){
    list := []string{"apple","orange"}
    if JoinWithCommas(list) != "apple and orange"{	//测试函数JoinWithCommas(),与预期输出进行比较，不匹配则输出错误
        t.Error("didn't match expected value")
    }
}
```

---

## 3.运行测试

- 使用go test命令运行测试，它将在包目录中查找_test.go为后缀的文件，并运行以Test开头的文件中包含的每个函数
- 运行时，会在t.Error()函数运行所在位置打印出错误信息和所在行数
- 如果没有出现错误，将打印输出ok

---

## 4.使用Errorf方法获得更详细的测试失败消息

- 与Error不同，Errorf接受一个带格式化动词的字符串，可以使用Errorf在测试的失败消息中包含其他信息，例如传递给函数的参数，得到的返回值和期望的返回值

---

## 5.运行特定的测试集

- go test提供两个命令行标志来运行特定测试集而不是整个
- -v 标志 （verbose-详细的）列出运行每个测试函数的名称和状态，verbose模式下，即使是通过的测试信息也会被输出
- -run 标志 在run后面指定部分或者全部的函数名，就可以只运行名称与指定的名称匹配的测试函数

```ssh
$ go test github.com/headfirstgo/prose -v -run Two //运行名称中带有Two的测试
```

---

## 6.表驱动测试

- 定义测试用类型testData，储存测试输入和期望输出，建立testData表，遍历表元素对代码进行测试。可大大缩短代码量

```go
type testData struct {
    inputs []string
    want string
}
tests := []testData{}	//创建表，在表中添加元素
```

- 测试集注意包含多种情况，即使是空输入也要考虑到

---

# 响应请求 Web应用程序

- go标准包提供Web应用程序托管

## 1.用go编写Web应用程序

- 将使用到net/http包

- 比起html文件通讯形式，现在更常见的是与程序通信来完成请求而不是直接读取文件
- 客户端发送请求，服务器接收，服务器启动程序获得应答，再将应答返回给客户端

```go
//一个简单的web应用程序
func viewHandler(writer http.ResponseWriter, request *http.Request) {
    //http.ResponseWriter用于更新将发送到浏览器响应的值
    //*http.Request 表示来自浏览器请求的值
	message := []byte("Hello,web!")
	_, err := writer.Write(message)
	if err != nil {
		log.Fatal(err)
	}
}
func main() {
	http.HandleFunc("/hello", viewHandler)//如果接收到一个以"/hello"结尾的URL请求，就调用一个viewHandler函数来生成响应
    //监听浏览器请求，并对其做出响应
	err := http.ListenAndServe("localhost:8080", nil)//IP地址//端口号	
	log.Fatal(err)
}
```

- 在浏览器URL界面生成输入localhost://8080即可访问该应用程序

- 在控制台按下ctrl + c即可退出程序
- 大多数web服务器监听80端口上的http请求，默认情况下We浏览器会将HTTP请求发送到80端口，但在许多操作系统上，出于安全原因，需要特殊的权限才能运行监听80端口的服务

- http.ListenAndServer()会一直运行，除非遇到错误
- 在viewHandler中，通过调用ResponseWriter上的write方法向响应添加数据，write函数不接受字符串，但它接收byte值的切片，因此需要将字符串转化为[]byte，然后将其传递给Write

```go
message := []byte("Hello,web!")
_,err := writer.Write(message)
if err != nil {
	log.Fatal(err)
}
```

- byte也可以转换为string

```go
str := string([]byte{'h','e','l','l','o'})
```

---

## 2.资源路径

- 服务器中由不同资源可以发给浏览器，包括HTML页面，图像等
- 调用http.HandleFunc()时，将字符串和处理函数传给它。字符串用作要查找请求的资源路径。
- 可以编写不同的函数，配合不同的资源路径传给http.HandleFunc()函数以对不同访问请求做出不同反应

---

## 3.一级函数

- 当用handler函数调用http/HandleFunc时，我们不会调用handler函数并将其结果传给HandleFunc，而是将函数本身传给HandleFunc。函数被储存起来，以便之后再接收到匹配的请求路径时调用。

```go
func main(){
    http.HandleFunc("/hello",englishHandler)
    http.HandleFunc("/salut",frenchHandler)
    http.HandleFunc("/namaste",hindiHandler)
    err := http.ListenAndServer("localhost:8080",nil)
    log.Fatal(err)
}
```

- Go语言支持有一级函数，在具有一级函数的编程语言中，可以将函数分配给变量，然后从这些变量中调用函数。(相当于函数指针)

```go
func sayHi(){
    fmt.Println("Hi")
}
func main(){
    var myFunction func()	//声明一个类型为func()的变量，该变量可以保存一个函数
    myFunction = sayHi()	//将sayHi函数赋值给变量
    myFunction()			//调用储存在变量中的函数
}
```

- 函数同样也可以作为参数传递给其他函数

```go
func twiceDo(theFunction func()){
    theFunction()
    theFunction()
}
//调用时将函数名作为参数传入twiceDo()
func sayHi(){}
func main(){
    twiceDo(sayHi)
}
```

- 函数形式也可以作为一种类型，不同函数类型区别于参数列表和返回值类型。定义函数形参后，不同类型的函数参数不能作为实参。例如func()类型的函数不能传给http.HandleFunc()函数作为第二个参数

```go
var myFunc func(int,int) float64	//变量为一种函数类型，该类型是——有两个int参数，和一个float64返回值
```

- 指定类型的变量也只能储存（指向）匹配类型的函数，否则就会报错

---

# HTML模板

- Web应用程序需要使用HTML而不是纯文本进行响应，Go语言提供html/template包将数据插入到HTML代码中

## 1.留言簿应用程序

- 为网站建立一个留言簿应用程序，访问者能够以表单的形式输入信息，该表单将被保存到文件中，还可以从网站查看之前所有签名的列表。
- 全部代码
- guestbook.go

```go
//guestbook.go
package main

import (
	"bufio"
	"fmt"
	"html/template"
	"log"
	"net/http"
	"os"
)
//签名簿的储存类型
type Guestbook struct {
	SignatureCount int      //储存签名总数
	Signatures     []string //保存签名本身
}

//封装一下error的检查
func check(err error) {
	if err != nil {
		log.Fatal(err)
	}
}
func viewHandler(writer http.ResponseWriter, request *http.Request) {
	signatures := getStrings("signatures.txt")            //从文件中读取签名
	html, err := template.ParseFiles("../html/view.html") //基于“view.html”的内容创建一个模板
	check(err)
	//创建变量储存读入的信息
	guestbook := Guestbook{SignatureCount: len(signatures), Signatures: signatures}
	err = html.Execute(writer, guestbook) //将数据倒入模板，并将结果写入ResponseWriter
	check(err)
}
func newHandler(writer http.ResponseWriter, request *http.Request) {
	html, err := template.ParseFiles("../html/new.html") //从模板加载html表格
	check(err)
	err = html.Execute(writer, nil) //将模板写入ResponseWriter（）没有要插入的数据
	check(err)
}
func createHandler(writer http.ResponseWriter, request *http.Request) {
	signature := request.FormValue("signature") //获取signature表单字段的值
	options := os.O_WRONLY | os.O_APPEND | os.O_CREATE
	file, err := os.OpenFile("signatures.txt", options, os.FileMode(0600)) //打开文件进行追加，如果存在就进行追加，如果不存在就创建它
	check(err)
	_, err = fmt.Fprintln(file, signature) //将表单字段内容添加到文件中
	check(err)
	err = file.Close()
	check(err)
	http.Redirect(writer, request, "/guestbook", http.StatusFound) //将浏览器重定向到主留言簿页面
}
//从文件中获取字符串切片
func getStrings(fileName string) []string {
	var lines []string             //文件的每一行都将作为字符串追加到切片中
	file, err := os.Open(fileName) //打开文件
	if os.IsNotExist(err) {        //文件不存在时
		return nil
	}
	check(err)
	defer file.Close()
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		lines = append(lines, scanner.Text())
	}
	check(scanner.Err())
	return lines
}
func main() {
	http.HandleFunc("/guestbook", viewHandler)          //查看签名列表的请求
	http.HandleFunc("/guestbook/new", newHandler)       //获取HTML表单的请求
	http.HandleFunc("/guestbook/create", createHandler) //提交表单的请求
	fmt.Println("load")
	err := http.ListenAndServe("localhost:8080", nil)
	log.Fatal(err)
}

```

- new.html

```html
<h1>Add a Signature</h1>
<form action = "/guestbook/create" method="POST">   <!--提交将转到前述路径，提交将使用POST方法-->
    <div><input type = "text" name = "signature"></div> <!--文本字段，可在signature名字下访问-->
    <div><input type="submit"></div>    <!--提交按钮-->
</form>
```

- view.html

```html
<h1>Guestbook</h1>  <!--一级标题-->
<div>
    <!--点值时Guestbook struct，在这里插入其SignatureCount字段-->
    {{.SignatureCount}} total signatures -
    <a href = "/guestbook/new">Add Your Signature</a>   <!--路径链接-->
</div>

<div>
    <!--从Guestbook.struct的Signatures字段中获取切片，并对包含的每个字符串进行重复-->
    {{range .Signatures}}
    <p>{{.}}</p>    <!--对每个元素都会重复该操作，“点”被设置为当前签名字符串，插入包含签名的HTML paragraph元素-->
    {{end}}
</div>
```







# 常用工具

## 1.文件读写

- 打开文件

```go
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
```

其中 name 是文件的文件名，如果不是在当前路径下运行需要加上具体路径；flag 是文件的处理参数，为 int 类型，根据系统的不同具体值可能有所不同，但是作用是相同的。

- 下面列举了一些常用的 flag 文件处理参数：
  - O_RDONLY：只读模式打开文件；
  - O_WRONLY：只写模式打开文件；
  - O_RDWR：读写模式打开文件；
  - O_APPEND：写操作时将数据附加到文件尾部（追加）；
  - O_CREATE：如果不存在将创建一个新文件；
  - O_EXCL：和 O_CREATE 配合使用，文件必须不存在，否则返回一个错误；
  - O_SYNC：当进行一系列写操作时，每次都要等待上次的 I/O 操作完成再进行；
  - O_TRUNC：如果可能，在打开时清空文件。

- 文件读写

  借助bufio.NewReader()和bufio.NewWriter()进行读写

- 缓存文件真正写入

  writer.Flush()

- 关闭文件

  file.Close()

```go
func main() {
    //创建一个新文件，写入内容 5 句 “http://c.biancheng.net/golang/”
    filePath := "e:/code/golang.txt"
    file, err := os.OpenFile(filePath, os.O_WRONLY|os.O_CREATE, 0666)
    if err != nil {
        fmt.Println("文件打开失败", err)
    }
    //及时关闭file句柄
    defer file.Close()
    //写入文件时，使用带缓存的 *Writer
    write := bufio.NewWriter(file)
    for i := 0; i < 5; i++ {
        write.WriteString("http://c.biancheng.net/golang/ \n")
    }
    //Flush将缓存的文件真正写入到文件中
    write.Flush()
}
```

