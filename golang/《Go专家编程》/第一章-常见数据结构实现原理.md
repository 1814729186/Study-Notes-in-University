## channel

【ˈtʃænl】渠道，通过通道，传输

- channel是Golang在语言层面提供的Goroutine键的通信方式，比Unix管道更易用也更轻便，channel主要用于进程内各goroutine间通信，如果要跨进程通信，建议使用分布式系统的方法来解决。

  ### 1.chan数据结构定义

  ```go
  //src/runtime/chan/.go:hchan定义了channel的数据结构
  type hchan struct {
      qcount unit 		//当前队列中剩余元素个数
      dataqsiz unit 		//环形队列长度（可存放的元素个数）
      buf unsafe.Pointer	//环形队列指针
      elemsize uint16		//每个元素大小
      closed unit32		//标识关闭状态
      elemtype *_type		//元素类型
      
      sendx unit			//队尾指针下标，写入时的位置（指向空位置）
      recvx unit			//队首指针下标，读出时的位置
      
      recvq waitq			//等待读消息的goroutine队列
      sendq waitq			//等待写消息的goroutine队列
      
      lock mutex			//互斥锁，chan不允许并发读写
  }
  ```


- chan数据结构实际上维护了一个循环队列用于发送和接收协程数据，维护两个协程队列用于进程的调度，此外，还设置了mutex互斥锁实现访问的互斥
- 从channel读数据，如果channel缓冲区为空或者没有缓冲区，当前goroutine会被阻塞。向channel写数据，如 果channel缓冲区已满或者没有缓冲区，当前goroutine会被阻塞。被阻塞的goroutine将会挂在channel的等待队列中。
  - 因读阻塞的goroutine会被向channel写入数据的goroutine唤醒； 
  - 因写阻塞的goroutine会被从channel读数据的goroutine唤醒；

### 2.chan实际使用

#### 2.1 创建channel

- 创建hchan的过程实际上是初始化hchan结构。其中类型信息和缓冲长度由make语句传入，buf的大小则与元素大小和缓冲区长度共同决定

```go
func makechan(t *chantype,size int) *hchan{
    var c *hchan
    c = new(hchan)
    c.buf = malloc("元素类型大小"*size)
	c.elemsize = "元素类型大小"
    c.elemtype = "元素类型"
    c.dataqsize = size
    
    return c
}
```





