# 字节跳动面试准备

## 一、面经一

一面

- **进程和线程，细节、区别、原理**

线程是进程的一部分，描述指令流执行状态。它是进程中的指令执行流的最小单位，是CPU调度的基本单位。

线程优点：1.一个进程中可以同时存在多个线程。2.各个线程之间可以并发的执行。3.各个线程之间可以共享地址空间和文件等资源
线程缺点：一个线程崩溃，会导致其所属进程的所有线程崩溃

**进程是资源分配单位，线程是CPU调度单位**
进程拥有一个完整的资源平台，而线程只独享指令流执行的必要资源，如寄存器和栈
线程具有就绪，等待和运行三种基本状态和状态间转换关系
**线程能减少并发执行的时间和空间开销：线程的创建时间比进程短；线程的终止时间比进程短；同一进程内的线程切换时间比进程短；由于同一进程的各线程间共享内存各文件资源，可以不通过内核进行直接通信**

线程的实现方式

1.**用户线程**：在用户空间实现
POSIX Pthreads,Mach C-threads,Solaris threads
	由一组用户级的线程库函数来完成线程的管理，包括线程的创建，终止，同步和调度等
特征：不依赖于操作系统内核（内核不了解用户线程的存在；可用于不支持线程的多进程操作系统）。在用户空间实现的线程机制（每个进程有私有的线程控制块列表；TCB由线程库函数维护）。同一进程内的用户线程切换速度快（无需用户态/内核态的切换）。允许每个进程拥有自己的线程调度算法
缺点：线程发起系统调用而阻塞时，整个进程进入等待；不支持基于线程的处理机抢占；只能按进程分配CPU时间
2.**内核线程**：在内核中实现
Windows,Solaris,Linux
进程由内核通过系统调用实现的线程机制，由内核完成线程的创建，终止和管理（内核中PCB中有指针指向线程控制块TCB）
特征：由内核维护PCB和TCB。线程执行系统调用而被阻塞不影响其他线程。线程的创建，终止和切换开销相对较大（通过系统调用/内核函数，在内核实现）。以线程为单位进行CPU时间分配（多线程的进程可获得更多的CPU时间）
3.**轻量级进程**：在内核中实现，支持用户线程
Solaris (LightWeight Process)
内核支持的用户线程。一个进程可有一个或多个轻量级进程，每个轻权进程由一个单独的内核线程来支持（Solaris/Linux）

用户线程与内核线程的对应关系：
1.N个用户线程对应N个内核线程；2.N个用户线程对应一个内核线程；3.N个用户线程对应M个内核线程
三种当中，现在的操作系统以第一种为主。

- **TPC和UDP，是否双工等**

TCP的优点： 可靠，稳定 TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源。 TCP的缺点： 慢，效率低，占用系统资源高，易被攻击 TCP在传递数据之前，要先建连接，这会消耗时间，而且在数据传递时，确认机制、重传机制、拥塞控制机制等都会消耗大量的时间，而且要在每台设备上维护所有的传输连接，事实上，每个连接都会占用系统的CPU、内存等硬件资源。 而且，因为TCP有确认机制、三次握手机制，这些也导致TCP容易被人利用，实现DOS、DDOS、CC等攻击。

UDP的优点： 快，比TCP稍安全 UDP没有TCP的握手、确认、窗口、重传、拥塞控制等机制，UDP是一个无状态的传输协议，所以它在传递数据时非常快。没有TCP的这些机制，UDP较TCP被攻击者利用的漏洞就要少一些。但UDP也是无法避免攻击的，比如：UDP Flood攻击…… UDP的缺点： 不可靠，不稳定 因为UDP没有TCP那些可靠的机制，在数据传递时，如果网络质量不好，就会很容易丢包。 基于上面的优缺点，那么： 什么时候应该使用TCP： 当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。 在日常生活中，常见使用TCP协议的应用如下： 浏览器，用的HTTP FlashFXP，用的FTP Outlook，用的POP、SMTP Putty，用的Telnet、SSH QQ文件传输 ………… 什么时候应该使用UDP： 当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。 比如，日常生活中，常见使用UDP协议的应用如下： QQ语音 QQ视频 TFTP ……

有些应用场景对可靠性要求不高会用到UPD，比如长视频，要求速率

**小结TCP与UDP的区别：**

TCP与UDP区别总结：

1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接

2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付

3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的

UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）

4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信

5、TCP首部开销20字节;UDP的首部开销小，只有8个字节

6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道

- **HTTPs和HTTP协议的细节和不同，比如HTTPs的公钥私钥**

**http协议的缺点**

通信使用明文，内容可能被窃听(重要密码泄露)

不验证通信方身份，有可能遭遇伪装(跨站点请求伪造)

无法证明报文的完整性，有可能已遭篡改(运营商劫持)

https是在http协议基础上加入加密处理和认证机制以及完整性保护，即**http+加密+认证+完整性保护=https**
https并非应用层的一种新协议，只是http通信接口部分用**ssl/tls协议**代替而已。通常**http直接和tcp通信**，当使用ssl时则演变成**先和ssl通信，再由ssl和tcp通信**。
所谓https，其实就是身披ssl协议这层外壳的http

SSL 是“Secure Sockets Layer”的缩写，中文叫做“安全套接层”。

SSL协议位于TCP/IP协议与各种应用层协议之间，为数据通讯提供安全支持。SSL协议可分为两层：
	**SSL记录协议**（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。
	**SSL握手协议**（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。

**对称密钥和非对称密钥加成**

​	对称密钥加密，又称私钥加密，即信息的发送方和接收方用同一个密钥去加密和解密数据。它的最大优势是加/解密速度快，适合于对大数据量进行加密，但密钥管理困难。
​	非对称密钥加密，又称公钥加密，它需要使用一对密钥来分别完成加密和解密操作，一个公开发布，即公开密钥，另一个由用户自己秘密保存，即私用密钥。信息发送者用公开密钥去加密，而信息接收者则用私用密钥去解密。
​	从功能角度而言非对称加密比对称加密功能强大，但加密和解密速度却比对称密钥加密慢得多。

**SSL/TLS协议的基本过程**是这样的：

1. 客户端向服务器端索要并验证公钥。
2. 双方协商生成“对话密钥”。
3. 双方采用“对话密钥”进行加密通信。

第一步，爱丽丝给出协议版本号、一个**客户端生成的随机数**（Client random），以及客户端支持的加密方法，具体的加密方法可参考[SSL证书背后的加密算法](https://www.cnblogs.com/cioliuguilan/p/5518798.html)。
第二步，鲍勃确认双方使用的加密方法，并给出数字证书、以及一个**服务器生成的随机数**（Server random）。
第三步，爱丽丝确认数字证书有效，然后生成一个**新的随机数**（Premaster secret），并使用数字证书中的**公钥，加密这个随机数**，发给鲍勃。
第四步，鲍勃使用自己的**私钥**，获取爱丽丝发来的随机数（即Premaster secret）。
第五步，爱丽丝和鲍勃根据约定的加密方法，使用前面的**三个随机数**，生成**"对话密钥"**（session key），用来加密接下来的整个对话过程。

**HTTPS工作原理**

1、客户端发起HTTPS请求
		用户在浏览器里输入一个https网址，然后连接到server的443端口。
2、服务端的配置
		采用HTTPS协议的服务器必须要有一套**数字证书**，可以自己制作，也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面。
3、传送证书
		**这个证书其实就是公钥**，只是包含了很多信息，如证书的颁发机构、证书版本、序列号、签名算法标识符、签发⼈姓名、有效期、公钥信息等并附有CA的签名
4、客户端解析证书
		这部分工作是由客户端的TLS来完成的，首先会**验证公钥是否有效**，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。
（1）首先浏览器读取证书中的证书所有者、有效期等信息进行一一校验
（2）浏览器开始查找操作系统中已内置的受信任的证书发布机构CA，与服务器发来的证书中的颁发者CA比对，用于校验证书是否为合法机构颁发
（3）如果找不到，浏览器就会报错，说明服务器发来的证书是不可信任的。
（4）如果找到，那么浏览器就会从操作系统中取出颁发者CA 的公钥(多数浏览器开发商发布版本时，会事先在内部植入常用认证机关的公开密钥)，然后对服务器发来的证书里面的签名进行解密
（5）浏览器使用相同的hash算法计算出服务器发来的证书的hash值，将这个计算的hash值与证书中签名做对比
（6）对比结果一致，则证明服务器发来的证书合法，没有被冒充
（7）此时浏览器就可以读取证书中的公钥，用于后续加密了
5、传送加密信息
		这部分传送的是**用证书加密后的随机值(私钥)**，目的就是让**服务端得到这个随机值**，以后**客户端和服务端的通信就可以通过这个随机值来进行加密解密**了。
6、服务端解密信息
		服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后**把内容通过该值进行对称加密**
7、传输加密后的信息
		这部分信息是服务端用私钥加密后的信息，可以在客户端被还原。
8、客户端解密信息
		客户端用之前生成的私钥解密服务端传过来的信息，于是获取了解密后的内容，整个过程第三方即使监听到了数据，也束手无策。

- **三次四次握手**

![](C:\Users\18147\Desktop\面试准备\resources\003.png)

1、客户端主动打开，发送连接请求报文段，将SYN标识位置为1，Sequence Number置为x(TCP规定**SYN=1时不能携带数据**，x为随机产生的一个值)，然后进入**SYN_SEND**状态。

2、服务器收到SYN报文段进行确认，将SYN标识位置为1，ACK置为1，Sequence Number置为y，Acknowledgment Number置为x+1，然后进入**SYN_RECV**状态，这个状态被称为**半连接状态**。

3、客户端再进行一次确认，将ACK置为1(此时不用SYN)，Sequence Number置为x+1，Acknowledgment Number置为y+1发向服务器，最后客户端与服务器都进入**ESTABLISHED**状态

![](C:\Users\18147\Desktop\面试准备\resources\004.png)

1、客户端发送一个报文给服务端(没有数据)，其中FIN设置为1，Sequence Number置为u，客户端进入FIN_WAIT_1状态。

2、服务端收到来自客户端的请求，发送一个ACK给客户端，Acknowledge置为u+1，同时发送Sequence Number为v，服务端年进入CLOSE_WAIT状态。

3、服务端发送一个FIN给客户端，ACK置为1，Sequence置为w，Acknowledge置为u+1，用来关闭服务端到客户端的数据传送，服务端进入**LAST_ACK**状态。

4、客户端收到FIN后，进入**TIME_WAIT**状态，接着发送一个ACK给服务端，Acknowledge置为w+1，Sequence Number置为u+1，最后客户端和服务端都进入CLOSED状态。

- **智能指针的细节**

智能指针主要用于**管理在堆上分配的内存**，它**将普通的指针封装为一个栈对象**。当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而**防止内存泄漏**。

- auto_ptr(C++11已弃用，存在潜在的内存崩溃问题！)

- unique_ptr

  - unique_ptr实现**独占式**拥有或严格拥有概念，保证同一时间内**只有一个智能指针可以指向该对象**。它对于避免资源泄露(例如“以new创建对象后因为发生异常而忘记调用delete”)特别有用。unique_ptr比auto_ptr更安全。
  - 另外unique_ptr还有更聪明的地方：当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个**临时右值**，编译器**允许**这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，

- shared_ptr

  shared_ptr实现**共享式**拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在**“最后一个引用被销毁”时候释放**。

  有一点share_ptr智能指针还是有内存泄露的情况，当两个对象相互使用一个shared_ptr成员变量指向对方，会造成**循环引用**，使引用**计数失效**，从而导致内存泄漏。

- weak_ptr

  weak_ptr 是一种不控制对象生命周期的智能指针, 它**指向一个 shared_ptr 管理的对象**. **进行该对象的内存管理的是那个强引用的shared_ptr**， weak_ptr只是**提供了对管理对象的一个访问手段**。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。**weak_ptr是用来解决shared_ptr相互引用时的死锁问题,如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0**,资源永远不会释放。它是**对对象的一种弱引用，不会增加对象的引用计数，**和shared_ptr之间可以相互转化，**shared_ptr可以直接赋值给它**，**它可以通过调用lock函数来获得shared_ptr**。

- **二叉树遍历的非递归写法，现场写**

```c++
//非递归先序
void preOrderTraverse(Tree tree) {
	//先序遍历
	//从栈中取出一个节点，访问，然后压栈右子树，然后压栈左子树
	struct treeNode* stack[MAX_SIZE],*curNode;
	int stackPointer = 0;
	//压栈头节点
	stack[stackPointer++] = tree;
	while (stackPointer) {
		//取出元素
		curNode = stack[--stackPointer];
		//访问
		cout << curNode->val;
		//压栈右子树，压栈左子树
		if(curNode->rightChild) stack[stackPointer++] = curNode->rightChild;
		if(curNode->leftChild)stack[stackPointer++] = curNode->leftChild;
	}
}
//非递归中序
void midOrderTraverse(Tree tree) {
	//中序遍历
	//左子树全部依次进栈直到不存在左子树
	struct treeNode* stack[MAX_SIZE], * curNode;
	int stackPointer = 0;
    curNode = tree;
	do {
		//全部完成压栈
		while (curNode) {
			stack[stackPointer++] = curNode;
			curNode = curNode->leftChild;
		}
		//出栈，访问该节点，并以同样的方式处理其右节点
		if (stackPointer) {
			curNode = stack[--stackPointer];	//出栈
			cout << curNode->val;
			curNode = curNode->rightChild;
		}
	} while (stackPointer||curNode);		//栈非空或者当前仍存在右节点未访问
}
//非递归后续
void postOrderTraverse(Tree tree) {
	//后续遍历
	struct treeNode* pre;	//pre指针
	struct treeNode* stack[MAX_SIZE], * curNode=tree;
	int stackPointer = 0, flag = 0;
	if (!tree) return;
	do {
		//左子树全部入栈
		while (curNode) {
			stack[stackPointer++] = curNode;
			curNode = curNode->leftChild;
		}
		//设置标记和前序指针
		pre = nullptr; flag = 1;
		while (stackPointer && flag) {
			curNode = stack[stackPointer - 1];//检查栈顶元素有没有右子树或者右子树是否已经访问
			if (curNode->rightChild == pre) {	//若右子树已经访问则访问该节点，（也可能没有右子树）
				cout << curNode->val;
				stackPointer--;
				pre = curNode;
			}
			else {
				curNode = curNode->rightChild;	//右子树未访问，则需要先处理右子节点
				flag = 0;
			}
		}
	}while (stackPointer);
}
```

先序遍历：压栈根节点，每轮从栈中取出节点，访问节点，压栈右子树，压栈左子树

中序遍历：从当前节点开始依次压栈所有左子节点，出栈节点进行访问，然后以同样的方式处理出栈节点的右节点

后序遍历：

- **多线程的具体使用和各种同步方法的优劣和不同**

同步方法：（1）互斥锁，（2）条件变量，（3）读写锁，（4）信号量

```c++
std::mutex mtx;	//共享锁变量
mtx.lock();	//加锁
mtx.unlock();//	开锁
thread_local int num;	//线程本地变量
lock_guard<mutex> lock(mtx);	//基于作用域的加锁
lock_guard<mutex> unlock(mtx);	//基于作用域的提前解锁
thread a(函数名);	//创建线程对象
a.join();	//等待线程执行结束
```

1.基于作用域的加锁方式

​	作用域结束时自动释放

2.基于致命区的加锁方式

​	如果致命区出现异常，则可能不执行解锁

- **进程间通信的方法，和socket的不同和相同点**

管道（pipe）,流管道(s_pipe)和有名管道（FIFO）

信号（signal）

消息队列（message queue）

共享内存（shared memory）

信号量（sinal）

套接字（socket) —— 它可用于不同机器间的进程通信.

- **不同操作系统下的进程间通信**

windows系统：文件映射、共享内存、匿名管道、命名管道、邮件槽、剪切板等等

二面

- `malloc`和`calloc`的底层细节

基于 linux 环境下的 malloc 实现:

1）当开辟的空间小于 128K 时，调用 brk（）函数，malloc 的底层实现是系统调用函数 brk（），其主要移动指针 _enddata(此时的 _enddata 指的是 Linux 地址空间中堆段的末尾地址，不是数据段的末尾地址)

2）当开辟的空间大于 128K 时，mmap（）系统调用函数来在虚拟地址空间中（堆和栈中间，称为“文件映射区域”的地方）找一块空间来开辟。

从操作系统角度看，进程分配内存有两种方式，分别由两个系统调用完成：brk 和 mmap (不考虑共享内存)

1）**brk** 是将**数据段**（.data）的最高地址指针 _edata 往高地址推

2）**mmap** 是在进程的**虚拟地址空间中**（堆和栈中间，称为“文件映射区域”的地方）找一块**空闲的虚拟内存**。

这两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系。

- **内存相关，如内存碎片管理和STL大内存的搬运方式，如何优化的，为什么需要优化和内存池等细节**

避免外部碎片：

第一种方案，我们使用地址转换技术，把非连续的物理地址转换成连续的线性地址。
第二种方案，开发一种特有的分配技术来记录下来空闲内存的情况，从而解决内存碎片问题。

Linux采用著名的**伙伴系统(buddy system)算法**来解决外碎片问题。把所有的空闲页框**分组为11个块链表**，每个链表分别包含大小为1,2,4,8,16,32,64,128,256,512,1024个连续的页框，对1024个页框的最大请求对应着4MB大小的连续RAM（每页大小为4KB），每个块的第一个页框的物理地址是该块大小的整数倍，例如，大小为16个页框的块，其起始地址是16*2^12的倍数。

我们通过一个例子来说明伙伴算法的工作原理，假设现在要**请求一个256个页框**的块（1MB），算法步骤如下：

- 在256个页框的链表中检查是否有一个空闲快，如果没有，**查找下一个更大的块**，如果有，请求满足。
- 在512个页框的链表中检查是否有一个空闲块，如果有，把512个页框的空闲块分为两份，**第一份用于满足请求，第二份链接到256个页框的链表中。**如果没有空闲块，继续寻找下一个更大的块。

下图比较形象地描述了该过程。

![](C:\Users\18147\Desktop\面试准备\resources\005.png)

以上过程的**逆过程**，就是页框块的释放过程，也是该算法**名字的由来**，内核试图把**大小为B的一对空闲伙伴块合并为一个2B的单独块**，满足以下条件的两个块称之为伙伴：

​	两个块具有相同的大小

​	他们的物理地址是连续的

​	第一块的第一个页框的物理地址是2 * B * 2^12
 该算法是递归的，如果它成功合并了B，就会试图去合并2B，以再次试图形成更大的块。





- **STL相关很多细节**

  - vector 可变长数组
  - list——双向链表
  - deque —— 双端链表、数组块链表，索引数组
  - set —— 红黑树
  - map —— 红黑树
  - hash_set —— hash表

  **map**内部是红黑树 

  - 元素有序
  - 占用空间更大

  **unordered_map**内部是哈希表 —— 适用于查找密集型

  - 元素无序
  - 查找速度快（较map）
  - hash表的建立比较费时间

- **一个中等难度的算法题**
- **我额外讲了一下操作系统分页方式导致STL内存池的构建**



三面

- **内存管理相关细节**
- **几个代码题，实现智能指针**



## 二、面经二

- **介绍一下你自己**
- **有哪些排序算法**           答：（排序算法都没准备）冒泡、选择、快排、归并等
- **手写一下快排和归并排序，给你10分钟**                   答：没准备，写了20分钟只写出了快拍。。。（漫长的沉默）
- **数据库会吗？**              答：了解一点。
- **数据库ACID知道吗?**



- **数据库用什么数据结构实现的？ ** B+树

- 那**数据库联结操作**知道吗？等值联结？

答：好像忘了。应该是表合并吧。

- 没错，就是将两个表相同键值的元素拼接起来。你**实现一下这个等值联结**，怎么实现？输入的列的某值，输出是整行元素。

- 5.操作系统linux会吗？

- **755什么意思？**

- **进程和线程有什么区别？**
  进程是程序的一次执行，是资源调度单位，一个进程一个PCB；线程更轻量级，可以使用资源，但不能调度资源。

- 那**虚函数和普通函数有什么区别**？
- 问**项目中有没有用数据库**
- 那就是数据库底层不了解咯？           答：对的。
- 那SQL语句会吗                        答：了解一点。
  求：一个班级，某科目的平均成绩大于某值，的科目内容。说明一下SQL语句思路。
         答： SELECT 科目 WHERE 班级=XXX AND AVERAGE(SUBJECT)>XXX

       错了，因为你不知科目有几门
    
       答：建表的时候，几列就表示有几门课（其实SQL语句都忘了）

- **哈希算法用什么数据结构好**。

       答：数组。

- **哈希的时候，如何删除元素？**
  答：哈希下去，到表尾删除元素，或者找到元素，将标记位更改。

- **哈希这个动作是线程安全的吗？**

答：读动作是安全的，写动作不安全，可以加锁。

- **给每个数组中的位置分别加锁，还是一个数组加一把锁。**

答：应该都可以，前者方便，后者可以实现更多的线程并发，但可能产生死锁。

- 写一下**线程的单例设计模式**吧。(私有化构造函数，静态成员变量指向创建的对象，只能创建一个对象)

```c++
class MyCAS //这是一个单例类
{
private:
    MyCAS(){}           //构造函数私有化了
                               //不能创建对象
private:
    static MyCAS *m_instance; //静态成员变量
 
public:
    static MyCAS *GetInstance()
    {
         if(m_instance ==nullptr)
             {
                 m_instance = new MyCAS();
              }
          return m_instance;
    }
};
```

- **100W个数，找出前10个最小的。**

- 长度为N的链表，隔K个数反转一次，例如123456，K为3就会变成321654 —— （头插法，尾插法混合使用）



## 三、面试准备

### （一）.数据库相关

#### 1. 数据库三范式是什么?

第一范式：表中每个字段都不能再分。（**每列不能再分**）

第二范式：满足第一范式并且表中的非主键字段都依赖于主键字段。（**每列依赖主键**）—— **消除部分依赖**

第三范式：满足第二范式并且表中的非主键字段必须不传递依赖于主键字段。（**非主键不传递依赖与主键**）—— **消除传递依赖**

BC范式：3NF的基础上 + **每一个决定因素都包含码，不能只是码的一部分**

#### 2. 什么是数据库事务？ACID

- 事务具有**四大特性**（数据库事物正确执行的四个要素）：

**原子性（atomicity）** 一个事务中的所有操作要么全部完成，要么全部不完成，（未执行完就会恢复Rollback）

**一致性（consistency）** 数据库完整性不会因为事务的执行而被破坏

**隔离性（isolation）** 数据库允许多个并发事务同时对数据进行读写和修改的能力，隔离性可以防止并发执行多个事务时由于交叉执行而导致的数据不一致。

**持久性（durability）** 事务处理结束后，对数据的修改使永久的，即便系统故障也不会丢失。

- 数据库事务的三个常用命令：Begin Transaction、Commit Transaction、RollBack Transaction。

#### 3. 什么是视图？

视图实际上是在数据库中通过Select查询语句从多张表中提取的多个表字段所组成的虚拟表。

l 视图并不占据物理空间，所以通过视图查询出的记录并非保存在视图中，而是保存在原表中。

l 通过视图可以对指定用户隐藏相应的表字段，起到保护数据的作用。

l 在满足一定条件时，可以通过视图对原表中的记录进行增删改操作。

l 创建视图时，只能使用单条select查询语句。

#### 4. 什么是索引？

索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。

l 索引分为：聚集索引、非聚集索引、唯一索引等。

l 一张表可以有多个唯一索引和非聚集索引，但最多只能有一个聚集索引。

l 索引可以包含多列。

l 合理的创建索引能够提升查询语句的执行效率，但降低了新增、删除操作的速度，同时也会消耗一定的数据库物理空间。

#### 5. 什么是存储过程？

存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。

#### 6. 什么是触发器？

触发器是一中特殊的存储过程，主要是通过事件来触发而被执行的。它可以强化约束，来维护数据的完整性和一致性，可以跟踪数据库内的操作从而不允许未经许可的更新和变化。可以联级运算。如，某表上的触发器上包含对另一个表的数据操作，而该操作又会导致该表触发器被触发。

#### 7. 写出一条Sql语句：取出表A中第31到第40记录 （MS-SQLServer）

解1：select top 10 * from A where id not in (select top 30 id from A)

解2：select top 10 * from A where id > (select max(id) from (select top 30 id from A )as A)

解3：select * from (select *, Row_Number() OVER (ORDER BY id asc) rowid FROM A) as A where rowid between 31 and 40

#### 8. 写出一条Sql语句：取出表A中第31到第40记录 （Mysql）

select * from A limit 30, 10

#### 9. 写出一条Sql语句：取出表A中第31到第40记录 （Oracle）

select *

from (select A.*,

  row_number() over (order by id asc) rank

  FROM A)  

where rank >=31 AND rank<=40;

#### 10. 在关系型数据库中如何描述多对多的关系?

在关系型数据库中描述多对多的关系,需要建立第三张数据表。比如学生选课,需要在学生信息表和课程信息表的基础上,再建立选课信息表,该表中存放学生Id和课程Id。

#### 11. 什么是数据库约束,常见的约束有哪几种?

数据库约束用于保证数据库表数据的完整性（正确性和一致性）。可以通过定义约束\索引\触发器来保证数据的完整性。

总体来讲,约束可以分为:

主键约束：primary key；

外键约束：foreign key；

唯一约束：unique；

检查约束：check；

空值约束：not null；

默认值约束：default；

#### 12. 列举几种常用的聚合函数?

Sum:求和\ Avg:求平均数\ Max:求最大值\ Min:求最小值\ Count:求记录数

#### 13. 什么是内联接、左外联接、右外联接？

l 内联接（Inner Join）：匹配2张表中相关联的记录。

l 左外联接（Left Outer Join）：除了匹配2张表中相关联的记录外，还会匹配左表中剩余的记录，右表中未匹配到的字段用NULL表示。

l 右外联接（Right Outer Join）：除了匹配2张表中相关联的记录外，还会匹配右表中剩余的记录，左表中未匹配到的字段用NULL表示。

在判定左表和右表时，要根据表名出现在Outer Join的左右位置关系。

#### 14. 如何在删除主表记录时，一并删除从表相关联的记录？

如果两张表存在主外键关系，那么在删除主键表的记录时，如果从表有相关联的记录，那么将导致删除失败。

在定义外键约束时，可以同时指定3种删除策略：一是将从表记录一并删除（级联删除）；二是将从表记录外键字段设置为NULL；三是将从表记录外键字段设置为默认值。

级联删除示例：

alter table 从表名add constraint 外键名foreign key(字段名) references 主表名(字段名)on delete cascade

#### 15. 什么是游标？

游标实际上是一种能从包括多条数据记录的结果集中每次提取一条记录进行处理的机制。

游标的使用步骤：

\1. 定义游标：declare cursor 游标名称 for  select查询语句 [for {readonly|update}]

\2. 打开游标：open cursor

\3. 从游标中操作数据：fetch... ...  current of cursor

\4. 关闭游标：close cursor

#### 16. 数据库系统的三级模式结构

- **外模式（多个） ** —— 数据库**用户能够看见和使用**的局部数据的逻辑结构和特征的描述，数据库用户的数据视图（**用户视图**），**与某一应用相关**，类型的描述
- **模式（一个）** —— 全体数据的逻辑结构和特征的描述，真实的表信息
- **内模式（一个）** —— 存储模式，数据在数据库内部的组织方式

三级模式之间存在两级模式映像，分别保证数据与程序的**逻辑独立性**、数据与程序的**物理独立性**

#### 17.数据库的隔离级别

- **读未提交（Read Uncommitted）**

  select语句不加锁，可能读取到不一致的数据，即“**读脏**”。该级别并发最高，一致性最差

- **读已提交（Read Committed）**

  避免“脏读”

- **可重复读（Repeatable read）**

  MySQL默认级别

  避免“脏读”，“不可重复读”

- **串行化（Serializable）**

  避免“脏读”、“不可重复读”、“幻读”。***Serializable*** 这样的级别，就是以 ***锁表*** 的方式进行并发同步控制

MYSQL支持以上四种，默认为Repeatable read。Oracle数据库只支持Serializable和read committed两种级别，默认为read committed

```mysql
set tx_isolation='read-uncommitted'; //设置隔离级别
select @@tx_isolation;				//查询隔离级别
```

#### 18.不考虑隔离性的后果

- **脏读**

  一个事务在处理数据的过程中，读取到另一个为提交事务的数据。（例如事务一在执行后rollback而不提交，而事务二却能读取到事务一修改的数据的中间值）

- **不可重复读**

  不可重复读是指对于数据库中的某个数据，**一个事务范围内的多次查询**却返回了不同的结果，这是由于在查询过程中，数据被另外一个事务修改并提交了。

- **幻读**

  幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。

幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。



#### 19.关系完整性

- **实体完整性** 主属性非空
- **参照完整性** 外码要么为空，要么等于一个关系的一个元组的主属性
- **用户自定义完整性** 



#### 20.聚簇索引

**InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，聚簇索引就是按照每张表的主键构造一颗B+树，同时叶子节点中存放的就是整张表的行记录数据，也将聚集索引的叶子节点称为数据页。这个特性决定了索引组织表中数据也是索引的一部分；**

聚簇索引：将**数据存储与索引放到了一块**，找到索引也就找到了数据

非聚簇索引：将**数据存储与索引分开**结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因。

- 由于聚簇索引是将数据跟索引结构放到一块，因此一个表仅有一个聚簇索引







### （二）.关系数据库标准语言

#### 1.定义模式

```mySQL
CREATE SCHEMA <模式名> AUTHORIZATION <用户名> [ <表定义子句> | <视图定义子句> | <授权定义子句> ];
```

#### 2.删除模式

```mySQL
DROP SCHEMA <模式名> <CASCADE|RESTRICT>
```

- CASCADE **级联删除**，删除模式的同时将模式中的数据库对象全部删除
- RESTRICT **限制删除**，如果该模式中已经定义了下属的数据库对象（表、视图等），则拒绝执行。（与表的删除不同，必须二选一）

#### 3.表定义、删除、修改

**定义基本表**

```mysql
CREATE TABLE <表名> (<列名> <数据类型> [列级完整性约束条件]
                  	[<列名> <数据类型> [列级完整性约束]]
                  	...
                  	[,<表级完整性约束>])
```

- 常见列级完整性约束
  - PRIMARY KEY 主码，主码约束
  - UNIQUE 唯一
  - NOT NULL 非空
- 常见表级完整性约束
  - FOREIGN KEY (列名) REFERENCES 表名(列名)	—— 参照表和被参照表可以是同一个
  - CHECK 子句
  - ……

---

**数据类型**

```mysql
CHAR(n),CHARACTER(n) 				长度为n的定长字符串
VARCHAR(n),CHARACTERVARYING(n)		最大长度为n的可变长字符串
CLOB 								字符串大对象
BLOB 								二进制大对象
INT，INTEGER							长整数（4字节）
SMALLINT 							短整数（2字节）
BIGINT 								大整数（8字节）
NUMERIC(p,d)						定点数，总共p位，小数部分d位
DECIMAL(p,d),DEC(p,d)				同上
REAL								取决于机器精度的单精度浮点数
DOUBLE PRECISION					取决于机器精度的双精度浮点数
FLOAT(n)							可选精度浮点数，精度至少为n位数字
BOOLEAN								逻辑布尔量
DATE								日期 YYYY-MM-DD
TIME								时间 HH:MM:SS
TIMESTAMP							时间戳
INTERVAL							时间间隔
```

---

**模式与表**

- 每个基本表属于某个模式

设置表所属模式的方式

（1）创建表时添加所属模式

```mysql
CREATE TABLE "S-T".Student(...);		创建属于模式 S-T的表Student
```

（2）创建模式的同时创建表

（3）设置所属模式，然后再模式路径下创建表

```mysal
SHOW search_path;		查看搜索路径，搜索路径默认值为 $user,PUBLIC，含义：首先搜索与用户名相同的模式名，如果该模式不存在，则使用PUBLIC模式
SET search_path TO "S-T",PUBLIC	设置模式
```

---

**修改基本表**

```mysql
ALTER TABLE <表名>
[ ADD [COLUMN] <新列名> <数据类型> [完整性约束] ]		 //添加列
[ ADD <表级完整性约束>]								//添加约束
[ DROP [COLUMN] <列名> [CASCADE|RESTRICT] ]		   //删除列
[ DROP CONSTRAINT <完整性约束名> [RESTRICT|CASCADE]]	 //删除约束
[ ALTER COLUMN <列名> <数据类型> ]					 //修改列
```

---

**删除基本表**

```mysql
DROP TABLE <表名> [RESTRICT|CASCADE]
```

- RESTRICT 限制删除，表不能被其他表引用（CHECK、FOREIGN KEY），不能有视图、触发器、储存过程和函数等，否则不能删除

---

#### 4.索引创建与删除

- 索引的底层可以有多种实现形式
  - 顺序文件上的索引
  - B+树索引
  - 散列索引
  - 位图索引

**建立索引**

```mysql
CREATE [UNIQUE] [CLUSTER] INDEX <索引名>
on <表名> (<列名> [<次序>] [, <列名> [<次序>]] ...);
```

次序：ASC | DESC —— 升序|降序

- 索引可以建在一个表的一列或者多列上
- UNIQUE CLUSTER
  - **UNIQUE** 表示每一个索引值只对应唯一的数据记录
  - **CLUSTER** 表示要建立的索引是聚簇索引

---

**修改索引**

```mysql
ALTER INDEX <旧索引名> RENAME TO <新索引名>
```

**删除索引**

```mysql
DROP INDEX <索引名>
```

---

**数据字典** —— 数据库管理系统内部的一组系统表，记录了数据库的所有定义信息（关系模式、视图、索引、完整性约束、操作权限、统计信息等）。

---

#### 5.数据查询

```mysql
SELECT [ALL|DISTINCT] <目标列表达式> [,<目标列表达式>] ...
FROM <表名|视图名> [,<表名或视图名>...] | (<SELECT语句>) [AS] <别名>
[WHERE <条件表达式>]
[GROUP BY <列名1> [HAVING <条件表达式>]]
[ORDER BY <列名2> [ASC|DESC]]
```

- **DISTINCT** -- 用于取消表中的重复行，相反则为ALL，默认为ALL

**查询计算后的值**

```mysql
SELECT Sname,2014-Sage 'Birth Year' //后面定义了别名
FROM Student;
```

**可插入引入的常量列**

```mysql
SELECT Sname,2014-Sage as 'Birth Year','HUST' as 'School' //别名的另一种写法
FROM Student;
```

**常用查询条件**

| =,> < >= <= != !> !< ; NOT + 上述比较运算符 |
| ------------------------------------------- |
| BETWEEN AND；NOT BETWEEN AND                |
| IN ，NOT IN                                 |
| LIKE，NOT LIKE                              |
| IS NULL；IS NOT NULL                        |
| AND，OR，NOT                                |

- **IN / NOT IN**后接集合，可用 (常量1,常量2 ...) 定义常量元素的集合，也可以接单列的子查询
- **LIKE / NOT LIKE**用于字符串匹配，%用于匹配任意长度的字符串，_用于匹配单个字符
  - 可后接 ESCAPE '<换码字符>' 用于手动定义转义字符，当需要匹配%或者_时，添加在前面

**ORDER BY排序**

```mysql
ORDER BY <列名> [ASC | DESC]
```

- ASC -- 升序 DESC -- 降序

**聚集函数**

- 常见聚集函数

```mysql
COUNT(*)
COUNT([DISTINCT] <列名>)
SUM([DISTINCT] <列名>)
AVG([DISTINCT] <列名>)
MAX([DISTINCT] <列名>)
MIN([DISTINCT] <列名>)
```

- 聚集函数只能用于SELETCT子句或者GROUP BY中的HAVING子句

**GROUP BY子句**

- 使用GROUP BY子句后，某些聚集函数会以每组为为对象进行计算

```mysql
SELECT Cno,COUNT(Sno)
FROM SC
GROUP BY Cno;	//按照Cno进行分组，并统计每一个分组中的元组的数量（统计选课Cno的学生人数）
```

**连接查询**

- WHERE子句可用于定义多个表的连接查询

```mysql
[<表名1>.] <列名1> <比较运算符> [<表名2>.] <列名2>	
```

- 可以区分列名时，表名可以省略，也能用BETWEEN运算符进行连接
- 使用等号叫做等值连接，否则叫做非等值连接
- 不定义连接形式，则默认为自然连接：使用两个表的所有相同属性列进行等值查询
- 一种连接算法叫做**嵌套循环连接**

**另一种连接形式**（用在FROM子句中）

```mysql
<表1> inner join <表2> on <条件>
<表1> LEFT OUTER JOIN <表2> on <条件>
<表1> RIGHT OUTER JOIN <表2> on <条件>
```

**自连接**

```mysql
SELECT FIRST.Cno,SECOND.Cpno
FROM Course FIRST,Course SECOND
WHERE FIRST.Cpno = SECOND.Cno
```

- FROM子句中可定义别名

**嵌套查询**

- 如子查询可用作集合放在父查询的IN/NOT IN谓词后面
- **相关子查询** —— 子查询的查询条件依赖于父查询       **不相关子查询** —— 子查询的查询条件不依赖于父查询

- **ANY / ALL**的使用

- **EXISTS**谓词的使用（WHERE子句）
  - EXISTS只产生逻辑真假，父查询中依次检查EXISTS子句，若返回true，就会将父查询中的相关元组选出

**集合查询**

- **UNION**并操作
- **INTERSECT**交操作
- **EXCEPT**差操作

#### 6.数据更新

**插入元组**

```mysql
INSERT INTO <表名> [(<属性列1> [, <属性列2>]...)]
VALUES (<常量1> [, <常量2> ]...);
```

**将子查询的结果插入到表中**

``` mysql
INSERT INTO <表名> [(<属性>，...)]
子查询;
```

**修改数据**

```mysql
UPDATE <表名>
SET <列名> = <表达式> [,<列名>=<表达式>] ...
[WHERE <条件>];
```

**选择性的修改（带子查询）**

```mysql
UPDATE <表名>
SET <列名1> = <表达式>
WHERE <列名2> in (子查询);	//这里的子查询检查出<列名2>满足一定要求的元组
```

**删除元素**

```mysql
DELETE FROM <表名>
[WHERE <条件>];
```



### 7.视图

**创建视图**

```mysql
CREATE VIEW <视图名> [(<列名> [,<列名>]...)]
AS 子查询
[WITH CHECK OPTION];
```

- WITH CHECK OPTION表示对视图进行UPDATE，INSERT，DELETE操作时要保证更新，插入或者删除的行满足视图定义中的谓词条件（子查询中WHERE的条件）。

# 其他相关

## 1.单例设计模式

单例设计模式，使用的频率比较高：在整个项目中，有某个或者某些特殊的类，属于该类的对象，我只能创建一个，多了创建不了。单例是写法比较特殊的类，整个项目中只能有一个，用于配置文件之类的操作。

```c++
class MyCAS //这是一个单例类
{
private:
    MyCAS(){}           //构造函数私有化了
                               //不能创建对象
private:
    static MyCAS *m_instance; //静态成员变量
 
public:
    static MyCAS *GetInstance()
    {
         if(m_instance ==nullptr)
             {
                 m_instance = new MyCAS();
              }
          return m_instance;
    }
};
```

## 2.C++STL内存池

　既然内存分配耗时, 那我们很容易想到的就是一次性分配一大块内存, 然后在用户需要的时候再划分其中一部分给用户, 这样的话, **一次分配, 多次使用, 自然而然提高了效率**, 而用来管理这所谓的一大块内存的数据结构, 也就是今天我们要说的内存池.

**1.内存申请流程图**

　　小于等于128k的用第二级分配器；

　　大于128k的用第一级分配器

![](C:\Users\18147\Desktop\面试准备\resources\006.png)

**2. 第一级配置器：**

　　第一级採用malloc、free；

此外，这个配置器提供了当内存配置错误时的处理函数oom*malloc，这个函数会调用*_malloc_alloc_oom_handler()这个错误处理函数，去企图释放内存，然后重新调用malloc分配内存。如此循环，直到分配成功，返回指针（所以再一定程度上提高内存分配成功）。

**3. 第二级配置器**

　　使用**自由链表(free-list)**技巧。主动将不论什么小额区块的**内存需求量上调至8的倍数**。如需求30，则上调至32。
  free-list节点结构

```c++
union obj 
{
     union obj * free_list_link;     //下一个节点的指针
     char client_data[1];                    //内存首地址
}
```

有16个free-lists。各自管理大小分别为8、16、24、32、40、48、56、64、72、80、88、96、104、112、120、128 bytes的**小额区块**。

![](C:\Users\18147\Desktop\面试准备\resources\007.png)

**释放内存**

![](C:\Users\18147\Desktop\面试准备\resources\008.png)

所以最终**内存池的思路**其实是这样的:

\1. 使用allocate向内存池请求size大小的内存空间, 如果需要请求的内存大小大于128bytes, 直接使用malloc.

\2. 如果需要的内存大小小于128bytes, allocate根据size**找到最适合的自由链表**.

　　a. 如果链表不为空, 返回第一个node, 链表头改为第二个node.

　　b. 如果链表为空, 使用blockAlloc请求分配node.

　　　　x. 如果内存池中有大于一个node的空间, 分配尽可能多的node(但是最多20个), 将一个node返回, 其他的node添加到链表中.

　　　　y. 如果内存池只有一个node的空间, 直接返回给用户.

　　　　z. 若果如果连一个node都没有, 再次向操作系统请求分配内存.

　　　　　　①分配成功, 再次进行b过程

　　　　　　②分配失败, 循环各个自由链表, 寻找空间

　　　　　　　　I. 找到空间, 再次进行过程b

　　　　　　　　II. 找不到空间, 抛出异常(代码中并未给出, 只是给出了注释)

\3. 用户调用deallocate释放内存空间, 如果要求释放的内存空间大于128bytes, 直接调用free.

\4. 否则按照其大小找到合适的自由链表, 并将其插入.

 

**特点**其实是这样的 :

\1. 刚开始初始化内存池的时候, 其实内存池中并没有内存, 同时所有的自由链表都为空链表.

\2. 只有用户第一次向内存池请求内存时, 内存池会依次执行上述过程的 1->2->b->z来完成内存池以及链表的首次填充, 而此时, 其他未使用链表仍然是空的.

\3. 所有已经分配的内存在内存池中没有任何记录, 释放与否完全靠程序员自觉.

\4. 释放内存时, 如果大于128bytes, 则直接free, 否则加入相应的自由链表中而不是直接返还给操作系统.