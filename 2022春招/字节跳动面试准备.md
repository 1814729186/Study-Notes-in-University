

# 字节跳动面试准备

## 一、面经一

一面

- **进程和线程，细节、区别、原理**

线程是进程的一部分，描述指令流执行状态。它是进程中的指令执行流的最小单位，是CPU调度的基本单位。

线程优点：1.一个进程中可以同时存在多个线程。2.各个线程之间可以并发的执行。3.各个线程之间可以共享地址空间和文件等资源
线程缺点：一个线程崩溃，会导致其所属进程的所有线程崩溃

**进程是资源分配单位，线程是CPU调度单位**
进程拥有一个完整的资源平台，而线程只独享指令流执行的必要资源，如寄存器和栈
线程具有就绪，等待和运行三种基本状态和状态间转换关系
**线程能减少并发执行的时间和空间开销：线程的创建时间比进程短；线程的终止时间比进程短；同一进程内的线程切换时间比进程短；由于同一进程的各线程间共享内存各文件资源，可以不通过内核进行直接通信**

线程的实现方式

1.**用户线程**：在用户空间实现
POSIX Pthreads,Mach C-threads,Solaris threads
	由一组用户级的线程库函数来完成线程的管理，包括线程的创建，终止，同步和调度等
特征：不依赖于操作系统内核（内核不了解用户线程的存在；可用于不支持线程的多进程操作系统）。在用户空间实现的线程机制（每个进程有私有的线程控制块列表；TCB由线程库函数维护）。同一进程内的用户线程切换速度快（无需用户态/内核态的切换）。允许每个进程拥有自己的线程调度算法
缺点：线程发起系统调用而阻塞时，整个进程进入等待；不支持基于线程的处理机抢占；只能按进程分配CPU时间
2.**内核线程**：在内核中实现
Windows,Solaris,Linux
进程由内核通过系统调用实现的线程机制，由内核完成线程的创建，终止和管理（内核中PCB中有指针指向线程控制块TCB）
特征：由内核维护PCB和TCB。线程执行系统调用而被阻塞不影响其他线程。线程的创建，终止和切换开销相对较大（通过系统调用/内核函数，在内核实现）。以线程为单位进行CPU时间分配（多线程的进程可获得更多的CPU时间）
3.**轻量级进程**：在内核中实现，支持用户线程
Solaris (LightWeight Process)
内核支持的用户线程。一个进程可有一个或多个轻量级进程，每个轻权进程由一个单独的内核线程来支持（Solaris/Linux）

用户线程与内核线程的对应关系：
1.N个用户线程对应N个内核线程；2.N个用户线程对应一个内核线程；3.N个用户线程对应M个内核线程
三种当中，现在的操作系统以第一种为主。

- **TPC和UDP，是否双工等**

TCP的优点： 可靠，稳定 TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源。 TCP的缺点： 慢，效率低，占用系统资源高，易被攻击 TCP在传递数据之前，要先建连接，这会消耗时间，而且在数据传递时，确认机制、重传机制、拥塞控制机制等都会消耗大量的时间，而且要在每台设备上维护所有的传输连接，事实上，每个连接都会占用系统的CPU、内存等硬件资源。 而且，因为TCP有确认机制、三次握手机制，这些也导致TCP容易被人利用，实现DOS、DDOS、CC等攻击。

UDP的优点： 快，比TCP稍安全 UDP没有TCP的握手、确认、窗口、重传、拥塞控制等机制，UDP是一个无状态的传输协议，所以它在传递数据时非常快。没有TCP的这些机制，UDP较TCP被攻击者利用的漏洞就要少一些。但UDP也是无法避免攻击的，比如：UDP Flood攻击…… UDP的缺点： 不可靠，不稳定 因为UDP没有TCP那些可靠的机制，在数据传递时，如果网络质量不好，就会很容易丢包。 基于上面的优缺点，那么： 什么时候应该使用TCP： 当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。 在日常生活中，常见使用TCP协议的应用如下： 浏览器，用的HTTP FlashFXP，用的FTP Outlook，用的POP、SMTP Putty，用的Telnet、SSH QQ文件传输 ………… 什么时候应该使用UDP： 当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。 比如，日常生活中，常见使用UDP协议的应用如下： QQ语音 QQ视频 TFTP ……

有些应用场景对可靠性要求不高会用到UPD，比如长视频，要求速率

TCP连接是全双工的，UDP双向传输时需要各自创建连接，是单双工的



**小结TCP与UDP的区别：**

TCP与UDP区别总结：

1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接

2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付

3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的

UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）

4、每一条TCP连接只能是**点到点**的;UDP支持一对一，一对多，多对一和多对多的交互通信

5、TCP首部开销20字节;UDP的首部开销小，只有8个字节

6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道

- **HTTPs和HTTP协议的细节和不同，比如HTTPs的公钥私钥**

**http协议的缺点**

通信使用**明文**，内容可能被窃听(重要密码泄露)

**不验证**通信方身份，有可能遭遇伪装(跨站点请求伪造)

**无法证明**报文的完整性，有可能已遭篡改(运营商劫持)

https是在http协议基础上加入加密处理和认证机制以及完整性保护，即**http+加密+认证+完整性保护=https**
https并非应用层的一种新协议，只是http通信接口部分用**ssl/tls协议**代替而已。通常**http直接和tcp通信**，当使用ssl时则演变成**先和ssl通信，再由ssl和tcp通信**。
所谓https，其实就是身披ssl协议这层外壳的http

SSL 是“Secure Sockets Layer”的缩写，中文叫做“安全套接层”。

SSL协议位于TCP/IP协议与各种应用层协议之间，为数据通讯提供安全支持。SSL协议可分为两层：
	**SSL记录协议**（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。
	**SSL握手协议**（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。

**对称密钥和非对称密钥加成**

​	对称密钥加密，又称**私钥加密**，即信息的发送方和接收方用同一个密钥去加密和解密数据。它的最大优势是加/解密速度快，适合于对大数据量进行加密，但密钥管理困难。
​	非对称密钥加密，又称**公钥加密**，它需要使用一对密钥来分别完成加密和解密操作，一个公开发布，即公开密钥，另一个由用户自己秘密保存，即私用密钥。信息发送者用公开密钥去加密，而信息接收者则用私用密钥去解密。
​	从功能角度而言非对称加密比对称加密功能强大，但加密和解密速度却比对称密钥加密慢得多。

**SSL/TLS协议的基本过程**是这样的：

1. 客户端向服务器端索要并验证公钥。
2. 双方协商生成“对话密钥”。
3. 双方采用“对话密钥”进行加密通信。

第一步，爱丽丝给出协议版本号、一个**客户端生成的随机数1**（Client random），以及客户端支持的加密方法，具体的加密方法可参考[SSL证书背后的加密算法](https://www.cnblogs.com/cioliuguilan/p/5518798.html)。
第二步，鲍勃确认双方使用的加密方法，并给出数字证书、以及一个**服务器生成的随机数2**（Server random）。
第三步，爱丽丝确认数字证书有效，然后生成一个**新的随机数3**（Premaster secret），并使用数字证书中的**公钥，加密这个随机数**，发给鲍勃。
第四步，鲍勃使用自己的**私钥**，获取爱丽丝发来的随机数（即Premaster secret）。
第五步，爱丽丝和鲍勃根据约定的加密方法，使用前面的**三个随机数**，生成**"对话密钥"**（session key），用来加密接下来的整个对话过程。

**HTTPS工作原理**

1、客户端发起HTTPS请求
		用户在浏览器里输入一个https网址，然后连接到server的443端口。
2、服务端的配置
		采用HTTPS协议的服务器必须要有一套**数字证书**，可以自己制作，也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面。
3、传送证书
		**这个证书其实就是公钥**，只是包含了很多信息，如证书的颁发机构、证书版本、序列号、签名算法标识符、签发⼈姓名、有效期、公钥信息等并附有CA的签名
4、客户端解析证书
		这部分工作是由客户端的TLS来完成的，首先会**验证公钥是否有效**，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。
（1）首先浏览器读取证书中的证书所有者、有效期等信息进行一一校验
（2）浏览器开始查找操作系统中已内置的受信任的证书发布机构CA，与服务器发来的证书中的颁发者CA比对，用于校验证书是否为合法机构颁发
（3）如果找不到，浏览器就会报错，说明服务器发来的证书是不可信任的。
（4）如果找到，那么浏览器就会从操作系统中取出颁发者CA 的公钥(多数浏览器开发商发布版本时，会事先在内部植入常用认证机关的公开密钥)，然后对服务器发来的证书里面的签名进行解密
（5）浏览器使用相同的hash算法计算出服务器发来的证书的hash值，将这个计算的hash值与证书中签名做对比
（6）对比结果一致，则证明服务器发来的证书合法，没有被冒充
（7）此时浏览器就可以读取证书中的公钥，用于后续加密了
5、传送加密信息
		这部分传送的是**用证书加密后的随机值(私钥)**，目的就是让**服务端得到这个随机值**，以后**客户端和服务端的通信就可以通过这个随机值来进行加密解密**了。
6、服务端解密信息
		服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后**把内容通过该值进行对称加密**
7、传输加密后的信息
		这部分信息是服务端用私钥加密后的信息，可以在客户端被还原。
8、客户端解密信息
		客户端用之前生成的私钥解密服务端传过来的信息，于是获取了解密后的内容，整个过程第三方即使监听到了数据，也束手无策。

总结：**私钥的传输使用非对称加密，信息的传输使用的是对称加密**

- **三次四次握手**

![](C:\Users\18147\Desktop\面试准备\resources\003.png)

1、客户端主动打开，发送连接请求报文段，将SYN标识位置为1，Sequence Number置为x(TCP规定**SYN=1时不能携带数据**，x为随机产生的一个值)，然后进入**SYN_SEND**状态。

2、服务器收到SYN报文段进行确认，将SYN标识位置为1，ACK置为1，Sequence Number置为y，Acknowledgment Number置为x+1，然后进入**SYN_RECV**状态，这个状态被称为**半连接状态**。

3、客户端再进行一次确认，将ACK置为1(此时不用SYN)，Sequence Number置为x+1，Acknowledgment Number置为y+1发向服务器，最后客户端与服务器都进入**ESTABLISHED**状态

![](C:\Users\18147\Desktop\面试准备\resources\004.png)

1、客户端发送一个报文给服务端(没有数据)，其中FIN设置为1，Sequence Number置为u，客户端进入FIN_WAIT_1状态。

2、服务端收到来自客户端的请求，发送一个ACK给客户端，Acknowledge置为u+1，同时发送Sequence Number为v，服务端年进入CLOSE_WAIT状态。

3、服务端发送一个FIN给客户端，ACK置为1，Sequence置为w，Acknowledge置为u+1，用来关闭服务端到客户端的数据传送，服务端进入**LAST_ACK**状态。

4、客户端收到FIN后，进入**TIME_WAIT**状态，接着发送一个ACK给服务端，Acknowledge置为w+1，Sequence Number置为u+1，最后客户端和服务端都进入CLOSED状态。

- **智能指针的细节**

智能指针主要用于**管理在堆上分配的内存**，它**将普通的指针封装为一个栈对象**。当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而**防止内存泄漏**。

- auto_ptr(C++11已弃用，存在潜在的内存崩溃问题！)

- unique_ptr

  - unique_ptr实现**独占式**拥有或严格拥有概念，保证同一时间内**只有一个智能指针可以指向该对象**。它对于避免资源泄露(例如“以new创建对象后因为发生异常而忘记调用delete”)特别有用。unique_ptr比auto_ptr更安全。
  - 另外unique_ptr还有更聪明的地方：当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个**临时右值**，编译器**允许**这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，

- shared_ptr

  shared_ptr实现**共享式**拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在**“最后一个引用被销毁”时候释放**。

  有一点share_ptr智能指针还是有内存泄露的情况，当两个对象相互使用一个shared_ptr成员变量指向对方，会造成**循环引用**，使引用**计数失效**，从而导致内存泄漏。

- weak_ptr

  weak_ptr 是一种不控制对象生命周期的智能指针, 它**指向一个 shared_ptr 管理的对象**. **进行该对象的内存管理的是那个强引用的shared_ptr**， weak_ptr只是**提供了对管理对象的一个访问手段**。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。**weak_ptr是用来解决shared_ptr相互引用时的死锁问题,如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0**,资源永远不会释放。它是**对对象的一种弱引用，不会增加对象的引用计数，**和shared_ptr之间可以相互转化，**shared_ptr可以直接赋值给它**，**它可以通过调用lock函数来获得shared_ptr**。

- **二叉树遍历的非递归写法，现场写**

```c++
//非递归先序
void preOrderTraverse(Tree tree) {
	//先序遍历
	//从栈中取出一个节点，访问，然后压栈右子树，然后压栈左子树
	struct treeNode* stack[MAX_SIZE],*curNode;
	int stackPointer = 0;
	//压栈头节点
	stack[stackPointer++] = tree;
	while (stackPointer) {
		//取出元素
		curNode = stack[--stackPointer];
		//访问
		cout << curNode->val;
		//压栈右子树，压栈左子树
		if(curNode->rightChild) stack[stackPointer++] = curNode->rightChild;
		if(curNode->leftChild)stack[stackPointer++] = curNode->leftChild;
	}
}
//非递归中序
void midOrderTraverse(Tree tree) {
	//中序遍历
	//左子树全部依次进栈直到不存在左子树
	struct treeNode* stack[MAX_SIZE], * curNode;
	int stackPointer = 0;
    curNode = tree;
	do {
		//全部完成压栈
		while (curNode) {
			stack[stackPointer++] = curNode;
			curNode = curNode->leftChild;
		}
		//出栈，访问该节点，并以同样的方式处理其右节点
		if (stackPointer) {
			curNode = stack[--stackPointer];	//出栈
			cout << curNode->val;
			curNode = curNode->rightChild;
		}
	} while (stackPointer||curNode);		//栈非空或者当前仍存在右节点未访问
}
//非递归后续
void postOrderTraverse(Tree tree) {
	//后续遍历
	struct treeNode* pre;	//pre指针
	struct treeNode* stack[MAX_SIZE], * curNode=tree;
	int stackPointer = 0, flag = 0;
	if (!tree) return;
	do {
		//左子树全部入栈
		while (curNode) {
			stack[stackPointer++] = curNode;
			curNode = curNode->leftChild;
		}
		//设置标记和前序指针
		pre = nullptr; flag = 1;
		while (stackPointer && flag) {
			curNode = stack[stackPointer - 1];//检查栈顶元素有没有右子树或者右子树是否已经访问
			if (curNode->rightChild == pre) {	//若右子树已经访问则访问该节点，（也可能没有右子树）
				cout << curNode->val;
				stackPointer--;
				pre = curNode;
			}
			else {
				curNode = curNode->rightChild;	//右子树未访问，则需要先处理右子节点
				flag = 0;
			}
		}
	}while (stackPointer);
}
```

先序遍历：压栈根节点，每轮从栈中取出节点，访问节点，压栈右子树，压栈左子树

中序遍历：从当前节点开始依次压栈所有左子节点，出栈节点进行访问，然后以同样的方式处理出栈节点的右节点

后序遍历：从当前节点开始依次压栈所有左子节点，查看栈顶元素的右子树是否已经访问，如果已经访问，则访问该节点，继续检查栈顶元素；如果未访问，则置其为当前节点，重复整个过程。

- **多线程的具体使用和各种同步方法的优劣和不同**

同步方法：（1）互斥锁，（2）条件变量，（3）读写锁，（4）信号量

```c++
std::mutex mtx;	//共享锁变量
mtx.lock();	//加锁
mtx.unlock();//	开锁
thread_local int num;	//线程本地变量
lock_guard<mutex> lock(mtx);	//基于作用域的加锁
lock_guard<mutex> unlock(mtx);	//基于作用域的提前解锁
thread a(函数名);	//创建线程对象
a.join();	//等待线程执行结束
```

1.基于作用域的加锁方式

​	作用域结束时自动释放

2.基于致命区的加锁方式

​	如果致命区出现异常，则可能不执行解锁

- **进程间通信的方法，和socket的不同和相同点**

管道（pipe）,流管道(s_pipe)和有名管道（FIFO）

信号（signal）

消息队列（message queue）

共享内存（shared memory）

信号量（sinal）

套接字（socket) —— 它可用于不同机器间的进程通信.

- **不同操作系统下的进程间通信**

windows系统：**文件映射**、共享内存、匿名管道、命名管道、邮件槽、剪切板等等

二面

- `malloc`和`calloc`的底层细节

基于 linux 环境下的 malloc 实现:

1）当开辟的空间小于 128K 时，调用 brk（）函数，malloc 的底层实现是系统调用函数 brk（），其主要移动指针 _enddata(此时的 _enddata 指的是 Linux 地址空间中堆段的末尾地址，不是数据段的末尾地址)

2）当开辟的空间大于 128K 时，mmap（）系统调用函数来在虚拟地址空间中（堆和栈中间，称为“文件映射区域”的地方）找一块空间来开辟。

从操作系统角度看，进程分配内存有两种方式，分别由两个系统调用完成：brk 和 mmap (不考虑共享内存)

1）**brk** 是将**数据段**（.data）的最高地址指针 _edata 往高地址推（堆中分配）

2）**mmap** 是在进程的**虚拟地址空间中**（堆和栈中间，称为“**文件映射区域**”的地方）找一块**空闲的虚拟内存**。

这两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系。

所以malloc采用的是内存池的管理方式（ptmalloc），Ptmalloc 采用边界标记法将内存划分成很多块，从而对内存的分配与回收进行管理。为了内存分配函数malloc的高效性，ptmalloc会预先向操作系统申请一块内存供用户使用，当我们申请和释放内存的时候，ptmalloc会将这些内存管理起来，并通过一些策略来判断是否将其回收给操作系统。这样做的最大好处就是，使用户申请和释放内存的时候更加高效，避免产生过多的内存碎片。

在堆区中， start_brk 指向 heap 的开始，而 brk 指向 heap 的顶部。可以使用系统调用 brk()和 sbrk()来增 加标识 heap 顶部的 brk 值，从而线性的增加分配给用户的 heap 空间。在使 malloc 之前，brk 的值等于 start_brk，也就是说 heap 大小为 0。
　　ptmalloc 在开始时，若请求的空间小于 mmap 分配阈值（mmap threshold，默认值为 128KB）时，主分配区会调用 sbrk()增加一块大小为 (128 KB + chunk_size) align 4KB 的空间作为 heap。非主分配区会调用 mmap 映射一块大小为 HEAP_MAX_SIZE（32 位系统上默认为 1MB，64 位系统上默认为 64MB）的空间作为 sub-heap。这就是前面所说的 ptmalloc 所维护的分配空间;　　　
　　当用户请求内存分配时，首先会在这个区域内找一块合适的 chunk 给用户。当用户释放了 heap 中的 chunk 时，ptmalloc 又会使用 fastbins 和 bins 来组织空闲 chunk。以备用户的下一次分配。
　　若需要分配的 chunk 大小小于 mmap分配阈值，而 heap 空间又不够，则此时主分配区会通过 sbrk()调用来增加 heap 大小，非主分配区会调用 mmap 映射一块新的 sub-heap，也就是增加 top chunk 的大小，每次 heap 增加的值都会对齐到 4KB。当用户的请求超过 mmap 分配阈值，并且主分配区使用 sbrk()分配失败的时候，或是非主分配区在 top chunk 中不能分配到需要的内存时，ptmalloc 会尝试使用 mmap()直接映射一块内存到进程内存空间。使用 mmap()直接映射的 chunk 在释放时直接解除映射，而不再属于进程的内存空间。任何对该内存的访问都会产生段错误。而在 heap 中或是 sub-heap 中分配的空间则可能会留在进程内存空间内，还可以再次引用（当然是很危险的）。

- **内存相关，如内存碎片管理和STL大内存的搬运方式，如何优化的，为什么需要优化和内存池等细节**

避免外部碎片：

第一种方案，我们使用地址转换技术，把非连续的物理地址转换成连续的线性地址。
第二种方案，开发一种特有的分配技术来记录下来空闲内存的情况，从而解决内存碎片问题。

Linux采用著名的**伙伴系统(buddy system)算法**来解决外碎片问题。把所有的空闲页框**分组为11个块链表**，每个链表分别包含大小为1,2,4,8,16,32,64,128,256,512,1024个连续的页框，对1024个页框的最大请求对应着4MB大小的连续RAM（每页大小为4KB），每个块的第一个页框的物理地址是该块大小的整数倍，例如，大小为16个页框的块，其起始地址是16*2^12的倍数。

我们通过一个例子来说明伙伴算法的工作原理，假设现在要**请求一个256个页框**的块（1MB），算法步骤如下：

- 在256个页框的链表中检查是否有一个空闲快，如果没有，**查找下一个更大的块**，如果有，请求满足。
- 在512个页框的链表中检查是否有一个空闲块，如果有，把512个页框的空闲块分为两份，**第一份用于满足请求，第二份链接到256个页框的链表中。**如果没有空闲块，继续寻找下一个更大的块。

下图比较形象地描述了该过程。

![](C:\Users\18147\Desktop\面试准备\resources\005.png)

以上过程的**逆过程**，就是页框块的释放过程，也是该算法**名字的由来**，内核试图把**大小为B的一对空闲伙伴块合并为一个2B的单独块**，满足以下条件的两个块称之为伙伴：

​	两个块具有相同的大小

​	他们的物理地址是连续的

​	第一块的第一个页框的物理地址是2 * B * 2^12
 该算法是递归的，如果它成功合并了B，就会试图去合并2B，以再次试图形成更大的块。





- **STL相关很多细节**

  - vector 可变长数组
  - list——双向链表
  - deque —— 双端链表、数组块链表，索引数组
  - set —— 红黑树
  - map —— 红黑树
  - hash_set —— hash表

  **map**内部是红黑树 

  - 元素有序
  - 占用空间更大

  **unordered_map**内部是哈希表 —— 适用于查找密集型

  - 元素无序
  - 查找速度快（较map）
  - hash表的建立比较费时间

- **一个中等难度的算法题**
- **我额外讲了一下操作系统分页方式导致STL内存池的构建**



三面

- **内存管理相关细节**
- **几个代码题，实现智能指针**



## 二、面经二

- **介绍一下你自己**
- **有哪些排序算法**           答：（排序算法都没准备）冒泡、选择、快排、归并等
- **手写一下快排和归并排序，给你10分钟**                   答：没准备，写了20分钟只写出了快拍。。。（漫长的沉默）
- **数据库会吗？**              答：了解一点。
- **数据库ACID知道吗?**



- **数据库用什么数据结构实现的？ ** B+树

- 那**数据库联结操作**知道吗？等值联结？

答：好像忘了。应该是表合并吧。

- 没错，就是将两个表相同键值的元素拼接起来。你**实现一下这个等值联结**，怎么实现？输入的列的某值，输出是整行元素。

- 5.操作系统linux会吗？

- **755什么意思？**

- **进程和线程有什么区别？**
  进程是程序的一次执行，是资源调度单位，一个进程一个PCB；线程更轻量级，可以使用资源，但不能调度资源。

- 那**虚函数和普通函数有什么区别**？
- 问**项目中有没有用数据库**
- 那就是数据库底层不了解咯？           答：对的。
- 那SQL语句会吗                        答：了解一点。
  求：一个班级，某科目的平均成绩大于某值，的科目内容。说明一下SQL语句思路。
         答： SELECT 科目 WHERE 班级=XXX AND AVERAGE(SUBJECT)>XXX

       错了，因为你不知科目有几门
        
       答：建表的时候，几列就表示有几门课（其实SQL语句都忘了）

- **哈希算法用什么数据结构好**。

       答：数组。

- **哈希的时候，如何删除元素？**
  答：哈希下去，到表尾删除元素，或者找到元素，将标记位更改。

- **哈希这个动作是线程安全的吗？**

答：读动作是安全的，写动作不安全，可以加锁。

- **给每个数组中的位置分别加锁，还是一个数组加一把锁。**

答：应该都可以，前者方便，后者可以实现更多的线程并发，但可能产生死锁。

- 写一下**线程的单例设计模式**吧。(私有化构造函数，静态成员变量指向创建的对象，只能创建一个对象)

```c++
class MyCAS //这是一个单例类
{
private:
    MyCAS(){}           //构造函数私有化了
                               //不能创建对象
private:
    static MyCAS *m_instance; //静态成员变量
 
public:
    static MyCAS *GetInstance()
    {
         if(m_instance ==nullptr)
             {
                 m_instance = new MyCAS();
              }
          return m_instance;
    }
};
```

- **100W个数，找出前10个最小的。**

- 长度为N的链表，隔K个数反转一次，例如123456，K为3就会变成321654 —— （头插法，尾插法混合使用）



## 三、面试准备

### （一）.数据库相关

#### 1. 数据库三范式是什么?

第一范式：表中每个字段都不能再分。（**每列不能再分**）

第二范式：满足第一范式并且表中的非主键字段都依赖于主键字段。（**每列依赖主键**）—— **消除部分依赖**

第三范式：满足第二范式并且表中的非主键字段必须不传递依赖于主键字段。（**非主键不传递依赖与主键**）—— **消除传递依赖**

BC范式：3NF的基础上 + **每一个决定因素都包含码，不能只是码的一部分**

#### 2. 什么是数据库事务？ACID

- 事务具有**四大特性**（数据库事物正确执行的四个要素）：

**原子性（atomicity）** 一个事务中的所有操作要么全部完成，要么全部不完成，（未执行完就会恢复Rollback）

**一致性（consistency）** 数据库完整性不会因为事务的执行而被破坏

**隔离性（isolation）** 数据库允许多个并发事务同时对数据进行读写和修改的能力，隔离性可以防止并发执行多个事务时由于交叉执行而导致的数据不一致。

**持久性（durability）** 事务处理结束后，对数据的修改使永久的，即便系统故障也不会丢失。

- 数据库事务的三个常用命令：Begin Transaction、Commit Transaction、RollBack Transaction。

#### 3. 什么是视图？

视图实际上是在数据库中通过Select查询语句从多张表中提取的多个表字段所组成的虚拟表。

l 视图并不占据物理空间，所以通过视图查询出的记录并非保存在视图中，而是保存在原表中。

l 通过视图可以对指定用户隐藏相应的表字段，起到保护数据的作用。

l 在满足一定条件时，可以通过视图对原表中的记录进行增删改操作。

l 创建视图时，只能使用单条select查询语句。

#### 4. 什么是索引？

索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。

l 索引分为：聚集索引、非聚集索引、唯一索引等。

l 一张表可以有多个唯一索引和非聚集索引，但最多只能有一个聚集索引。

l 索引可以包含多列。

l 合理的创建索引能够提升查询语句的执行效率，但降低了新增、删除操作的速度，同时也会消耗一定的数据库物理空间。

#### 5. 什么是存储过程？

存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。

#### 6. 什么是触发器？

触发器是一中特殊的存储过程，主要是通过事件来触发而被执行的。它可以强化约束，来维护数据的完整性和一致性，可以跟踪数据库内的操作从而不允许未经许可的更新和变化。可以联级运算。如，某表上的触发器上包含对另一个表的数据操作，而该操作又会导致该表触发器被触发。

#### 7. 写出一条Sql语句：取出表A中第31到第40记录 （MS-SQLServer）

解1：select top 10 * from A where id not in (select top 30 id from A)

解2：select top 10 * from A where id > (select max(id) from (select top 30 id from A )as A)

解3：select * from (select *, Row_Number() OVER (ORDER BY id asc) rowid FROM A) as A where rowid between 31 and 40

#### 8. 写出一条Sql语句：取出表A中第31到第40记录 （Mysql）

select * from A limit 30, 10

#### 9. 写出一条Sql语句：取出表A中第31到第40记录 （Oracle）

select *

from (select A.*,

  row_number() over (order by id asc) rank

  FROM A)  

where rank >=31 AND rank<=40;

#### 10. 在关系型数据库中如何描述多对多的关系?

在关系型数据库中描述多对多的关系,需要建立第三张数据表。比如学生选课,需要在学生信息表和课程信息表的基础上,再建立选课信息表,该表中存放学生Id和课程Id。

#### 11. 什么是数据库约束,常见的约束有哪几种?

数据库约束用于保证数据库表数据的完整性（正确性和一致性）。可以通过定义约束\索引\触发器来保证数据的完整性。

总体来讲,约束可以分为:

主键约束：primary key；

外键约束：foreign key；

唯一约束：unique；

检查约束：check；

空值约束：not null；

默认值约束：default；

#### 12. 列举几种常用的聚合函数?

Sum:求和\ Avg:求平均数\ Max:求最大值\ Min:求最小值\ Count:求记录数

#### 13. 什么是内联接、左外联接、右外联接？

l 内联接（Inner Join）：匹配2张表中相关联的记录。

l 左外联接（Left Outer Join）：除了匹配2张表中相关联的记录外，还会匹配左表中剩余的记录，右表中未匹配到的字段用NULL表示。

l 右外联接（Right Outer Join）：除了匹配2张表中相关联的记录外，还会匹配右表中剩余的记录，左表中未匹配到的字段用NULL表示。

在判定左表和右表时，要根据表名出现在Outer Join的左右位置关系。

#### 14. 如何在删除主表记录时，一并删除从表相关联的记录？

如果两张表存在主外键关系，那么在删除主键表的记录时，如果从表有相关联的记录，那么将导致删除失败。

在定义外键约束时，可以同时指定3种删除策略：一是将从表记录一并删除（级联删除）；二是将从表记录外键字段设置为NULL；三是将从表记录外键字段设置为默认值。

级联删除示例：

alter table 从表名add constraint 外键名foreign key(字段名) references 主表名(字段名)on delete cascade

#### 15. 什么是游标？

游标实际上是一种能从包括多条数据记录的结果集中每次提取一条记录进行处理的机制。

游标的使用步骤：

\1. 定义游标：declare cursor 游标名称 for  select查询语句 [for {readonly|update}]

\2. 打开游标：open cursor

\3. 从游标中操作数据：fetch... ...  current of cursor

\4. 关闭游标：close cursor

#### 16. 数据库系统的三级模式结构

- **外模式（多个） ** —— 数据库**用户能够看见和使用**的局部数据的逻辑结构和特征的描述，数据库用户的数据视图（**用户视图**），**与某一应用相关**，类型的描述
- **模式（一个）** —— 全体数据的逻辑结构和特征的描述，真实的表信息
- **内模式（一个）** —— 存储模式，数据在数据库内部的组织方式

三级模式之间存在两级模式映像，分别保证数据与程序的**逻辑独立性**、数据与程序的**物理独立性**

#### 17.数据库的隔离级别

- **读未提交（Read Uncommitted）**

  select语句不加锁，可能读取到不一致的数据，即“**读脏**”。该级别并发最高，一致性最差

- **读已提交（Read Committed）**

  避免“脏读”

- **可重复读（Repeatable read）**

  MySQL默认级别

  避免“脏读”，“不可重复读”

- **串行化（Serializable）**

  避免“脏读”、“不可重复读”、“幻读”。***Serializable*** 这样的级别，就是以 ***锁表*** 的方式进行并发同步控制

MYSQL支持以上四种，默认为Repeatable read。Oracle数据库只支持Serializable和read committed两种级别，默认为read committed

```mysql
set tx_isolation='read-uncommitted'; //设置隔离级别
select @@tx_isolation;				//查询隔离级别
```

#### 18.不考虑隔离性的后果

- **脏读**

  一个事务在处理数据的过程中，读取到另一个为提交事务的数据。（例如事务一在执行后rollback而不提交，而事务二却能读取到事务一修改的数据的中间值）

- **不可重复读**

  不可重复读是指对于数据库中的某个数据，**一个事务范围内的多次查询**却返回了不同的结果，这是由于在查询过程中，数据被另外一个事务修改并提交了。

- **幻读**

  幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。

幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。



#### 19.关系完整性

- **实体完整性** 主属性非空
- **参照完整性** 外码要么为空，要么等于一个关系的一个元组的主属性
- **用户自定义完整性** 



#### 20.聚簇索引

**InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，聚簇索引就是按照每张表的主键构造一颗B+树，同时叶子节点中存放的就是整张表的行记录数据，也将聚集索引的叶子节点称为数据页。这个特性决定了索引组织表中数据也是索引的一部分；**

聚簇索引：将**数据存储与索引放到了一块**，找到索引也就找到了数据

非聚簇索引：将**数据存储与索引分开**结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因。

- 由于聚簇索引是将数据跟索引结构放到一块，因此一个表仅有一个聚簇索引







### （二）.关系数据库标准语言

#### 1.定义模式

```mySQL
CREATE SCHEMA <模式名> AUTHORIZATION <用户名> [ <表定义子句> | <视图定义子句> | <授权定义子句> ];
```

#### 2.删除模式

```mySQL
DROP SCHEMA <模式名> <CASCADE|RESTRICT>
```

- CASCADE **级联删除**，删除模式的同时将模式中的数据库对象全部删除
- RESTRICT **限制删除**，如果该模式中已经定义了下属的数据库对象（表、视图等），则拒绝执行。（与表的删除不同，必须二选一）

#### 3.表定义、删除、修改

**定义基本表**

```mysql
CREATE TABLE <表名> (<列名> <数据类型> [列级完整性约束条件]
                  	[<列名> <数据类型> [列级完整性约束]]
                  	...
                  	[,<表级完整性约束>])
```

- 常见列级完整性约束
  - PRIMARY KEY 主码，主码约束
  - UNIQUE 唯一
  - NOT NULL 非空
- 常见表级完整性约束
  - FOREIGN KEY (列名) REFERENCES 表名(列名)	—— 参照表和被参照表可以是同一个
  - CHECK 子句
  - ……

---

**数据类型**

```mysql
CHAR(n),CHARACTER(n) 				长度为n的定长字符串
VARCHAR(n),CHARACTERVARYING(n)		最大长度为n的可变长字符串
CLOB 								字符串大对象
BLOB 								二进制大对象
INT，INTEGER							长整数（4字节）
SMALLINT 							短整数（2字节）
BIGINT 								大整数（8字节）
NUMERIC(p,d)						定点数，总共p位，小数部分d位
DECIMAL(p,d),DEC(p,d)				同上
REAL								取决于机器精度的单精度浮点数
DOUBLE PRECISION					取决于机器精度的双精度浮点数
FLOAT(n)							可选精度浮点数，精度至少为n位数字
BOOLEAN								逻辑布尔量
DATE								日期 YYYY-MM-DD
TIME								时间 HH:MM:SS
TIMESTAMP							时间戳
INTERVAL							时间间隔
```

---

**模式与表**

- 每个基本表属于某个模式

设置表所属模式的方式

（1）创建表时添加所属模式

```mysql
CREATE TABLE "S-T".Student(...);		创建属于模式 S-T的表Student
```

（2）创建模式的同时创建表

（3）设置所属模式，然后再模式路径下创建表

```mysal
SHOW search_path;		查看搜索路径，搜索路径默认值为 $user,PUBLIC，含义：首先搜索与用户名相同的模式名，如果该模式不存在，则使用PUBLIC模式
SET search_path TO "S-T",PUBLIC	设置模式
```

---

**修改基本表**

```mysql
ALTER TABLE <表名>
[ ADD [COLUMN] <新列名> <数据类型> [完整性约束] ]		 //添加列
[ ADD <表级完整性约束>]								//添加约束
[ DROP [COLUMN] <列名> [CASCADE|RESTRICT] ]		   //删除列
[ DROP CONSTRAINT <完整性约束名> [RESTRICT|CASCADE]]	 //删除约束
[ ALTER COLUMN <列名> <数据类型> ]					 //修改列
```

---

**删除基本表**

```mysql
DROP TABLE <表名> [RESTRICT|CASCADE]
```

- RESTRICT 限制删除，表不能被其他表引用（CHECK、FOREIGN KEY），不能有视图、触发器、储存过程和函数等，否则不能删除

---

#### 4.索引创建与删除

- 索引的底层可以有多种实现形式
  - 顺序文件上的索引
  - B+树索引
  - 散列索引
  - 位图索引

**建立索引**

```mysql
CREATE [UNIQUE] [CLUSTER] INDEX <索引名>
on <表名> (<列名> [<次序>] [, <列名> [<次序>]] ...);
```

次序：ASC | DESC —— 升序|降序

- 索引可以建在一个表的一列或者多列上
- UNIQUE CLUSTER
  - **UNIQUE** 表示每一个索引值只对应唯一的数据记录
  - **CLUSTER** 表示要建立的索引是聚簇索引

---

**修改索引**

```mysql
ALTER INDEX <旧索引名> RENAME TO <新索引名>
```

**删除索引**

```mysql
DROP INDEX <索引名>
```

---

**数据字典** —— 数据库管理系统内部的一组系统表，记录了数据库的所有定义信息（关系模式、视图、索引、完整性约束、操作权限、统计信息等）。

---

#### 5.数据查询

```mysql
SELECT [ALL|DISTINCT] <目标列表达式> [,<目标列表达式>] ...
FROM <表名|视图名> [,<表名或视图名>...] | (<SELECT语句>) [AS] <别名>
[WHERE <条件表达式>]
[GROUP BY <列名1> [HAVING <条件表达式>]]
[ORDER BY <列名2> [ASC|DESC]]
```

- **DISTINCT** -- 用于取消表中的重复行，相反则为ALL，默认为ALL

**查询计算后的值**

```mysql
SELECT Sname,2014-Sage 'Birth Year' //后面定义了别名
FROM Student;
```

**可插入引入的常量列**

```mysql
SELECT Sname,2014-Sage as 'Birth Year','HUST' as 'School' //别名的另一种写法
FROM Student;
```

**常用查询条件**

| =,> < >= <= != !> !< ; NOT + 上述比较运算符 |
| ------------------------------------------- |
| BETWEEN AND；NOT BETWEEN AND                |
| IN ，NOT IN                                 |
| LIKE，NOT LIKE                              |
| IS NULL；IS NOT NULL                        |
| AND，OR，NOT                                |

- **IN / NOT IN**后接集合，可用 (常量1,常量2 ...) 定义常量元素的集合，也可以接单列的子查询
- **LIKE / NOT LIKE**用于字符串匹配，%用于匹配任意长度的字符串，_用于匹配单个字符
  - 可后接 ESCAPE '<换码字符>' 用于手动定义转义字符，当需要匹配%或者_时，添加在前面

**ORDER BY排序**

```mysql
ORDER BY <列名> [ASC | DESC]
```

- ASC -- 升序 DESC -- 降序

**聚集函数**

- 常见聚集函数

```mysql
COUNT(*)
COUNT([DISTINCT] <列名>)
SUM([DISTINCT] <列名>)
AVG([DISTINCT] <列名>)
MAX([DISTINCT] <列名>)
MIN([DISTINCT] <列名>)
```

- 聚集函数只能用于SELETCT子句或者GROUP BY中的HAVING子句

**GROUP BY子句**

- 使用GROUP BY子句后，某些聚集函数会以每组为为对象进行计算

```mysql
SELECT Cno,COUNT(Sno)
FROM SC
GROUP BY Cno;	//按照Cno进行分组，并统计每一个分组中的元组的数量（统计选课Cno的学生人数）
```

**连接查询**

- WHERE子句可用于定义多个表的连接查询

```mysql
[<表名1>.] <列名1> <比较运算符> [<表名2>.] <列名2>	
```

- 可以区分列名时，表名可以省略，也能用BETWEEN运算符进行连接
- 使用等号叫做等值连接，否则叫做非等值连接
- 不定义连接形式，则默认为自然连接：使用两个表的所有相同属性列进行等值查询
- 一种连接算法叫做**嵌套循环连接**

**另一种连接形式**（用在FROM子句中）

```mysql
<表1> inner join <表2> on <条件>
<表1> LEFT OUTER JOIN <表2> on <条件>
<表1> RIGHT OUTER JOIN <表2> on <条件>
```

**自连接**

```mysql
SELECT FIRST.Cno,SECOND.Cpno
FROM Course FIRST,Course SECOND
WHERE FIRST.Cpno = SECOND.Cno
```

- FROM子句中可定义别名

**嵌套查询**

- 如子查询可用作集合放在父查询的IN/NOT IN谓词后面
- **相关子查询** —— 子查询的查询条件依赖于父查询       **不相关子查询** —— 子查询的查询条件不依赖于父查询

- **ANY / ALL**的使用

- **EXISTS**谓词的使用（WHERE子句）
  - EXISTS只产生逻辑真假，父查询中依次检查EXISTS子句，若返回true，就会将父查询中的相关元组选出

**集合查询**

- **UNION**并操作
- **INTERSECT**交操作
- **EXCEPT**差操作

#### 6.数据更新

**插入元组**

```mysql
INSERT INTO <表名> [(<属性列1> [, <属性列2>]...)]
VALUES (<常量1> [, <常量2> ]...);
```

**将子查询的结果插入到表中**

``` mysql
INSERT INTO <表名> [(<属性>，...)]
子查询;
```

**修改数据**

```mysql
UPDATE <表名>
SET <列名> = <表达式> [,<列名>=<表达式>] ...
[WHERE <条件>];
```

**选择性的修改（带子查询）**

```mysql
UPDATE <表名>
SET <列名1> = <表达式>
WHERE <列名2> in (子查询);	//这里的子查询检查出<列名2>满足一定要求的元组
```

**删除元素**

```mysql
DELETE FROM <表名>
[WHERE <条件>];
```



### 7.视图

**创建视图**

```mysql
CREATE VIEW <视图名> [(<列名> [,<列名>]...)]
AS 子查询
[WITH CHECK OPTION];
```

- WITH CHECK OPTION表示对视图进行UPDATE，INSERT，DELETE操作时要保证更新，插入或者删除的行满足视图定义中的谓词条件（子查询中WHERE的条件）。

# 其他相关

## 1.单例设计模式

单例设计模式，使用的频率比较高：在整个项目中，有某个或者某些特殊的类，属于该类的对象，我只能创建一个，多了创建不了。单例是写法比较特殊的类，整个项目中只能有一个，用于配置文件之类的操作。

```c++
class MyCAS //这是一个单例类
{
private:
    MyCAS(){}           //构造函数私有化了
                               //不能创建对象
private:
    static MyCAS *m_instance; //静态成员变量
 
public:
    static MyCAS *GetInstance()
    {
         if(m_instance ==nullptr)
             {
                 m_instance = new MyCAS();
              }
          return m_instance;
    }
};
```

## 2.C++STL内存池

　既然内存分配耗时, 那我们很容易想到的就是一次性分配一大块内存, 然后在用户需要的时候再划分其中一部分给用户, 这样的话, **一次分配, 多次使用, 自然而然提高了效率**, 而用来管理这所谓的一大块内存的数据结构, 也就是今天我们要说的内存池.

**1.内存申请流程图**

　　小于等于128k的用第二级分配器；

　　大于128k的用第一级分配器

![](C:\Users\18147\Desktop\面试准备\resources\006.png)

**2. 第一级配置器：**

　　第一级採用malloc、free；

此外，这个配置器提供了当内存配置错误时的处理函数oom*malloc，这个函数会调用*_malloc_alloc_oom_handler()这个错误处理函数，去企图释放内存，然后重新调用malloc分配内存。如此循环，直到分配成功，返回指针（所以再一定程度上提高内存分配成功）。

**3. 第二级配置器**

　　使用**自由链表(free-list)**技巧。主动将不论什么小额区块的**内存需求量上调至8的倍数**。如需求30，则上调至32。
  free-list节点结构

```c++
union obj 
{
     union obj * free_list_link;     //下一个节点的指针
     char client_data[1];                    //内存首地址
}
```

有16个free-lists。各自管理大小分别为8、16、24、32、40、48、56、64、72、80、88、96、104、112、120、128 bytes的**小额区块**。

![](C:\Users\18147\Desktop\面试准备\resources\007.png)

**释放内存**

![](C:\Users\18147\Desktop\面试准备\resources\008.png)

所以最终**内存池的思路**其实是这样的:

\1. 使用allocate向内存池请求size大小的内存空间, 如果需要请求的内存大小大于128bytes, 直接使用malloc.

\2. 如果需要的内存大小小于128bytes, allocate根据size**找到最适合的自由链表**.

　　a. 如果链表不为空, 返回第一个node, 链表头改为第二个node.

　　b. 如果链表为空, 使用blockAlloc请求分配node.

　　　　x. 如果内存池中有大于一个node的空间, 分配尽可能多的node(但是最多20个), 将一个node返回, 其他的node添加到链表中.

　　　　y. 如果内存池只有一个node的空间, 直接返回给用户.

　　　　z. 若果如果连一个node都没有, 再次向操作系统请求分配内存.

　　　　　　①分配成功, 再次进行b过程

　　　　　　②分配失败, 循环各个自由链表, 寻找空间

　　　　　　　　I. 找到空间, 再次进行过程b

　　　　　　　　II. 找不到空间, 抛出异常(代码中并未给出, 只是给出了注释)

\3. 用户调用deallocate释放内存空间, 如果要求释放的内存空间大于128bytes, 直接调用free.

\4. 否则按照其大小找到合适的自由链表, 并将其插入.

 

**特点**其实是这样的 :

\1. 刚开始初始化内存池的时候, 其实内存池中并没有内存, 同时所有的自由链表都为空链表.

\2. 只有用户第一次向内存池请求内存时, 内存池会依次执行上述过程的 1->2->b->z来完成内存池以及链表的首次填充, 而此时, 其他未使用链表仍然是空的.

\3. 所有已经分配的内存在内存池中没有任何记录, 释放与否完全靠程序员自觉.

\4. 释放内存时, 如果大于128bytes, 则直接free, 否则加入相应的自由链表中而不是直接返还给操作系统.



## 3.C++线程中的几种锁

### 1.互斥锁

​	**互斥锁**用于控制多个线程对他们之间共享资源互斥访问的一个信号量。也就是说是为了避免多个线程在某一时刻同时操作一个共享资源。例如线程池中的有多个空闲线程和一个任务队列。任何是一个线程都要使用互斥锁互斥访问任务队列，以避免多个线程同时访问任务队列以发生错乱。

​	在某一时刻，只有一个线程可以获取互斥锁，在释放互斥锁之前其他线程都不能获取该互斥锁。如果其他线程想要获取这个互斥锁，那么这个线程只能以阻塞方式进行等待。

### 2.条件锁

​	条件锁就是所谓的条件变量**，某一个线程因为某个条件为满足时可以使用条件变量使改程序处于阻塞状态**。一旦条件满足以“信号量”的方式唤醒一个因为该条件而被阻塞的线程。最为常见就是在线程池中，起初没有任务时任务队列为空，此时线程池中的线程因为“任务队列为空”这个条件处于阻塞状态。一旦有任务进来，就会以信号量的方式唤醒一个线程来处理这个任务。这个过程中就使用到了条件变量pthread_cond_t。

### 3.自旋锁

​	下面通过比较互斥锁和自旋锁原理的不同，这对于真正理解自旋锁有很大帮助。

​	假设我们有一个两个处理器core1和core2计算机，现在在这台计算机上运行的程序中有两个线程：T1和T2分别在处理器core1和core2上运行，两个线程之间共享着一个资源。

​	首先我们说明互斥锁的工作原理，互斥锁是是一种sleep-waiting的锁。假设线程T1获取互斥锁并且正在core1上运行时，此时线程T2也想要获取互斥锁（pthread_mutex_lock），但是由于T1正在使用互斥锁使得T2被阻塞。当T2处于阻塞状态时，T2被放入到等待队列中去，处理器core2会去处理其他任务而不必一直等待（忙等）。也就是说处理器不会因为线程阻塞而空闲着，它去处理其他事务去了。
​	而自旋锁就不同了，自旋锁是一种busy-waiting的锁。也就是说，如果T1正在使用自旋锁，而T2也去申请这个自旋锁，此时T2肯定得不到这个自旋锁。与互斥锁相反的是，此时运行T2的处理器core2会一直不断地循环检查锁是否可用（自旋锁请求），直到获取到这个自旋锁为止。

​	从“自旋锁”的名字也可以看出来，如果一个线程想要获取一个被使用的自旋锁，那么它会一致占用CPU请求这个自旋锁使得CPU不能去做其他的事情，直到获取这个锁为止，这就是“自旋”的含义。

​	当发生阻塞时，互斥锁可以让CPU去处理其他的任务；而自旋锁让CPU一直不断循环请求获取这个锁。通过两个含义的对比可以我们知道“自旋锁”是比较耗费CPU的。

### 4.读写锁

​	说到读写锁我们可以借助于“读者-写者”问题进行理解。首先我们简单说下“读者-写者”问题。

​	计算机中某些数据被多个进程共享，对数据库的操作有两种：一种是读操作，就是从数据库中读取数据不会修改数据库中内容；另一种就是写操作，写操作会修改数据库中存放的数据。因此可以得到我们允许在数据库上同时执行多个“读”操作，但是某一时刻只能在数据库上有一个“写”操作来更新数据。这就是一个简单的读者-写者模型。

## 4.编码格式

### 1.utf-8

​	UTF-8是针对Unicode的一种**可变长度**字符编码；它可以用来表示Unicode标准中的任何字符，而且其编码中的第一个字节仍与ASCII相容，使得原来处理ASCII字符的软件无须或只进行少部份修改后，便可继续使用。

**基本特征**

​	UCS字符U+0000到U+007F（ASCII）被编码为字节0×00到0x7F（ASCIⅡ兼容）。这意味着只包含**7位ASCIl字符的文件在ASCIⅡ和UTF-8两种编码方式下是一样的。**

​	所有大于0x007F的UCS字符被编码为一个有**多个字节的串**，每个字节都有**标记位集**。因此，ASCIl字节（0x00-0x7F）不可能作为任何其他字符的一部分。表示**非ASCIl字符的多字节串的第一个字节总是在0xC0到0XFD的范围里（以1开头）**，并**指出这个字符包含多少个字节**。多字节串的**其余字节都在0x80到0xBF范围里。这使得重新同步非常容易，并使编码无国界，且很少受丢失字节的影响。**

UTF-8编码字符理论上可以**最多到6个字节长**，然而16位BMP字符最多只用到3字节长，Bigendian UCS-4字节串的排列顺序是预定的，字节0xFE和OxFF在UTF-8编码中从未用到。

**编码字节数**

UTF-8使用1~4字节为每个字符编码：

·一个US-ASCIl字符只需1字节编码（Unicode范围由U+0000~U+007F）。

·带有变音符号的拉丁文、希腊文、西里尔字母、亚美尼亚语、希伯来文、阿拉伯文、叙利亚文等字母则需要2字节编码（Unicode范围由U+0080~U+07FF）。

·其他语言的字符（包括**中日韩文字**、东南亚文字、中东文字等）包含了**大部分常用字**，使用**3字节编码**。

·其他极少使用的语言字符使用4字节编码。

**UTF-8编码规则**

如果**只有一个字节则其最高二进制位为0**；如果是多字节，其**第一个字节从最高位开始，连续的二进制位值为1的个数决定了其编码的字节数，其余各字节均以10开头。**

### 2.utf-16

​	UTF-16 编码介于 UTF-32 与 UTF-8 之间，同时结合了定长和变长两种编码方法的特点。它的编码规则很简单：基本平面的字符占用 2 个字节，辅助平面的字符占用 4 个字节。也就是说，UTF-16 的编码长度**要么是 2 个字节**（U+0000 到 U+FFFF），**要么是 4 个字节**（U+010000 到 U+10FFFF）。

在基本平面内，从 **U+D800** 到 **U+DFFF** 是一个空段，即这些码点不对应任何字符。因此，这个空段可以用来**映射辅助平面的字符**。

辅助平面的字符位共有 2^20 个，因此表示这些字符至少需要 20 个二进制位。UTF-16 将这 20 个二进制位分成两半，前 10 位映射在 U+D800 到 U+DBFF，称为高位（H），后 10 位映射在 U+DC00 到 U+DFFF，称为低位（L）。这意味着，一个辅助平面的字符，被拆成两个基本平面的字符表示。

因此，当我们遇到两个字节，发现它的码点在 U+D800 到 U+DBFF 之间，就可以断定，紧跟在后面的两个字节的码点，应该在 U+DC00 到 U+DFFF 之间，这四个字节必须放在一起解读。

汉字"?"的 Unicode 码点为 0x20BB7，该码点显然超出了基本平面的范围（0x0000 - 0xFFFF），因此需要使用四个字节表示。首先用 0x20BB7 - 0x10000 计算出超出的部分，然后将其用 20 个二进制位表示（不足前面补 0 ），结果为0001000010 1110110111。接着，将前 10 位映射到 U+D800 到 U+DBFF 之间，后 10 位映射到 U+DC00 到 U+DFFF 即可。U+D800 对应的二进制数为 1101100000000000，直接填充后面的 10 个二进制位即可，得到 1101100001000010，转成 16 进制数则为 0xD842。同理可得，低位为 0xDFB7。因此得出汉字"?"的 UTF-16 编码为 0xD842 0xDFB7。



### 3.Unicode

​	它仅仅只是一个字符集，规定了符合对应的二进制代码，至于这个二进制代码如何存储则没有任何规定。它的想法很简单，就是为每个字符规定一个用来表示该字符的数字，仅此而已。

​	Unicode仅仅使用16字节表示相应字符信息。

### 4.ASCII



## 4.互联网七层体系结构每层的作用

![](C:\Users\18147\Desktop\面试准备\resources\009.png)

![](C:\Users\18147\Desktop\面试准备\resources\010.png)

## 5.乐观锁与悲观锁

**悲观锁**
总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。

**乐观锁**
总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。

**乐观锁适用于写比较少的情况下（多读场景）**，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以**一般多写的场景下用悲观锁就比较合适。**

**乐观锁常见的两种实现方式**

**（1）版本号机制**

一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。

举一个简单的例子：

假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ balance ）为 $100 。当需要对账户信息表进行更新的时候，需要首先读取version字段。

操作员 A 此时将其读出（ version=1 ），并从其帐户余额中扣除 $50（ $100-$50 ）。
在操作员 A 操作的过程中，操作员B 也读入此用户信息（ version=1 ），并从其帐户余额中扣除 $20 （ $100-$20 ）。
操作员 A 完成了修改工作，提交更新之前会先看数据库的版本和自己读取到的版本是否一致，一致的话，就会将数据版本号加1（ version=2 ），连同帐户扣除后余额（ balance=$50 ），提交至数据库更新，此时由于提交数据版本大于数据库记录当前版本，数据被更新，数据库记录 version 更新为 2 。
操作员 B 完成了操作，提交更新之前会先看数据库的版本和自己读取到的版本是否一致，但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 2 ，而自己读取到的版本号为1 ，不满足 “ 当前最后更新的version与操作员第一次读取的版本号相等 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。
这样，就避免了操作员 B 用基于 version=1 的旧数据修改的结果覆盖操作员A 的操作结果的可能。
**（2）CAS算法**

即compare and swap（比较与交换），是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。CAS算法涉及到三个操作数

- 需要读写的内存值 V

- 进行比较的值 A

- 拟写入的新值 B

当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。

**乐观锁的缺点**

ABA 问题是乐观锁一个常见的问题

**1 ABA 问题**
如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 "ABA"问题。

JDK 1.5 以后的 AtomicStampedReference 类就提供了此种能力，其中的 compareAndSet 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。

**2 循环时间长开销大**
自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。 如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。

**3 只能保证一个共享变量的原子操作**
CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5开始，提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用AtomicReference类把多个共享变量合并成一个共享变量来操作。

**CAS与synchronized的使用情景**
简单的来说CAS适用于写比较少的情况下（多读场景，冲突一般较少），synchronized适用于写比较多的情况下（多写场景，冲突一般较多）

对于资源竞争较少（线程冲突较轻）的情况，使用synchronized同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。
对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。
补充： Java并发编程这个领域中synchronized关键字一直都是元老级的角色，很久之前很多人都会称它为 “重量级锁” 。但是，在JavaSE 1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的 偏向锁 和 轻量级锁 以及其它各种优化之后变得在某些情况下并不是那么重了。synchronized的底层实现主要依靠 Lock-Free 的队列，基本思路是 自旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了高吞吐量。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。



## 6.C++的类的大小，C++内存组织

C++空类的大小为1，编译器优化的效果（因为需要让它能够编译）

C++的类在分配内存时会自动进行成员对齐操作。

每个特定平台上的编译器都有自己的默认“**对齐系数**”（也叫对齐模数）。程序员可以通过预编译命令**#pragma pack(n)，n=1,2,4,8,16**来改变这一系数，其中的n就是你要指定的“对齐系数”。

数据成员对齐规则： 类（class）、结构体（struct）或联合体（union）的数据成员，**第一个数据成员放在offset为0的地方，以后每个数据成员的对齐按照#pragma pack指定的数值和这个数据成员自身长度中，比较小的那个进行。**
整体对齐规则： 在数据成员完成各自对齐之后，类、结构体或联合体本身也要进行对齐，对齐将按照#pragma pack指定的数值和类、结构体或联合体最大数据成员长度中，比较小的那个进行。
结合1、2可推断，当#pragma pack的n值等于或超过所有数据成员长度的时候，这个n值的大小将不产生任何效果。

类的成员函数本身不会影响类的大小，除非有虚函数地址表

带有继承的类，子类成员会接在父类成员之后



## 7.URL解析过程

网页解析的全过程
   **1、用户输入网址，浏览器发起DNS查询请求**

用户访问网页，DNS服务器（域名解析系统）会根据用户提供的域名查找对应的IP地址

域名解析服务器是基于UDP实协议实现的一个应用程序，通常通过监听53端口来获取客户端的域名解析请求。DNS查找过过程如下：

**浏览器缓存**-浏览器会缓存DNS记录一段时间。有趣的是操作系统没有告诉浏览器存储DNS记录的时间，这样不同浏览器会记录他们各自固定的一个时间（2分钟到30分钟不等）

**系统缓存**-如果在浏览器缓存中没有找到需要的记录，浏览器会做一个系统调用（gethostbyname）。这样便可获得系统缓存中的记录。

**路由器缓存**-接着前面的查询请求发向路由器，他一般会有自己的DNS缓存

**ISP DNs缓存**-接下来要check的就是ISP缓存DNS的服务器。在这一般都能找到相应的缓存记录。

**递归搜索**-你的ISP的DNS服务器从域名服务器开始进行递归搜索，从com顶级域名服务器到Facebook的域名服务器。一般DNS服务器的缓存中会有.com域名服务器中的域名，所以到顶级服务器的匹配过程不是那么必要了。

   **2、建立TCP连接**

浏览器通过DNS获取到web服务器真的IP地址后，便向服务器发起TCP连接请求，通过tcp的三次握手建立好连接后，浏览器便可以将http请求数据通过发送给服务器了。

   **3、浏览器向web服务器发送一个http请求**

http请求时基于tcp协议之上的应用层协议--超文本传输协议。一个http事务由一条（从客户端发往服务器的）请求命令和一个（从服务器发回客户端的）响应结果组成。

GET http://www.cricode.com/ HTTP/1.1

Host: www.cricode.com

Connection: keep-alive

Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8

User-Agent: Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.114 Safari/537.36

Accept-Encoding: gzip,deflate,sdch

Accept-Language: zh-CN,zh;q=0.8

   **4、发送响应数据给客户端**

web服务器通过监听80端口，来获取客户端的http请求。与客户端建立好TCP连接后，web服务器开始接受客户端发来的数据，并通过http解码，从接收到的网络数据中解析出请求的url信息以前其他诸如Accept-Encoding、Accept-Language等信息。Web服务器根据http请求头的信息，得到响应数据返回给客户端。一个典型的http响应头数据报如下：

HTTP/1.1 200 OK

Date: Fri, 24 Oct 2014 13:55:18 GMT

Server: Apache

X-Powered-By: PHP/5.4.32

Keep-Alive: timeout=5, max=10000

Connection: Keep-Alive

Transfer-Encoding: chunked

Content-Type: text/html; charset=UTF-8

a0f6

<</span>!DOCTYPE HTML>

<</span>html>

<</span>head>

<</span>meta charset="UTF-8">

<</span>meta http-equiv="X-UA-Compatible" content="IE=10,IE=9,IE=8">

<</span>meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimum-scale=1.0, maximum-scale=1.0">

<</span>title><</span>/title>

<</span>body class="home"><</span>/body>

<</span>/html>

至此，一个http通信过程完成。web服务器会根据http请求头中的Connection字段值决定是否关闭TCP链接通道，当Connection字段值为keep-alive时，web服务器不会立即关闭此链接。

   **5、浏览器解析http response**

（1）html文档解析（DOM Tree）

在浏览器没有完整的接收全部HTML文档时，它就已经开始显示这个页面了。生成解析树解析即dom树，是由dom元素及属性节点组成，树的根是docunment对象。

（2）浏览器发送获取嵌入在html中的对象

加载过程中遇到外部css文件，浏览器另外发出一个请求，来获取css文件。遇到图片资源，浏览器也会另发出一个请求，来获取图片资源。这是异步请求，并不会影响html文档进行加载。

但是当文档加载过程中遇到js文件，html文档会挂起渲染的线程，不仅要等待文档中的js文件加载完毕，还要等待解析执行完毕，才能恢复html文档的渲染线程。

（3）css解析

浏览器下载css文件，将css文件解析为样式表对象，并来用渲染dom tree。该对象包含css规则，该规则包含选择器和声明对象。

css元素遍历的顺序，是从树的低端向上遍历。

（4）js解析

浏览器UI线程：单线程，大多数浏览器让一个单线程共用于执行JavaScript和更新用户界面

js阻塞页面：浏览器里的http请求被阻塞一般都是由js所引起，具体原因是js文件在下载完毕之后会立即执行，而js执行时候会阻塞浏览器的其他行为，有一段时间是没好网络请求被处理的，这段空闲时间就是所谓的http请求被阻塞。

js被阻塞的原因：之所以会阻塞U线程的执行，是因为js能控制UI的展示，而页面加载的规则是要顺序执行，所以在碰到js代码时候UI线程会首先执行他。

