# HTTP 超文本传输协议

## 1.协议简述

1. **超文本**：是文字、图片、音频和视频的混合体，并拥有“超链接”，能够从一个“超文本”跳跃到另一个“超文本”，形成网状的结构关系。
2. **传输**：意思是**两点之间传输数据**。
3. **协议**：意思是**对行为的约定和规范**。

- 综合来看**HTTP 是一个对两点之间传输超文本数据的约定和规范。**

## 2.HTTP报文

- **“起始行 + 头部 + 空行 + 实体”**
  - 起始行（start line）：请求行或是状态行  

    请求行格式：“请求方法 目标URI 协议版本号” 

    状态行格式：“协议版本号 状态码 原因” 

  - 头部（header）：使用 key-value 详细说明报文； 

  - 消息体（entity）：实际传输的数据

## 3.请求方法与幂等性

（1）**GET**方法的含义是请求从服务器获取指定的URI 资源，可以搭配其他 头部 **字段** 实现对资源更精细的操作。

```http
GET /10-2 HTTP/1.1
Host: www.chrono.com
```

（2）**POST**方法的含义是向指定的URI 资源提交数据，数据就放在报文的 body 里。

```http
post /10-2 HTTP/1.1
Host:222.chrono.com
Content-Length:17
POST DATA IS HERE
```

（3）**幂等**意思是**多次执行相同的操作后结果是相同的**，GET和HEAD这种只读显然幂等，DELETE多次删除同个资源结果都是资源不存在，PUT多次修改同一个资源显然也幂等，但POST每次都提交新数据就不幂等了。联系到SQL中，POST就像insert，PUT就像update。

（4）**安全**是指请求方法不会对服务器上的资源造成修改。

## 4.**POST和GET的区别**

- **POST和GET的本质都是 TCP 链接，并无区别。但是由于 HTTP 的规定以及浏览器/服务器的限制，导致它们在应用过程中可能会有所不同。具体的有**

（1）GET 用于获取资源，无副作用、安全且幂等，会被浏览器主动缓存；

（2）POST 用于修改服务器上的资源，有副作用、不安全不幂等，除非手动设置否则不会被浏览器主动缓存

（3）GET的参数直接暴露在URL上，POST的参数放在消息体里不会暴露，但HTTP本身在网络上是明文传输的，所以GET和POST都不安全，除非用HTTPS。

（4）GET的参数数据类型必须是ASCII码字符，POST没有限制。

（5）一个很有意思的事情是国外一篇博客说Ruby的net::HTTP库在使用POST方法时会 先将请求头和消息体分两个TCP数据包发送，我自己测试了我主机上的各个浏览器包括postman都没有看到这个现象，所以这应该是很少见的现象（这很好验证，我们写一个服务端，封装简单的HTTP处理方法，然后我们用浏览器或postman发一个post请求，然后抓包看一下就可以）。

（6）虽然HTTP本身不限制URL的长度，但因为长url处理起来很耗资源所以浏览器和服务器为了性能和安全考虑（避免长url攻击）对 url 的长度有限制，所以 GET请求在URL中传送的参数是有长度限制的，而POST请求没有（一样可以验证一下HTTP不限制URL的长度，我们写个服务端让它在接收到请求时打印报文，然后用postman发送超过2k个字符的get请求，可以看到打印出来的url长度多少都没问题）。

## 5.URI和响应状态码

- 1xx：**指示信息**--表示请求已接收，继续处理

  ​	100 ——客户端必须继续发出请求；101——客户端要求服务器转换 HTTP 协议版本。

- 2xx：成功--表示请求已被成功接收、理解、接受

  ​	200——OK 204--请求收到，但返回信息为空；206——服务器已经完成了部分用户的 GET 请求

- 3xx：重定向--信息不完整需要进一步补充

  ​	300——请求资源在多处可得到。301——永久重定向，隐式重定向。302 临时重定向，显示重定向。304——请求的资源没有改变，可以使用缓存。

- 4xx：客户端错误--请求有语法错误或请求无法实现

  ​	401——未授权；403——禁止访问。 404——找不到；409——对当前资源状态，请求不能完成

- 5xx：服务器端错误--服务器未能实现合法的请求

  ​	500 内部服务器错误，501 未实现， 502 网关错误，503 服务不可用，504 网关超时。

## 6.cookie和session

由于HTTP协议是无状态的协议，需要用某种机制来识具体的用户身份，用来跟踪用户的整个会话。常用的会话跟踪技术是cookie与session。

（1）**Cookie**是一种通过在客户端记录信息确定用户身份的会话追踪技术

​	cookie的工作流程：

​	a）当浏览器访问一个支持cookie的网站时，浏览器会把个人信息提交至服务端； 

​	b）然后服务端创建并保存对应的cookie并在响应请求时发回set-cookie，set-cookie放在响应报文的header中 

​	c）浏览器收到响应之后将set-cookie保存 

​	d）下次访问时浏览器将自动携带cookie发送至服务端，服务端通过cookie就能够知道用户的信息，从而动态生成相对应的内容。

![cookie](.\resources\001.png)

（2）**session**是一种通过在服务器端记录信息确定用户身份的会话追踪技术。

​	session的工作流程：

​	a）当客户端请求服务端时，服务端首先检查请求报文是否包含sessionid，如果包含则说明服务端已经为这个客户端创建过session，服务端就将对应的session检索出来使用 

​	b）如果请求报文不包含sessionid，服务端就为这个客户端创建一个session，并且生成一个对应的sessionid存放到set-cookie中在本次响应中返回到客户端保存。 

​	c）之后客户端每次请求都会带着sessionid，服务器根据sessionid就可以找到对应的session，从而知道用户的信息，动态生成相对应的内容。

![session](.\resources\002.png)

（3）cookie和session区别

- **存储位置不同**，cookie数据存储在客户端，session数据存储在服务端； 

- **隐私策略不同**，cookie数据存储在客户端，所以对客户端可见，有信息泄露的风险，敏感信息最好不存放在cookie中，cookie也可以像[google]()、baidu那样做一个加密，在服务端解密；而session数据存放在服务端，对客户端不可见，但是sessionid通过cookie存储，所以客户端仅能 看见sessionid 

- **存取类型不同**，Cookie中只能保管ASCII码字符串，若要存储略微复杂的信息非常麻烦；而Session能够存储任何类型的数据，String、Integer、List、Map，也能够直接保管任何Java类和对象，使用起来十分方便。 

- **有效期不同**，cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，session 一般失效时间较短，客户端关闭或者 session 超时都会失效。 

- **浏览器支持的不同**，Cookie是需要客户端浏览器支持的，如果客户端禁用了Cookie或者不支持Cookie，cookie就不能用了；但sessoin不会，虽然session更常见的实现是通过cookie传递sessionid的，但也可以在配置过后通过url传递sessionid

## 7.**HTTP中请求应答过程（请求响应模型）**

- 浏览器：浏览器本质上是一个 HTTP 协议中的**请求方** 

- 服务器（Web server）  
  - **硬件**含义就是物理形式或“云”形式的机器，在大多数情况下它可能不是一台服务器，而是利用反向代理、负载均衡等技术组成的庞大集群 
  - **软件**含义的 Web 服务器就是提供 Web 服务的应用程序，通常会运行在硬件含义的服务器上。它利用强大的硬件能力响应海量的客户端 HTTP 请求，处理磁盘上的网页、图片等静态文件，或者把请求转发给后面的 Tomcat、Node.js 等业务应用，返回动态的信息。如Nignx，Tomcat，Jetty等 
  - 所谓的后端开发也是服务端开发

**基于HTTP协议的客户端/服务器请求响应机制的信息交换过程包含下面几个步骤：**

1) **建立连接**：客户端与服务器建立TCP连接

2) **发送请求**：打开一个连接后，客户端把请求信息发送到服务器的相应端口上，完成请求动作提交。

3) **发送响应**：服务器在处理完客户端请求之后，要向客户端发送响应消息。

4) **关闭连接**：客户端和服务器端都可以关闭套接字来结束TCP/IP对话。
