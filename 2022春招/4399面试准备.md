**4399面试要求：**

1、本科及以上学历，22届计算机、软件等相关专业；

2、计算机基础扎实，熟练掌握C++，对算法和数据结构、网络通讯有很好的掌握和理解，熟悉常用设计模式；
3、具备较强的分析和解决问题的能力，积极上进，沟通良好，有责任心，具有良好的团队合作精神。



面经

技术问题

#### 1.指针引用区别 https://blog.csdn.net/qq_27678917/article/details/70224813

#### 2.内存有哪些问题 (内存泄漏，野指针，空指针，栈溢出，越界) https://zhuanlan.zhihu.com/p/44024266

#### 3.怎么解决内存问题  https://blog.csdn.net/weixin_44363885/article/details/93617377

​	尽量使用栈空间，少用堆空间，注意递归、申请的空间注意释放

#### 4.智能指针的原理 https://blog.csdn.net/lizhentao0707/article/details/81156384

#### 5.进入视野，离开视野，移动广播

#### 6.除了A星算法还知道其他算法吗  http://blog.chinaunix.net/uid-8074738-id-5747101.html

- DFS
- BFS
- Dijkstra

#### 7.A星算法的原理 https://www.cnblogs.com/leoin2012/p/3899822.html

A星算法是一种寻径算法，寻路常见的算法有BFS、DFS等。

而A星寻路的思路很简单：从开始点，每走一步都选择代价最小的格子走，直到达到结束点。

**A星算法核心公式就是F值的计算：**
**F = G + H**

F - 方块的总移动代价
G - 开始点到当前方块的移动代价
H - 当前方块到结束点的预估移动代价

以下详细解释这个公式，方便更好地理解它。

**G值是怎么计算的？**
假设现在我们在某一格子，邻近有8个格子可走，当我们往上、下、左、右这4个格子走时，移动代价为10；当往左上、左下、右上、右下这4个格子走时，移动代价为14；即**走斜线的移动代价为走直线的1.4倍**。
这就是G值最基本的计算方式，**适用于大多数2.5Drpg页游**。

基本公式：
**G = 移动代价**

根据游戏需要，G值的计算可以进行拓展。如加上地形因素对寻路的影响。格子地形不同，那么选择通过不同地形格子，移动代价肯定不同。同一段路，平地地形和丘陵地形，虽然都可以走，但平地地形显然更易走。
我们可以**给不同地形赋予不同代价因子，来体现出G值的差异**。如给平地地形设置代价因子为1，丘陵地形为2，在移动代价相同情况下，平地地形的G值更低，算法就会倾向选择G值更小的平地地形。

拓展公式：
**G = 移动代价 * 代价因子**

**H值是如何预估出来的？**
很显然，在只知道当前点，结束点，不知道这两者的路径情况下，我们无法精确地确定H值大小，所以只能进行预估。
有多种方式可以**预估H值**，如曼哈顿距离、欧式距离、对角线估价，最常用最简单的方法就是使用**曼哈顿距离**进行预估：
**H = 当前方块到结束点的水平距离 + 当前方块到结束点的垂直距离**

题外话：A星算法之所以被认为是具有启发策略的算法，在于其可通过预估H值，降低走弯路的可能性，**更容易找到一条更短的路径**。其他不具有启发策略的算法，没有做**预估处理**，只是穷举出所有可通行路径，然后从中挑选一条最短的路径。这也是A星算法效率更高的原因。

**每个方块的G值、H值是怎么确定的呢？**
G值 = 父节点的G值 + 父节点到当前点的移动代价
H值 = 当前点到结束点的曼哈顿距离

最后，A星算法还需要用到两个列表：
**开放列表** - 用于记录所有可考虑选择的格子
**封闭列表** - 用于记录所有不再考虑的格子

以上就是要完成A星算法所需要的东西,而算法的过程并不复杂。

**A星算法伪码：**

---

a、将开始点记录为当前点P
b、将当前点P放入封闭列表
c、搜寻点P所有邻近点，假如某邻近点既没有在开放列表或封闭列表里面，则计算出该邻近点的F值，并设父节点为P，然后将其放入开放列表
d、判断开放列表是否已经空了，如果没有说明在达到结束点前已经找完了所有可能的路径点，寻路失败，算法结束；否则继续。
e、从开放列表拿出一个F值最小的点，作为寻路路径的下一步。
f、判断该点是否为结束点，如果是，则寻路成功，算法结束；否则继续。
g、将该点设为当前点P，跳回步骤c。

---

**后续优化**

以上就是A星算法最基本的原理，明白了基本原理，用2,3百行代码写出一个可用的A星算法并不难。当然A星算法在实际应用中不仅于此，还可以对细节进行优化：

1、选择**排序更快的二叉树来作为开放列表**，帮助我们更快地从开放列表中取出F值最小的点；

2、对何种情况下可以走斜线路径加以判断；

3、采用布兰森汉姆算法预先判断两点是否可以直接通行，可通行就直接返回两点的直线路径，不可直接通行再采用A星算法寻路，提高寻路效率；

4、A星算法得出寻路路径后，可采用**弗洛伊德算法对路径进行平滑处理，使人物走动更为自然**


这里只是用语言讲解A星算法原理，并没有配图讲解整个寻路的过程，希望进一步直观理解整个过程的，推荐参考下面两个网友翻译过来的A星教程



#### 8.C++的三大特性 https://blog.csdn.net/qq_43414142/article/details/100892336

封装、继承、多态

#### 9.敏感词屏蔽 https://blog.csdn.net/little_stupid_child/article/details/54407271 https://www.cnblogs.com/lvrcbl/p/3884707.html



#### 10.用的什么IO https://www.oschina.net/p/hp-socket

HP-Socket 是一套通用的高性能 TCP/UDP/HTTP 通信框架，包含服务端组件、客户端组件和Agent组件，广泛适用于各种不同应用场景的 TCP/UDP/HTTP 通信系统，提供 C/C++、C#、Delphi、E（易语言）、Java、Python 等编程语言接口。HP-Socket 对通信层实现完全封装，应用程序不必关注通信层的任何细节；HP-Socket 提供基于事件通知模型的 API 接口，能非常简单高效地整合到新旧应用程序中。

#### 11.HPSocket 为什么用Epool https://baike.baidu.com/item/epoll/10738144?fr=aladdin

epoll是[Linux内核](https://baike.baidu.com/item/Linux内核)为处理大批量[文件描述符](https://baike.baidu.com/item/文件描述符/9809582)而作了改进的poll，是Linux下**多路复用[IO](https://baike.baidu.com/item/IO/5918)接口select/poll的增强版本**，它能**显著提高程序在大量[并发连接](https://baike.baidu.com/item/并发连接/3763280)中只有少量活跃的情况下的系统[CPU](https://baike.baidu.com/item/CPU/120556)利用率**。另一点原因就是获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行了。epoll除了提供select/poll那种IO事件的水平触发（Level Triggered）外，还提供了边缘触发（Edge Triggered），这就使得用户空间程序有可能缓存IO状态，减少epoll_wait/epoll_pwait的调用，提高应用程序效率。

#### 12.内存越界会怎么样

报错退出

#### 13.内存越界为什么会蹦 https://blog.csdn.net/wads23456/article/details/100170693

内存越界，为什么会崩溃
越界操作引起的崩溃根源一般是下面两种情况
1.权限问题 – 访问了没有相应访问权限的地址.一般读越界引起崩溃都是这种. 多数写越界也会直接或间接引起这种问题.
2.代码执行出错 – 执行了非法的代码或是由数据错误引起的代码执行异常. 这种错误多由写越界引起.比如写坏了栈导致执行的非法代码,读取错误数据. 写坏了堆引起堆管理代码执行异常等等.

越界就好比踏进了地雷区。很可能生还，也很可能碰到各种雷！！

“内存越界访问有两种：一种是读越界，即读了不属于自己的数据，如果所读的内存地址
是无效的，程度立刻就崩溃了。如果所读内存地址是有效的，在读的时候不会出问题，但由
于读到的数据是随机的，它会产生不可预料的后果。另外一种是写越界，又叫缓冲区溢出。
它会产生不可预料的后果，比如把程序返回地址改掉了，使函数返回时跳到未知内存，导致崩溃。

free的时候会做完整性检查

野指针，也就是指向不可用内存区域的指针。通常对这种指针进行操作的话，将会使程序发生不可预知的错误。
“野指针”不是NULL指针，是指向“垃圾”内存的指针。人们一般不会错用NULL指针，因为用if语句很容易判断。但是“野指针”是很危险的，if语句对它不起作用。野指针的成因主要有两种：

一、指针变量没有被初始化。任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。

二、指针p被free或者delete之后，没有置为NULL，让人误以为p是个合法的指针。别看free和delete的名字恶狠狠的（尤其是delete），它们只是把指针所指的内存给释放掉，但并没有把指针本身干掉。通常会用语句if (p != NULL)进行防错处理。很遗憾，此时if语句起不到防错作用，因为即便p不是NULL指针，它也不指向合法的内存块。例：

另外一个要注意的问题：不要返回指向栈内存的指针或引用，因为栈内存在函数结束时会被释放。
指针是个很强大的工具，可是正因为它太强大，所以要操作它不是件易事。操作不当造成的野指针，甚至会引起系统死机等比较严重的后果。 　如果程序定义了一个指针，就必须要立即让它指向一个我们设定的空间或者把它设为NULL，如果没有这么做，那么这个指针里的内容是不可预知的，即不知道它指向内存中的哪个空间（即野指针），它有可能指向的是一个空白的内存区域，可能指向的是已经受保护的区域，甚至可能指向系统的关键内存，如果是那样就糟了，也许我们后面不小心对指针进行操作就有可能让系统出现紊乱，死机了。所以我们必须设定一个空间让指针指向它，或者把指针设为NULL，这是怎么样的一个原理呢，如果是建立一个与指针相同类型的空间，实际上是在内存中的空白区域中开辟了这么一个受保护的内存空间，然后用指针来指向它，那么指针里的地址就是这个受保护空间的地址了，而不是不可预知的啦，然后我们就可以通过指针对这个空间进行相应的操作了；如果我们把指针设为NULL，我们在头文件定义中的 #define NULL 0 可以知道，其实NULL就是表示0，那么我们让指针＝NULL，实际上就是让指针＝0，如此，指针里的地址（机器数）就被初始化为0了，而内存中地址为0 的内存空间……不用多说也能想象吧，这个地址是特定的，那么也就不是不可预知的在内存中乱指一气的野指针了。 　　还应该注意的是，free和delete只是把指针所指的内存给释放掉，但并没有把指针本身干掉。指针p被free以后其地址仍然不变（非NULL），只是该地址对应的内存是垃圾，p成了“野指针”。如果此时不把p设置为NULL，会让人误以为p是个合法的指针。用free或delete释放了内存之后，就应立即将指针设置为NULL，防止产生“野指针”。内存被释放了，并不表示指针会消亡或者成了NULL指针。（而且，指针消亡了，也并不表示它所指的内存会被自动释放。） 　　最后，总结一下野指针的的成因吧： 1、指针变量没有被初始化。任何指针变量刚被创建时不会自动成为NULL指针，它的默认值是随机的，它会乱指一气。 2、指针p被free或者delete之后，没有置为NULL，让人误以为p是个合法的指针。 3、指针操作超越了变量的作用范围。这种情况让人防不胜防。

https://blog.csdn.net/tongxinxiao/article/details/8502304

https://www.cnblogs.com/clover-toeic/p/3816644.html

#include <stdio.h>
int main()
{}
全局变量和局部变量初始化与不初始化的区别
即int x 和 int x=0的区别。

int x =0; 跟 int x; 的效果看起来是一样的。但其实这里面的差别很大，强烈建议大家所有的全局变量都要初始化，他们的主要差别如下：

编译器在编译的时候针对这两种情况会产生两种符号放在目标文件的符号表中，对于初始化的，叫强符号，未初始化的，叫弱符号。连接器在连接目标文件的时候，如果遇到两个重名符号，会有以下处理规
则：
1、如果有多个重名的强符号，则报错。
2、如果有一个强符号，多个弱符号，则以强符号为准。
3、如果没有强符号，但有多个重名的弱符号，则任选一个弱符号。

例：

#include "stdafx.h"
int i;
int main(int argc, char* argv[])
{
 printf(" i = %d\n",i);
 int j;
 printf(" j %d\n",j);
 return 0;
}
在Debug版下，i输出是0，j输出是-858993460，也就是0xCCCCCCCC。
至于为什么是这个值，有网友给出这个解释。（设计成0xcccccccc是有特殊用意的……这个好像叫做Poison，未初始化的Pointer去取值的话会出错。肯定有人问为什么不弄成0x00000000，因为空指针是指针的有效状态，可能会误导人，而0xCCCCCCCC在Windows下永远不可能是一个指针的有效状态（不是NULL，不指向一个对象，不指向一堆对象紧接之后的区域），这就是在模拟野指针……）

值得注意的是，同样的代码在Release版下，这段代码中未被初始化的变量最后打印出来的可能都是0。也有强大的网友给出解释。（重点在于vc的一个功能：Catch release-build errors in debug build用/GZ编译开关打开。debug版这个开关是开的，release版是关的（为了效率）。这个开关说白了就是把所有动态局部变量初始化成0xcccccccc，把所有动态堆变量初始化成0xcdcdcdcd。很多新手会忘记初始化这些本来应该初始化的变量（尤其是new出来的变量），有时他们会假定这些变量应该是0，这样就可能出现在release版正常而debug版不正常的程序，因为release版至少局部变量的初始值很可能就是0，而有时他们又会假定或者期望这些变量不是0，这样就带了一个最难发现的bug）

切记 无论什么变量，记得初始化！！！！

#### 14.stl的map是什么数据结构 https://blog.csdn.net/zhu_0416/article/details/20099291

红黑树

#### 15.红黑树的特性 https://www.cnblogs.com/jibisheng/p/13178619.html

排序树的一种，黑度

#### 16.delete 和delete[] 区别 https://www.cnblogs.com/I-AM-Monster/p/4095925.html

new 分配的单个对象的内存空间的时候用 delete，回收用 new[] 分配的**一组对象的内存空间**的时候用 delete[]

基本类型的对象没有析构函数，所以回收基本类型组成的数组空间用 delete 和 delete[] 都是应该可以的；但是对于类对象数组，只能用 delete[]。对于 new 的单个对象，只能用 delete 不能用 delete[] 回收空间。 



# 常见设计模式

https://www.cnblogs.com/chengjundu/p/8473564.html

**1.简单工厂模式**

工厂模式有一种非常形象的描述，建立对象的类就如一个工厂，而需要被建立的对象就是一个个产品；在工厂中加工产品，而使用产品的人，不用在乎产品是如何生产出来的。从软件开发的角度来说，这样就有效的降低了模块之间的耦合。主要特点是需要在工厂类中做判断，从而创造相应的产品，当增加新产品时，需要修改工厂类。

使用情景： 

 在不确定会有多少个处理操作时应该考虑使用简单工厂模式，如针对同样的接收到的数据，处理的逻辑可能会不同，可能以后还会增加新的操作。

案例： 

![img](https:////upload-images.jianshu.io/upload_images/10950606-9fdf3cd641503538.png?imageMogr2/auto-orient/strip|imageView2/2/w/451/format/webp)

图一

**2.工厂方法模式**

是指定义一个创建对象的接口，让子类决定实例化哪一个类，Factory Method使一个类的实例化延迟到其子类。

 主要解决：主要解决接口选择的问题。针对同样的数据，不同的操作用不同的接口。

何时使用：我们明确地计划不同条件下创建不同实例时。

 如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品。

 关键代码：创建过程在其子类执行。

 缺点：每增加一种产品，就需要增加一个对象工厂。相比简单工厂模式，工厂方法模式需要定义更多的类。

![img](https:////upload-images.jianshu.io/upload_images/10950606-be20edd18b481421.png?imageMogr2/auto-orient/strip|imageView2/2/w/411/format/webp)

图二



**3.抽象工厂模式**

提供一个创建一系列相关或相互依赖的对象接口，而无需指定它们的具体类。

 主要解决：主要解决接口选择的问题。

 何时使用：系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。

 如何解决：在一个产品族里面，定义多个产品。

 关键代码：在一个工厂里聚合多个同类产品。

缺点：产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。

![img](https:////upload-images.jianshu.io/upload_images/10950606-b81e4384ba9e6d8a.png?imageMogr2/auto-orient/strip|imageView2/2/w/342/format/webp)

![img](https:////upload-images.jianshu.io/upload_images/10950606-3777a92e356189a1.png?imageMogr2/auto-orient/strip|imageView2/2/w/301/format/webp)

图三



**4.策略模式**

策略模式:是指定义一系列的算法，把它们一个个封装起来，并且使它们可以互相替换。使得算法可以独立于使用它的客户而变化，也就是说这些算法所完成的功能是一样的，对外接口是一样的，只是各自现实上存在差异。

主要解决：在有多种算法相似的情况下，使用 if...else 所带来的复杂和难以维护。

何时使用：一个系统有许多许多类，而区分它们的只是他们直接的行为。

 如何解决：将这些算法封装成一个一个的类，任意地替换。

 关键代码：实现同一个接口。

 缺点： 1、策略类会增多。 2、所有策略类都需要对外暴露。

![img](https:////upload-images.jianshu.io/upload_images/10950606-99d75b3056d55b2b.png?imageMogr2/auto-orient/strip|imageView2/2/w/427/format/webp)

![img](https:////upload-images.jianshu.io/upload_images/10950606-31a7029675671b38.png?imageMogr2/auto-orient/strip|imageView2/2/w/375/format/webp)

![img](https:////upload-images.jianshu.io/upload_images/10950606-03b068e011e53b94.png?imageMogr2/auto-orient/strip|imageView2/2/w/333/format/webp)

![img](https:////upload-images.jianshu.io/upload_images/10950606-e77969c3e65ae6d2.png?imageMogr2/auto-orient/strip|imageView2/2/w/418/format/webp)

图四

**
**

**5.单例模式**

保证一个类仅有一个实例，并提供一个访问它的全局访问点。

主要解决：一个全局使用的类频繁地创建与销毁。

 何时使用：想控制实例数目，节省系统资源的时候。

如何解决：判断系统是否已存在单例，如果有则返回，没有则创建。

关键代码：构造函数是私有的。

单例大约有两种实现方法：懒汉与饿汉。

懒汉：故名思义，不到万不得已就不会去实例化类，也就是说在第一次用到类实例的时候才会去实例化，所以上边的经典方法被归为懒汉实现；

饿汉：饿了肯定要饥不择食。所以在单例类定义的时候就进行实例化。

特点与选择：

  由于要进行线程同步，所以在访问量比较大，或者可能访问的线程比较多时，采用饿汉实现，可以实现更好的性能。这是以空间换时间。

  在访问量较小时，采用懒汉实现。这是以时间换空间。

![img](https:////upload-images.jianshu.io/upload_images/10950606-ddfb1129c5318e62.png?imageMogr2/auto-orient/strip|imageView2/2/w/505/format/webp)

![img](https:////upload-images.jianshu.io/upload_images/10950606-cbac3e7a3fb3ae0e.png?imageMogr2/auto-orient/strip|imageView2/2/w/520/format/webp)

![img](https:////upload-images.jianshu.io/upload_images/10950606-58448e75523c9f52.png?imageMogr2/auto-orient/strip|imageView2/2/w/500/format/webp)

图5

**6.访问者模式**

适用于数据结构相对未定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由的演化。访问者模式使得增加新的操作变的很容易，就是增加一个新的访问者类。访问者模式将有关的行为集中到一个访问者对象中(做任何更改不需要修改基类，不依赖虚函数)

**7.观察者模式**

将复杂对象的构建和其表示分离，使得同样的构建过程可以创建不同的表示。

主要解决：一个复杂对象的创建工作，由各个部分的子对象用一定的算法构成；由于需求变化，这个复杂对象的各个部分经常面临变化，但将它们组合在一起的算法却相对稳定。

如何解决：将变与不变分开

 关键代码：建造者：创建和提供实例，Director：管理建造出来的实例的依赖关系。。

 缺点：1、产品必须有共同点，范围有限制。 2、如内部变化复杂，会有很多的建造类。

![img](https:////upload-images.jianshu.io/upload_images/10950606-63a2821349148f95.png?imageMogr2/auto-orient/strip|imageView2/2/w/489/format/webp)

![img](https:////upload-images.jianshu.io/upload_images/10950606-0f66705d14d57870.png?imageMogr2/auto-orient/strip|imageView2/2/w/492/format/webp)

![img](https:////upload-images.jianshu.io/upload_images/10950606-ce7308350ca11ab9.png?imageMogr2/auto-orient/strip|imageView2/2/w/491/format/webp)

![img](https:////upload-images.jianshu.io/upload_images/10950606-e5f04f9dee05ecf5.png?imageMogr2/auto-orient/strip|imageView2/2/w/488/format/webp)

图七

**8.建造者模式**

使得产品内部表象可以独立地变化，客户不必知道产品内部组成的细节。可以强制实行一种分步骤进行的建造过程。用一个接口完成不同的操作，需要对客户的需求进行把握。(如：登陆QQ，自动选择所在地的服务器)

**9.解释器模式**

给定一个语言后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。(如：360读取lua脚本，这个细节的实现就是解释器模式)

**10.命令模式**

把发出命令的责任和执行命令的责任分割开，委派给不同的对象允许请求的一方和发送的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否执行，何时被执行以及是怎么被执行的。(命令模式在客户端与服务器之间用的最多 (C/S架构))

**11.模板模式**

定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

主要解决：多个子类有相同的方法，并且逻辑相同，细节有差异。

如何解决：对重要，复杂的算法，将核心算法设计为模板方法，周边细节由子类实现，重构时，经常使用的方法，将相同的代码抽象到父类，通过钩子函数约束行为。

关键代码：在抽象类实现通用接口，细节变化在子类实现。

 缺点：每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。

![img](https:////upload-images.jianshu.io/upload_images/10950606-22cc98b54542c390.png?imageMogr2/auto-orient/strip|imageView2/2/w/523/format/webp)

![img](https:////upload-images.jianshu.io/upload_images/10950606-4d534d0d8606a602.png?imageMogr2/auto-orient/strip|imageView2/2/w/518/format/webp)

图11

**12.桥接模式**

将抽象化与实现化脱离，使得二者可以独立的变化，也就是指在一个软件系统的抽象化和实现化之间使用组合聚合关系而不是继承关系，从而使两者可以独立的变化。(相当于配电脑去装机，把各个模块组合到一起)

**13.适配器模式**

将一个类的接口转换成客户希望的另一个接口，使得原本由于接口不兼容而不能一起工作的哪些类可以一起工作。

主要解决：主要解决在软件系统中，常常要将一些"现存的对象"放到新的环境中，而新环境要求的接口是现对象不能满足的。

 何时使用： 1、系统需要使用现有的类，而此类的接口不符合系统的需要。 2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）

 如何解决：继承或依赖（推荐）。

 关键代码：适配器继承或依赖已有的对象，实现想要的目标接口。

缺点：1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。

![img](https:////upload-images.jianshu.io/upload_images/10950606-9e99f64c99c9a66a.png?imageMogr2/auto-orient/strip|imageView2/2/w/457/format/webp)

![img](https:////upload-images.jianshu.io/upload_images/10950606-1ba66c05d5b7bdcb.png?imageMogr2/auto-orient/strip|imageView2/2/w/425/format/webp)

![img](https:////upload-images.jianshu.io/upload_images/10950606-0dfc32ba0fcb0394.png?imageMogr2/auto-orient/strip|imageView2/2/w/486/format/webp)

![img](https:////upload-images.jianshu.io/upload_images/10950606-fa45af92d51a2675.png?imageMogr2/auto-orient/strip|imageView2/2/w/493/format/webp)

图13



**14.外观模式**

外部与一个子系统的通信必须通过一个统一的外观对象进行。每一个子系统只有一个外观类，而且此外观类只有一个实例，也就是说它是一个单例模式。但整个系统可以有多个外观类。(多个子系统方法都需要一个外观类统一管理，用统一的接口方便消费者使用)

**15.享元模式**

享元模式大幅度的降低内存中对象的数量，使用享元模式主要是为了优化内存，相同功能可以并行使用。

**16.原型模式**

用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

主要解决：在运行期建立和删除对象。

 何时使用：1).当我们的对象类型不是开始就能确定的，而这个类型是在运行期确定的话，那么我们通过这个类型的对象克隆出一个新的对象比较容易一些；2).有的时候，我们需要一个对象在某个状态下的副本，此时，我们使用原型模式是最好的选择；例如：一个对象，经过一段处理之后，其内部的状态发生了变化；这个时候，我们需要一个这个状态的副本，如果直接new一个新的对象的话,但是它的状态是不对的，此时，可以使用原型模式，将原来的对象拷贝一个出来，这个对象就和之前的对象是完全一致的了；3).当我们处理一些比较简单的对象时，并且对象之间的区别很小，可能就几个属性不同而已，那么就可以使用原型模式来完成，省去了创建对象时的麻烦了；4).有的时候，创建对象时，构造函数的参数很多，而自己又不完全的知道每个参数的意义，就可以使用原型模式来创建一个新的对象，不必去理会创建的过程。

 ->适当的时候考虑一下原型模式，能减少对应的工作量，减少程序的复杂度，提高效率

 如何解决：利用已有的一个原型对象，快速地生成和原型对象一样的实例。

 关键代码：拷贝，return new className(*this);

![img](https:////upload-images.jianshu.io/upload_images/10950606-1ada06c997198626.png?imageMogr2/auto-orient/strip|imageView2/2/w/517/format/webp)

![img](https:////upload-images.jianshu.io/upload_images/10950606-078d2e108ce99ef4.png?imageMogr2/auto-orient/strip|imageView2/2/w/523/format/webp)

图16





**17.责任链模式**

在责任链模式中，很多对象由每一个对象对其下家的引用而接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。处理者有两个选择：承担责任或者把责任推给下家。一个请求可以最终不被任何接收端对象所接受。(例如：晚上去上英语课，为了好开溜坐到了最后一排，哇，前面坐了好几个漂亮的MM哎，找张纸条，写上“Hi, 可以做我的女朋友吗？如果不愿意请向前传”，纸条就一个接一个的传上去了，糟糕，传到第一排的MM把纸条传给老师了)

**18.中介者模式**

中介者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用。从而使他们可以松散偶合。当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用。（如：TCP/IP打洞技术）

**19.装饰模式**

装饰模式以对客户端透明的方式扩展对象的功能是继承关系的一个替代方案，提供比继承更多的灵活性。动态给一个对象增加功能，这些功能可以再动态的撤消。增加由一些基本功能的排列组合而产生的非常大量的功能**。
**

**20.状态模式**

意图是让一个对象在其内部状态改变的时候，其行为也随之改变。状态模式需要对每一个系统可能取得的状态创立一个状态类的子类。当系统的状态变化时，系统便改变所选的子类。(如：到了晚上12点要睡觉，到了早上8点要起床...这就是状态)

**21.合成模式**

将对象组织到树结构中，可以用来描述整体与部分的关系。合成模式就是一个处理对象的树结构的模式。合成模式把部分与整体的关系用树结构表示出来。(用于树状结构)