# C++面试题

## 1.sizeof和strlen的区别

- sizeof是操作符、strlen是库函数
- 参数不同
  - sizeof参数可以是类型，也可以是常量，也可以是变量-
  - strlen参数只能是字符数组
- 计算时机不同
  - sizeof在编译时可计算
  - strlen运行时才能计算
- 数组做sizeof的参数不退化，传递给strlen就退化为指针了

## 2.C语言的static与C++的static有什么区别

- C中static可用于修饰局部静态变量和外部静态变量、函数
- C++中还可以用于定义静态成员变量和函数

## 3.C中的malloc与C++中的new有什么区别

- new、delete是操作符可以重载，只能在C++中使用；malloc、free是函数，可以被覆盖，可以在C、C++中使用
- malloc、free仅仅分配和释放内存；而new、delete不光可以分配和释放内存，还可以调用类的构造和析构函数
- new返回的是某种类型的指针，malloc返回的是void*指针，使用时需要强转

## 4.标准的宏MIN

```c++
#define MIN(a,b) ((a)<=(b)?(a):(b))
```

## 5.指针可以是volatile

- 任何变量都可以是volatile的

## 6.对于数组a，问a与&a的区别

- a是数组名，可作为数组的首地址
- &a是数组的指针

两者数值上是一样的，但作为指针表达的含义是不同的。**比如a的默认偏移量是单个元素的字节数，而&a的默认偏移量是整个数组**

## 7.C/C++的内存分配

（1）静态内存区（数据段）

​	全局变量、模块变量等

（2）栈区

​	局部变量，函数调用维护结构等

（3）堆区

​	new、malloc分配的内存区

## 8.strcpy、sprintf、memcpy的区别

（1）操作对象不同

- strcpy操作字符串
- sprintf操作源对象可以是多种数据类型，目的对象是字符串
- memcpy操作对象可以是内存地址，不局限于数据类型

（2）执行效率不同

​	memcpy > strcpy > sprintf

（3）功能不同

- strcpy —— 字符串拷贝
- sprintf —— 格式化字符串生成
- memcpy —— 内存块之间的拷贝

## 9.面向对象三大特征

- 封装、继承、多态

## 10.C++类默认实现的六个成员函数

**A()、A(const A&)、A&operator=(const A&)、~A()、A* operator&()、const A*operator&()const**

- （1）缺省构造函数、拷贝构造函数
- （2）析构函数
- （3）赋值运算符函数
- （4）取值运算符和取值运算符 const

## 11.对拷贝构造与赋值运算符的认识

（1）拷贝构造函数生成新的对象，而赋值运算符不能

当类中有指针引用类型成员变量时要注意重写拷贝构造函数和赋值运算符

## 12.写一个不能被继承的类

- （1）使用final，c++11的已经加入了final关键字，直接在类后面加上final关键字，就可以防止该类被继承
- （2）使用友元和模板
  - 将A的构造函数和析构函数都声明为private的，但是将B作为A的友元类，这样B就可以访问A的构造函数和析构函数了，此时B能正常构造；

```c++
template <typename T>
class A<T>{
    friend T;
    private:
    A(){}
    ~A(){}
};
class B:virtual public A<B>{	//虚继承
    public:
    B(){}
    ~B(){}
};	//B不能被继承
//类A的构造函数是私有的，只有A类的友元才能访问，
```

## 13.访问基类的私有虚函数

```C++
#include <iostream> 
class A { 
 	virtual void g() { cout << "A::g" << endl; } 
private: 
 	virtual void f() { cout << "A::f" << endl; } 
}; 
class B : public A { 
 	void g() { cout << "B::g" << endl; } 
 	virtual void h() { cout << "B::h" << endl; } 
}; 
typedef void( *Fun )( void ); 
void main() { 
 	B b; 
 	Fun pFun; 
 	for(int i = 0 ; i < 3; i++) 
 	{ 
 	 	pFun = ( Fun )*( ( int* ) * ( int* )( &b ) + i ); 
 	 	pFun(); 
 	} 	 
}
//输出结果，考察对虚函数表的理解
/*
B::g
A::f
B::h   */ 
```

## 14.简述成员函数的重写、重载和隐藏的区别

## 15.简述多态实现的原理

- 虚函数地址表

## 16.简述队列和栈的异同

## 17.两个栈实现一个队列

- 一个栈A作为队首，另一个栈B作为队尾。

入队时向B压入元素，出队时向若A非空，则从A出栈元素即可，若A栈为空，则将B栈中元素出栈依次压入栈A，B空后，再出栈A中的元素即可

## 18.计算一个二叉树的深度

## 19.编码实现直接插入排序

## 20.冒泡排序

## 21.选择排序

## 22.堆排序

## 23.基数排序

## 24.对编程规范的理解或认识

- 编程规范可总结为：程序的可行性、可读性、可以执行以及可测试性

## 25.&& 与 &、||和|的区别

## 26.C++的引用和C语言的指针有什么区别

- 引用必须初始化，但是不分配空间；指针需要分配储存空间
- 引用初始化后不可以改变，指针初始化后可以修改

## 27.在二叉树中找出和为某一值的所有路径

- 可以利用栈或者队列进行操作

## 28.typedef和#define的区别

（1）用法不同

- typedef用于定义一种数据类型的别名，增强程序的可读性
- define用于定义常量或者宏等

（2）执行时间不同

- typedef是编译的一部分
- define是预编译的一部分，发生在编译之前，不进行类型检查

（3）作用域不同

- typedef有作用域限定
- define不受作用域约束，只要在define语句之后就行

（4）对指针定义的不同

## 29.关键字const

- 修饰变量或者对象——只读
- 修饰函数参数、修饰成员函数

## 30.extern

- 声明外部变量、函数、引入不同语言编写的函数等等

## 31.流操作符重载为什么返回引用

- 程序中，流操作符经常连续使用，因此两个操作符的返回值应该仍旧支持两个操作符的流引用

## 32.指针常量与常量指针

int * const

const int *

## 33.数组名和指针的区别

- 数组名并不是真正意义上的指针，其内涵比指针丰富，但是当数组名作为参数传递给函数后，就会失去原本的含义，编程普通指针

(1)数组名的内涵在于其指代实体是一种**数据结构**，这种数据结构就是数组；不能自增自减。//************这才是实质

(2)数组名的外延在于其**可以转换为指向其指代实体的指针**，而且是一个指针常量；//********code

(3)指向数组的指针则是另外一种变量类型（在WIN32平台下，长度为4），仅仅意味着数组的存放地址！//********code

## 33.避免野指针

- 在适当的时候置空（定义时，指向的对象析构时等等）

## 34.常引用的作用

- 常用于函数的形参，表示只能传入常数，提高安全性

## 35.编码实现字符串转化为数字



## 36.编码实现某一位置零或者置1

- 使用位运算即可，按位与，按位或，按位异或，以及左移右移操作

## 37.中断函数

## 38.构造函数不能为虚函数、析构函数可以是虚函数

## 39.对面向对象的认识

- 传统的面向过程的程序多基于功能的角度来考虑和设计程序
- 面向对象则更宏观地看待问题，将问题进行总结归纳成多个类，然后分别设计每个对象，通过对象或者对象间的关系进行问题地处理或者。面向对象的设计方式更加符合社会实际，把自然属性引入了编程过程中，也提高了代码的健壮性、降低了代码的耦合性，提高了编程效率，易维护、易复用、易扩展。但性能比面向过程更差



## 自我介绍

​	面试官你好

姓名、就读于华中科技大学计算机学院。我有着有良好的学习能力与学习驱动力，很多新鲜的事物都能很快上手。有良好的动员和组织能力，曾担任班级团支书和社团部长，参与策划和举办过多场活动。具有很好的表达交流能力，曾在义务教育培训机构担任兼职教师，一度得到很高评价。有较强的团队合作意识和能力，在许多学校的课题项目中与同学组队完成课题，并常常成为团队主力。

**嵌入式**或跨平台开发  性能优化，算法优化

## 1.http与https有什么区别

- 明文与具有安全性的SSL加密传输协议，需要消耗更多的CPU和内存资源
- 端口不同，http-80，https-443
- https在TCP和HTTP之间加入了SSL/TLS安全协议，使密文能够加密传输

http 简单灵活易于扩展支持跨平台，但通信不安全，不验证对方身份，无法证明报文完整性

## 2.URI （Identifier）与URL（Location）

URI - 统一资源标识符，可以唯一标识一个资源

URL - 统一资源定位符，定位资源的路径



## linux下如何查看当前有多少个tcp连接

nestat -an

## TCP有11种状态

**closed，listen，syn_sent，established，fin_wait_1，fin_wait_2、TIME_WAIT、CLOSING、CLOSE_WAIT、LAST_ACK**

## TCP可以建立的连接数

取决于内存、CPU等、端口号资源、文件描述符资源、线程资源等情况，另外还有一些其他的限制，在linux系统中好像可以同通过命令查到：linux对可用端口的限制，文件描述符的最大数量等等

## 静态链表



# 二面准备

## 1.A函数调用了B函数，这时候在B中添加成员函数，问A需不需要重新编译？在C和C++ 中分别不需要重新编译。

在C中，不需要再次编译

C++中，也不需要再次编译

## 2.指针转参和引用传参的区别

- 指针传参本质上是传值，会在引用传参本质上是传址

- 程序在编译时分别将指针和引用添加到符号表上，符号表上记录的是变量名及变量所对应地址。指针变量在符号表上对应的地址值为**指针变量的地址值**，而引用在符号表上对应的地址值为**引用对象的地址值**。符号表生成后就不会再改，因此**指针可以改变其指向的对象**（指针变量中的值可以改），而**引用对象则不能修改**。
- 相同点
  - 都是地址概念，指针指向一块内存；因哟ing则是某块内存的别名
- 不同点
  - 指针是一个实体，引用是一个别名
  - 引用在定义时只能初始化一次，之后不可变，指针可变。引用不能为空
  - 引用是类型安全的，而指针不是

## 3.C++调用函数压栈模型

从下往上：现场，返回地址，参数压栈（从右往左）

## 4.浮点数不能直接比较问题

- 除了可以表示为2的幂次以及整数数乘的浮点数可以准确表示外，其余的数的值都是近似值。

- 所以对于两个浮点数a,b，如果要比较大小，那么常常会设置一个精度，如果fabs(a-b)<=1e-6，那么就是相等了。

- 判断小于的时候，就是if(a<b&&fabs(a-b)>1e-6)。

## 5.进程、线程区别

- **进程**：每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含1--n个线程。（进程是资源分配的最小单位）

  **线程：**同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小。（线程是cpu调度的最小单位）

## 6.STL底层实现

- vector 可变长数组
- list——双向链表
- deque —— 双端链表、数组块链表，索引数组
- set —— 红黑树
- map —— 红黑树
- hash_set —— hash表

## 7.C++关键字final

- 禁用继承
- 禁用重写

## 8.进程通信

- 匿名管道	—— 半双工通信方式
- 高级管道通信 —— 将另一个程序当做一个新的进程在当前程序进程中启动，则它算是当前程序的子进程，这种方式我们成为高级管道方式。
- 有名管道通信—— 半双工通信方式
- 消息队列通信 —— 消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
- 信号量通信 —— 互斥和同步
- 信号
- 共享内存
- 套接字（网络通信）

## 9.Linux进程间套接字通信

​	套接字通信允许互联的位于不同计算机上的进程之间实现通信功能。

## 10.进程调度算法有哪些

- 先来先服务调度算法
- 短作业优先
- 优先级调度（抢占式、非抢占式）
- 最高响应比优先（基于短作业优先算法，保证长作业等待较长时间后能够得到执行）
- 时间片轮转
- 多级反馈队列调度算法

## 11.什么是智能指针

​	智能指针主要用于**管理在堆上分配的内存**，它**将普通的指针封装为一个栈对象**。当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而**防止内存泄漏**。

- auto_ptr(C++11已弃用，存在潜在的内存崩溃问题！)

- unique_ptr

  - unique_ptr实现**独占式**拥有或严格拥有概念，保证同一时间内**只有一个智能指针可以指向该对象**。它对于避免资源泄露(例如“以new创建对象后因为发生异常而忘记调用delete”)特别有用。unique_ptr比auto_ptr更安全。
  - 另外unique_ptr还有更聪明的地方：当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个**临时右值**，编译器**允许**这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，

- shared_ptr

  shared_ptr实现**共享式**拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在**“最后一个引用被销毁”时候释放**。

  有一点share_ptr智能指针还是有内存泄露的情况，当两个对象相互使用一个shared_ptr成员变量指向对方，会造成**循环引用**，使引用**计数失效**，从而导致内存泄漏。

- weak_ptr

  weak_ptr 是一种不控制对象生命周期的智能指针, 它**指向一个 shared_ptr 管理的对象**. **进行该对象的内存管理的是那个强引用的shared_ptr**， weak_ptr只是**提供了对管理对象的一个访问手段**。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。**weak_ptr是用来解决shared_ptr相互引用时的死锁问题,如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0**,资源永远不会释放。它是**对对象的一种弱引用，不会增加对象的引用计数，**和shared_ptr之间可以相互转化，**shared_ptr可以直接赋值给它**，**它可以通过调用lock函数来获得shared_ptr**。

## 12.给定一棵树，求出这棵树的直径，即两个节点距离的最大值。

- **宽度优先搜索（可记录路径）**

  两次dfs或bfs。**第一次任意选一个点进行dfs(bfs)找到离它最远的点**，此点就是最长路的一个端点，**再以此点进行dfs（bfs）**，找到离它最远的点，此点就是最长路的另一个端点，**于是就找到了树的直径**。

- **动态规划（不可记录路径）**

dp[x]为以当前节点x为根的子树的直径

枚举每一个结点 x 以及 它要到达的下一个结点 Eiv。

树的直径 **ans_max = max{ d[ x ] + d[ Eiv ] + edge[x, Eiv] } （1 <= x <= N）**

那么 d[ x ] 通过什么更新呢？当然是由 它所连接下一个结点所能达到最大距离 来更新了；

即 **d[ x ] = max{ d[ x ], d[ Eiv ] + edge[ x, Eiv ] }；**



## 13.简述一下浅拷贝与深拷贝

浅拷贝是指 —— 对象的变量进行基于字面值的拷贝，而不考虑指针指向的内存的分配，

深拷贝是指—— 对值变量进行直接复制，对指针变量和引用变量等分配新的内存空间并拷贝一份数据

**浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。**

## 14.map和unordered_map的区别

- **map**内部是红黑树 
  - 元素有序
  - 占用空间更大
- **unordered_map**内部是哈希表 —— 适用于查找密集型
  - 元素无序
  - 查找速度快（较map）
  - hash表的建立比较费时间

## 15.epoll

- epoll是为**处理大批量句柄**而作了改进的poll, 是**性能最好的多路I/O就绪通知方法**;
- 三个系统调用**epoll_create, epoll_ctl, epoll_wait**;

- epoll 是在 select 出现 N 多年后才被发明的，是 select 和 poll（poll 和 select 基本一样，有少量改进）的增强版本。select 低效的原因之一是将“**维护等待队列**”和“**阻塞进程**”两个步骤合二为一。每次调用 select 都需要这两步操作，然而大多数应用场景中，需要监视的 socket 相对固定，并不需要每次都修改。epoll 将这两个操作分开，先用 epoll_ctl 维护等待队列，再调用 epoll_wait 阻塞进程。显而易见地，效率就能得到提升。

select流程：

