# 1.cast系列类型转换

## 1）static_cast 静态转换

- static_cast仅在编译时静态检查源类型能否转换为T类型，运行时不做动态类型检查，故不保证转换的安全性。

- static_cast不能将const或者volatile实体的指针转换为指向非const或volatile实体的指针，也不能将引用const或者volatile的值转换为非const或者volatile实体的值，换句话说**static_cast不能去除源类型的const、volatile**

- const<int> 转换的为右值

  const<int &>转换为左值，可赋值

```c++
const int a;	//用作右值时可以使用static_cast
int b = static_cast<int>(a);//用作右值，可以转换
static_cast<int &>(a) = 1;	//错误，不能去除const属性
static_cast<int>(a) = 1;	//错误，转换结果为右值，不能赋值
```



## 2）const_cast只读转换

- const_cast在原类型中去除或者添加const和volatile属性

```c++
const_cast<类型表达式> (数值表达式)
```

- 类型表达式不能包含储存位置修饰符：static、extern、auto、register等

- const_cast只能转换为指针、引用或指向对象的指针类型

```c++
```

## 3）dynamic_cast动态转换（运行时检查）

- dynamic_cast主要用于子类向父类转换，以及有虚函数的基类向派生类转换

```c++
dynamic_cast<T> (expr)
```

- 要求类型T是类的引用、类的指针或者void*，而expr的原类型必须是类的对象（常量或者变量：向引用类型转换）、父类或者子类的引用或指针
- dynamic_cast转换时可以添加const和volatile属性

## 4）reinterpret_cast重释转换

- reinterpret_cast用于将数值表达式转换成T类型的值
- reinterpret_cast用于名字到指针或引用类型的转换、有址引用与无址引用之间的相互zhuanhua你，以及指针与足够大的整数类型之间的相互转换。其中，指针是能够取得实际内存地址而不是偏移量的指针

## 5）typeid可用于获得类型标识符







# 2.move强转

- 同static_move



# 3.explicit要求显式调用



# 4.auto自动类型推导



# 5.Lambda表达式

- Lambda表达式用于定义匿名函数

```c++
[捕获列表] (形参列表) mutable 异常说明 -> 返回类型 {函数体}
```



# 6.模板与内存回收

- 变量模板使用类型形参定义的变量的类型，可根据类型实参生成变量模板的实例变量

```c++
//定义模板
template<class T>
template<typename T>
```

## 1）变量模板

