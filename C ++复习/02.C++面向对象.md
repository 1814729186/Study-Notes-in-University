# C++面向对象

## 1.类

- 关键字class、struct、union关键字都可以用于定义类，类用于描述对象的共同属性和方法
- **封装**用于定义对象的属性方法以及属性方法的访问权限，提高了代码的安全性，也使程序更易维护
- 类是一种数据结构，对象是类的实例

- **实例函数成员**——间接或直接通过对象调用的函数成员，实例函数成员中可访问隐含参数this
- 没有自己定义时，C++编译程序会为类生成默认的析构函数、构造函数和赋值运算函数。自动生成的类构造函数是无参的，不会初始化数据成员，仅保证类的正常运作，维护函数的多态性并进行最基本的初始化，**为维护多态或晚期绑定的必要的初始化**
- 构造函数是类封装的特殊的实例函数成员，用于对对象的数据成员进行初始化，为对象申请各种资源，对象必须且仅能初始化一次。



- 析构函数用于释放构造函数申请的各种资源：文件资源或设备资源等。**析构函数可以执行多次**，但应该避免多次执行

- 析构函数会按照构造过程的逆序对对象进行析构，析构函数无参，仅有一个隐含参数this
- 构造函数和析构函数一般定义为公开函数，但在某些工具函数中也可以定义为非公开（不需要构造对象）
- **函数绑定**——指为函数调用寻找入口并调用的过程
  - **早期绑定**——在程序代码运行之前完成绑定，通常由编译程序静态连接或者由操作系统自动完成。
  - **晚期绑定**——程序运行期间由程序自己根据调用对象的类型，寻找合适的多态函数入口地址并调用的过程。**完成晚期绑定过程的代码**由编译器预先插入程序中，早期绑定不需要编译程序完成绑定过程的代码

- 非成员函数不是任何类的函数，如main函数
- 构造函数只能被编译程序隐式调用（new关键字）或自动调用，析构函数可以被程序显式调用，也可以隐式或自动调用，一个对象生命期结束时，会自动调用析构函数。生命期为整个程序生命期的对象如全局变量，会在收工函数中调用其析构函数。其它函数成员只能够被隐式调用

- 对于未初始化的class，struct，union变量，若这些类没有基类和对象成员，也没有自定义构造函数、虚函数、纯虚函数，则可以对其使用{...}的列表形式进行初始化（为了兼容C）

- 可能出现程序异常退出导致析构函数未执行的情况，因此（1）正常使用return结束函数（2）使用异常处理机制处理异常

- exit()和abort()函数均能退出程序，但均属于非正常退出

  - exit()退出时还会执行收工函数，会析构全局对象
  - abort()退出时不会执行收工函数，不会析构全局对象
  - exit和abort均不会析构当前函数已经构造的局部对象

  正确使用的exit和abort的方式是：在使用exit退出程序前主动析构局部对象，在使用abort退出程序前主动析构全局对象和局部对象

- cpp文件也可以同h文件一样被#include，但是不提倡，因为可能被include多次
- 若显式调用析构函数后隐式析构函数正常执行，则可能出现反复析构的情况。为了防止反复析构，应该在析构后设置已经析构的标志，如指针的置空，在析构前判断是否为空
- **操作系统允许内存反复释放，但不允许文件和设备多次析构关闭**

```c++
struct STRING{
    char*s;
    STRING(const char*);
    ~STRING();
}
STRING::STRING(const char*s){
    this.s = (char*)malloc(sizeof(char)*(strlen(s)+1));
    strcpy(this.s,s);
}
STRING::~STRING(){
    if(0==s) return ;
    free(s);
    s=0;	//置空,析构标志
}
```

- 对象在其生命期结束时自动进行析构，且对象的自动析构顺序和其创建顺序相反
- **自动生成拷贝构造、移动构造及没有显式形参的构造函数的条件**——没有为类自定义任何构造函数，（+以下条件之一）：（1）该类自定义或者继承了虚函数或者纯虚函数，（2）定义了只读或者引用数据成员但没有指定默认值，（3）该类的对象成员或积累必须用实参调用构造函数初始化

- **自动生成析构函数条件**——该类没有定义析构函数（+以下之一）（1）该类的基类或者对象成员存在析构函数，（2）该类继承了或者自定义了虚函数或者纯虚函数

- delete可用于释放指针指向的内存外，还可用于删除编译能够生成的函数成员：如构造函数，析构函数和赋值运算函数

- 使用delete和default禁止自动生成相关函数和接受自动生成

```c++
struct {
    int x=0;
    A()=delete;	//禁止产生无参构造
    A(int m):x(m){}
    A(const A&a)=default;	//接受编译生成的浅拷贝构造函数A(const A &)，A没有指针成员，浅拷贝即可
}
int main(){
    A x(2);
    A y(x);	//浅拷贝构造
    //A z;报错，会调用A()构造函数
    A v();	//不报错，这里是说明了外部非成员函数，返回值为A ***
}
```

- 在类A没有自定义任何构造函数、析构函数、赋值运算函数的情况下，编译程序会自动为类生成6个成员函数：
  - **A()、A(const A&)、A(A &&)、A&operator=(const A&)、A&operator=(A &&)、~A()**



## 2.成员访问权限及突破方法

访问权限：**private、protected、public**

- class定义的类默认为private，struct或union定义的类默认为public（可更改）

**友元函数**

- 不管什么访问权限的成员都可以被该类的友元函数访问
- 对类的成员的访问主要包括：
  - （1）类型成员的使用
  - （2）数据成员的取值、赋值、取地址以及取内容等
  - （3）函数成员的调用以及取函数成员的入口地址等（构造函数不能显式调用，不能获取构造函数的入口地址）

---

构造函数也能被定义为private或者protected权限，即使是private类型，也能在友元函数中进行对象的构造

- C++的封装能够阻止无意识的越权访问但不能阻止有意识地越权访问，C++的强行转换可以做到这一点（特洛伊木马方式：用于原类结构相同的类型将现有类进行强转，而原本的private成员设置为public）

```C++
class USER{
    char passwd[10];
   public:
   	char name[10];
    USER(const char*user);
}
//定义另一个类，结构与USER相似
struct TROJAN_HORSE{
    char passwd[10],name[10];
}
void main(){
    USER w("Wang");
    for(int i = 0;i < 10;i ++){
        cout << ((TORJAN_HORES*)&w)->passwd[i];	//输出密码信息
    }
}
```

## 3.内联、匿名类及位段

- 类体内定义了函数体的任何函数成员都会自动成为内联函数。类体外使用inline关键字也可以定义内联函数。内联函数通常是函数体较小的函数，不满足条件的内联函数会内联失败
- 在调用内联函数前，若内联函数仅完成声明，还没有定义，则会内联失败
- 若定义了一个带有默认参数值的构造函数，则会形成多个不同参数的构造函数

---

**匿名类**

- 没有类名，不可以定义构造、析构函数（自动生成无参构造），函数成员不可以在类体外定义(默认为内联)

- 若使用struct定义类，且满足前面提到的条件，则会自动生成构造函数，否则不会（兼容C）；若函数成员定义了虚函数，则自动内联会失败

---

**无对象的匿名联合**

- 对于无对象的匿名联合，C++完全兼容C语言定义及其用法，没有进行扩展
- 无对象匿名联合具有如下特点：
  - （1）必须定义储存位置特性static
  - （2）只能定义公开实例数据成员
  - （3）其实例数据成员和联合本身的作用域相同
  - （4）所有的实例数据成员共享储存空间

**

---

**局部类**

- 类体或函数体中定义的类

- 局部类的函数成员只能在类体中定义函数体，成为内联函数，内联可能失败



## 4.new 和delete运算符

new —— 分配内存，调用构造函数构造对象

delete —— 调用析构函数析构对象，释放内存

- 编译器不会自动调用new产生的对象的析构函数，必须由程序员使用delete进行析构
- **delete[]** 可用于析构数组中的所有对象，并释放对象数组所占用的内存，即使是单个对象，创建时可使用[1]表示分配长度为1的数组，之后也可以使用delete[]进行析构

**

## 5.隐含参数this

- 类的实例数据成员比静态数据成员多了一个隐含参数this，this是实例函数成员的第一个参数，其类型与实例函数成员参数表后的修饰符有关，一般为指向此类的const指针。
- 析构函数或者构造函数的隐含参数类型之恩那个为C*const而不能是 const C const *或者 volatile C * const等。析构函数的参数列表只能为空，析构函数不可能有重载函数
- 隐含参数this是一个只读指针，不能修改



## 6.对象的构造与析构

- 若类A的成员中含有B类的实例数据成员，则若未定义构造函数，Ａ()会默认调用B的无参构造，若B没有午餐构造，则会报错
- 构造函数必须在其参数列表和":"之后（构造函数初始化位置）调用其基类或者虚基类的构造函数，初始化其只读和引用类型的示例数据成员，以及初始化类型为类的实例数据成员。
- 在构造函数中，应该按照顺序：虚基类、基类、实例数据成员进行初始化

- 实例数据成员可以定义为默认值，在构造函数中没有对其进行初始化时，会使用默认值对其进行初始化
-  若示例数据成员全为公开成员且没有定义构造函数，则可以使用{...}进行初始化（兼容C）



# 成员及成员指针

## 1.实例成员指针

- 实例成员指针是一种新的数据类型，指向实例成员，包含**实例数据成员指针**和实**例函数成员指针**

实例成员指针要和对象一起使用

- 实例数据成员的类型 **类型名::***

可在公开成员函数中，在满足一定条件的前提下返回非公开实例成员的地址，这样就可以通过实例成员指针访问非公开实例成员。

- 实例成员指针实质上是一个偏移量，使用实例成员指针访问成员时仍旧需要借助类对象

  **对象名 -> 实例成员指针**

- 实例成员指针不能移动（可能越权访问）也强制转换成其他类型（否则可能间接移动指针）



## 2.const、volatile和mutable

- 类的const成员必须在构造函数的初始化位置对其进行初始化

- 使用const修饰this参数时，表示不能修改this指向的对象的所有实例数据成员，但可以修改静态数据成员。volatile修饰this参数时，说明对象的每一个成员都出于易变状态，禁止对该对象的所有数据成员的访问进行优化
- 对this的修饰符不同，也能视为重载的不同函数。使用const修饰的函数也能被非const的对象调用（相容原则），但会优先调用更合适的函数成员实例函数成员
- 构造函数和虚构函数的this指针不能被const或者volatile修饰。（构造或者析构时，对象必须是可以被修改的、稳定的）

---

**mutable**

- mutable**只用于修饰实例数据成员**，提供了示例数据成员可被修改的机动能力。
- 对于只读对象的mutable是可以修改的（**可被修改的机动能力**）

## 3.静态数据成员

- 静态数据成员在物理上独立于对象分配内存，被类的所有对象共享，sizeof关键字计算的尺寸不包括静态数据成员
  - 局部类——作用域局限于函数中的类，其中不能定义静态数据成员，否则会造成静态数据成员的生存矛盾
  - 嵌套类——作用域局限于类体中的类

- 静态数据成员不可定义为位段类型（位段成员没有地址，无法独立分配内存，而静态数据成员需要在对象外独立分配内存）
- 静态数据成员在类体中仅仅是说明，因此可以include多次。在类体外定义静态数据成员时，只能在某个cpp代码中定义一次（定义时不需要再加static进行再次说明），非静态数据成员不能在外部进行定义

## 4.静态函数成员

- 构造函数、析构函数、虚函数、纯虚函数等函数不能定义为静态函数成员
- 静态函数成员没有this指针
- 局部类不能定义静态数据成员，但可以定义静态函数成员，必须在类体内定义，为inline函数

## 5.静态成员指针

- 普通类型的指针即可指向静态成员，即int*可指向static int类型的静态数据成员，int ( * )()类型的函数指针可以指向如static int A::f()的静态函数成员
- **成员指针也可以作为类的成员**

**



# 继承与构造

## 1.单继承

- 派生类可以做到
  - （1）增加新成员
  - （2）改变积累成员继承后的访问权限
  - （3）重新定义和基类成员同名的成员

- 联合不能继承和被继承
- 使用class声明的派生类——继承方式默认为private，进入类体的访问权限默认为private
- 使用struct声明的派生类——继承方式默认为public，进入类体的访问权限默认为public

## 2.继承方式

- 继承方式分为—— **private、protected、public**

- 派生类中基类成员的访问权限如同两张过滤网一般

  **基类成员权限 = min{继承方式,基类成员原访问权限}**	private < protected < public

  - 若派生类被定义为基类的友元函数，则基类的私有成员也能被派生类访问并作为private成员

- 派生类可以访问基类中除private之外的所有成员



- 派生类的构造函数必须调用基类构造函数，（默认隐式调用无参构造）

- 基类成员继承到派生类后访问权限可以修改：（能被继承的成员才能修改权限，private成员不能被继承）

  - （1）将基类成员直接放在想要的访问权限位置	格式：**基类名 :: 成员名**

  - （2）在适当访问权限位置使用using将成员放在派生类中希望的访问权限范围：格式： **using 基类名 :: 成员名**

    若同一基类成员在派生类中说明了多次（可多次说明），则以第一次说明为准

- 派生类可定义与基类成员同名的成员，此时直接访问则会默认访问派生类的成员，可使用限定符 **基类类名 :: 成员名** 进行访问

## 3.构造与析构

派生类的构造顺序：

​	（1）调用虚基类的构造函数

​	（2）调用直接基类的构造函数

​	（3）按照派生类的数据成员的声明一次调用他们的构造函数或者对其进行初始化

​	（4）最后执行派生类构造函数的函数体



## 4.父类和子类

- 使用父类定义变量或者指针，则在编译时只检查他们访问父类成员的权限，因此即使父类指针实际指向了子类对象，早期绑定也只能调用父类函数成员，除非将父类函数成员定义为虚函数进行晚期绑定，否则子类对象就会不合理地调用父类函数成员。

- 派生类以public方式继承基类，则满足父子关系

---

- 父类的指针可以指向子类成员，但此时若使用指针或引用调用同名函数，则会默认调用父类的函数（静态语法检查）
- 如果基类和派生类没有构成父子关系且非成员函数main不是派生类的友元函数，则main定义的基类指针不能指向派生类对象，（强转后可以）
- 编译程序只能假定父类引用变量引用的都是父类对象

---

- 在作为派生类友元的main函数中，基类和派生类默认满足父子关系
  - 基类对象被继承到派生类后，**可被视为匿名的具有某种访问权限的对象成员**。main函数作为友元函数，与派生类具有相同的访问权限（无障碍访问），就像基类以公开方式继承到派生类，使基类可被派生类当作父类看待
- **基类对象可被视为派生类的匿名成员**

---

- **派生类占用的内存 = 基类对象占用的内存 + 派生类实例数据成员占用的内存**
- 静态数据成员在对象外分配内存

# 作用域

- 作用域运算符 **::** 即是单目又是多目

  单目：用于限定函数外的类型名、变量名及函数名等（如函数内访问与局部变量同名的函数外静态变量，类的成员调用同名的非函数成员时也会用到）

  多目：用于限定枚举元素、名字空间成员、类的数据函数成员以及类型成员等，还可以用于修改基类成员继承到派生类后的访问权限

## 1.面向对象的作用域

- 面向对象的作用域，此法单位的作用范围可分为五级
  - （1）常量作用于表达式内
  - （2）局部变量和函数形参作用于函数成员内
  - （3）数据成员或函数成员作用于类或派生类内
  - （4）数据成员或函数成员作用于基类
  - （5）数据成员或函数成员作用于虚基类



## 2.面向过程的作用域

- 面向过程的作用域即传统的C语言作用域
  - （1）常量作用于表达式内
  - （2）局部变量和函数形参作用于函数内
  - （3）模块变量和静态函数作用于代码文件内
  - （4）全局变量和全局函数作用于整个程序

- 面向对象的作用域属于面向过程的作用域

## 3.名字空间namespace

- 名字空间使用namespace进行定义即可

- 使用名字空间时使用using即可
- 可直接using名称空间的某个特定成员，这时候就不能在当前名称空间定义同名的成员了。若只是using了名称空间，则可以定义同名成员。main只能定义在默认的名称空间中，否者会发生连接错误。main函数只能为全局作用域

- cpp内可以定义匿名名称空间，匿名名称空间的成员只在当前cpp中具有访问权限，cpp中也可以定义同名的成员，此时可使用 **::成员名** 访问匿名空间的成员

- 名字空间可以多层嵌套定义

## 4.友元

- 非成员函数定义为类的友元时，可以在类中同时定义该友元的函数体，此时为inline函数。其作用域为当前代码文件
- 若希望友元具有局部作用域，则需要加上inline或者static进行修饰

- 成员友元 —— 某个类的成员函数作为友元
- 普通友元 —— 非成员函数作为友元

## 5.覆盖与隐藏

**隐藏**——指的是当基类成员和派生类成员同名时，通过派生类对象只能访问到派生类成员，而无法访问到其基类的同名成员，则称派生类成员隐藏了同名的基类成员

**覆盖**——派生类对象还能访问到基类的同名成员，则成派生类成员覆盖了基类成员

- 突破覆盖的方法： **派生类对象.基类名称::基类成员**

- 覆盖和隐藏是相对的

---

# 多态与虚函数

- 虚函数用于实现多态特性

- 虚函数是用关键字virtual定义的函数，通常只需要在基类中定义虚函数，派生类中的原型“相容”的实例函数成员将自动成为虚函数，不管进行了多少级派生，虚函数的性质会一直传递下去。派生类中的覆盖函数可以与基类虚函数的访问权限不相同
- “相容”：
  - （1）实例函数和基类虚函数同名，且显式参数列表相同
  - （2）基类虚函数的返回类型是基类指针p或引用r，则派生类的实例函数的返回类型必须是**可向p或者r赋值的基类指针引用**或者**派生类指针引用**或者**相同**。

- 虚函具有隐含参数this，不能定义为静态函数成员，构造函数不能定义为虚函数或者纯虚函数。析构函数可定义为虚函数，在析构对象时可找到对象实际对应的析构函数进行正确地析构
- **虚函数的多态特性**——根据对象的真实类型不同而调用不同的实例函数

- 引用类型的变量会被编译为指针，因此通过父类引用变量调用虚函数同指针一样表现出多态特性
- 不能用virtual定义friend函数，virtual只能定义当前类的成员函数
- 虚函数不能定义为constexpr函数，不能接受inline优化而丧失虚函数入口，虚函数入口用于填写虚**函数入口地址表**，该地址表的首址将成为**对象存储的一个内部指针**
- constexpr函数(constexpr function)是指能用于常量表达式的函数。定义constexpr函数的方法与其他函数类似，不过要遵循几项约定：函数的返回类型及所有形参的类型都得是字面值类型，而且**函数体中必须有且只有一条return语句**：

## 1.虚函数的重载及内联

- 虚函数可以声明为inline函数，也可以重载

- 虚析构函数可以根据对象类型进行多态析构
- 虚函数能根据对象的类型适当地绑定到实函数（晚期绑定），除了构造函数不能定义为虚函数外，最好能将所有实例函数成员定义为虚函数。虚函数主要通过对象类型不同来表现出多态性
- union不能作为基类，不能定义派生类，其中不能定义虚函数

## 2.虚析构函数

- delete完成的工作：
  - （1）调用析构函数析构对象的指针、引用类型的实例函数成员引用的结构
  - （2）释放对象

- 仅仅用析构函数不能完成（2）

## 3.类的引用

- new的对象才需要进行析构
- **



# 抽象类

- 纯虚函数函数体定义为 =0

```c++
virtual int func()=0;	//纯虚函数
```



- 构造函数不能定义为纯虚函数，静态函数成员不能定义为纯虚函数，析构函数能够定义为纯虚函数

含有纯虚函数的类称为**抽象类**，抽象类常常用于派生类的基类

抽象类的派生类要么实现基类的所有纯虚函数，要么也自动成为抽象类。派生类也可以定义新的纯虚函数，这样其也会转化为抽象类

- **抽象类不可以构造对象**

malloc可为抽象类对象分配空间，但不会调用抽象类的构造函数来初始化对象

- 抽象类作为抽象级别最高的类，主要用于定义子类共有的数据成员和函数成员

## 1.虚函数友元与晚期绑定

- 友元关系不能传递或者继承，即若f()为类A的友元，B继承于A，则f()并不能作为B的友元，除非再次在B中定义友元f()。同样的，虚函数作为友元，覆盖它的成员函数也没有友元特性

- **晚期绑定**

  - 对象在构造之前（执行基类构造函数之后，执行当前类构造函数之前，同样的在执行基类构造函数之前，**VFT指针**会指向基类的虚函数地址表），会将虚函数地址表的首址储存到对象的VFT首地址指针中，之后的调用就会晚期绑定对应于对象类型的函数成员（通常VTF首地址放在对象的起始单元），VTF指针通常在一个对象中最多只有一个，被对象的所有部分共享

  - 析构时与上述过程相反，先执行派生类的析构函数之后，VFT会指向基类的虚函数地址表，然后调用基类的析构函数逐层析构

  - 只有定义了虚函数的类构造出的部分才具有VTF指针：例如C继承于B，B继承于A，B中定义了虚函数，则创建的C对象中，分为从B继承的部分和自己的部分，其中B的部分中含有VTF指针，另有从A继承的部分。


　# 多继承与虚基类

# 1.多继承类

对象聚合能够在单继承的语言中满足一定需求，但当对象成员和基类的类型相同或者在逻辑上和基类对象存在共享的内存时，就可能对同一屋里对象重复初始化

- 多继承可能带来许多不得不同名的直接基类的问题，这时候可能引入重名成员，这时候需要活用作用域运算符和访问优先级来确定访问的成员

## 2.虚基类

- 将基类说明为虚基类，就能保证虚基类在类的整个构造树中**只初始化一次**。若A多继承B和C，同时C继承B。则可令A，C分别虚继承B，这样在创建A的对象时，就只会初始化一次B，且A中的B和C中的B共享同一块物理空间

```c++
class A : virtual public B,C{
    ...
}
```

- 虚基类的构造优先级高于普通基类，析构优先级低于普通基类
- **只有同名虚基类才能共享内存**，同名基类不会共享内存，当出现基类和虚基类同名时，必然导致二义性访问，编译程序会对二义性访问提出警告，此时要么将基类说明为对象成员，要么将基类说明为虚基类。（使用类名限定可以解决二义性访问的问题）

**多继承时的构造与析构**

​	（1）按照定义顺序自左至右，自下而上构造所碰到的**虚基类**

​	（2）按照定义顺序构造派生类的所有**直接基类**（递归过程）

​	（3）按照定义顺序构造或者初始化所有**实例数据成员**，包括对象成员、const成员和引用成员等

​	（4）执行派生类**自己的构造函数**函数体

同名的虚基类在同一颗派生树中仅构造一次

- 析构的过程是构造的逆序

**虚基类内存**

- 虚基类的内存建于派生类的尾部，按照定义顺序建立，同名虚基类仅建立一次

---

- 多继承的类产生的对象可能有多个虚函数入口地址表指针



# 异常与断言

- try...catch...语句块可以完成异常的处理操作，C++的异常处理没有finally部分，但是microsoft对C++进行扩展，添加了finally部分
- throw可用于抛出**异常对象**（软件引发），异常对象用于描述异常，抛出的对象可以为一般的对象
- try后可接多个catch语句块，捕获顺序应从小到大，优先使用子类的子类类型的指针捕获异常。父类指针可以指向子类对象。可用于捕获任何异常的指针：**const volatile void ***。或者使用“**...**”捕获所有异常

```C++
try {
        ; // throw something
    }
    catch(...)
    {
        std::exception_ptr p = std::current_exception();
        std::clog <<(p ? p.__cxa_exception_type()->name() :"null") << std::endl;
    }
```

- 引发异常后需要进行处理，一般会在函数中查找处理流程，未找到则会向调用者层层传递，如果main函数也没有处理异常，则由C++的监控系统处理该异常，监控系统通常会终止该程序
- try中触发throw后，紧接在其后的语句都会被跳过，转而执行匹配类型的catch中的语句。catch接收参数作为捕获的对象的类型，不可以定义void作为参数类型，但可以定义const void*
- catch语句块中可以使用无参数的throw语句，表示将当前捕获的异常对象向外层调用者函数抛出
- catch不能捕获&&类型的无址引用异常，因为catch链是一个由内层作用域向外层作用域传播的过程，若再内层作用域生成常量对象，则会再作用域退出时自动析构

## 1.函数的异常接口

异常接口声明，声明一个函数会抛出某种类型的异常（不声明也可以，声明只是为了提醒编译器检查是否处理异常）

```c++
void func(void) throw(A,B,C);	//声明会抛出A、B、C或者其子类的异常对象
void func(void)const throw(A,B);
void func1(void)noexcept;	//不引发任何异常
void func2(void)throw();	//不引发任何异常
void func3(void)throw(void);//不引发任何异常
```

- 声明抛出的类型时可以多种多样的，甚至可以是数组或者指针
- 关键字noexcept用于说明函数不会引发任何异常，也可以用throw()代替（括号中不写任何类型或写void）
  - noexcept、const、volatile接在参数表后面
  - noexcept关键字给编译编译长须留有很大的优化空间，鼓励使用noexcept关键字定义移动构造函数和析构函数
  - constexpr修饰的函数不应该抛出任何异常，否则编译不能优化该函数的函数体，从而无法生成常量表达式
  - **constexpr函数**是指能用于常量表达式的函数。该函数要遵循几项约定：函数的返回类型及所有形参的类型都得是字面值类型，而且函数体中必须有且只有一条return语句：
  - noexcept不能作为函数重载的标志
- 抛出异常之前，应该对new的对象执行析构函数，防止内存泄漏。局部对象会自动析构

---

## 2.assert断言

- 断言assert用于调试程序，当predicate为假时，会输出断言表达式和行号，并执行abort()退出

```c++
assert(int predicate);
```

- assert语句是被编译程序固化的，完成编译后，不管可执行文件改名成什么，无论移植到什么机器上，输出的信息都会和原本的一样

```()c++
static_assert(int && predicate)
```

- static_assert是一个保留字，只能使用常量表达式作为实参
  - static_assert与assert断言的检查时间不同，static_assert在编译时检查，assert在运行时检查
- assert断言只能用于调式程序，不能用作程序的错误处理，在使用“#define NDEBUG”后，其后的断言将当作注释处理；再使用"#undef NDEBUG"后，后面的才能再编译成可执行代码。（默认定义为#undef NDEBUG）

# 运算符重载

- 除‘sizeof’、‘.’ 、‘ :: ’和三目运算符‘ ? :  ’运算符之外的所有运算符都可以重载

---

”=“，”->“，”( )“，”[ ]“只能重载为实例数据成员

new，delete只能重载为静态函数成员或非成员函数

其他操作符只能重载为实例函数成员或非成员函数

| 运算符         | 实例函数成员 | 静态函数成员 | 非成员函数 |
| -------------- | ------------ | ------------ | ---------- |
| **= -> () []** | **√**        |              |            |
| **new delete** |              | **√**        | **√**      |
| **其他**       | **√**        |              | **√**      |

- 对于++，--的重载（非成员函数）

```c++
INT &operator --(INT &){ } //一个参数，表示前置运算--的重载
INT &operator-- (INT&,int){} //两个参数，表示后置--的重载，后面的参数没有实际意义
```

- 对于++，--的重载（成员函数）（成员函数包含默认参数this）

```c++
INT &operator --(){ } //一个参数this，表示前置运算--的重载
INT &operator-- (int){} //两个参数，表示后置--的重载，后面的参数没有实际意义
```

## 1.重载->运算符

