# C++面向对象

## 1.类

- 关键字class、struct、union关键字都可以用于定义类，类用于描述对象的共同属性和方法
- **封装**用于定义对象的属性方法以及属性方法的访问权限，提高了代码的安全性，也使程序更易维护
- 类是一种数据结构，对象是类的实例

- **实例函数成员**——间接或直接通过对象调用的函数成员，实例函数成员中可访问隐含参数this
- 没有自己定义时，C++编译程序会为类生成默认的析构函数、构造函数和赋值运算函数。自动生成的类构造函数是无参的，不会初始化数据成员，仅保证类的正常运作，维护函数的多态性并进行最基本的初始化，**为维护多态或晚期绑定的必要的初始化**
- 构造函数是类封装的特殊的实例函数成员，用于对对象的数据成员进行初始化，为对象申请各种资源，对象必须且仅能初始化一次。



- 析构函数用于释放构造函数申请的各种资源：文件资源或设备资源等。**析构函数可以执行多次**，但应该避免多次执行

- 析构函数会按照构造过程的逆序对对象进行析构，析构函数无参，仅有一个隐含参数this
- 构造函数和析构函数一般定义为公开函数，但在某些工具函数中也可以定义为非公开（不需要构造对象）
- **函数绑定**——指为函数调用寻找入口并调用的过程
  - **早期绑定**——在程序代码运行之前完成绑定，通常由编译程序静态连接或者由操作系统自动完成。
  - **晚期绑定**——程序运行期间由程序自己根据调用对象的类型，寻找合适的多态函数入口地址并调用的过程。**完成晚期绑定过程的代码**由编译器预先插入程序中，早期绑定不需要编译程序完成绑定过程的代码

- 非成员函数不是任何类的函数，如main函数
- 构造函数只能被编译程序隐式调用（new关键字）或自动调用，析构函数可以被程序显式调用，也可以隐式或自动调用，一个对象生命期结束时，会自动调用析构函数。生命期为整个程序生命期的对象如全局变量，会在收工函数中调用其析构函数。其它函数成员只能够被隐式调用

- 对于未初始化的class，struct，union变量，若这些类没有基类和对象成员，也没有自定义构造函数、虚函数、纯虚函数，则可以对其使用{...}的列表形式进行初始化（为了兼容C）

- 可能出现程序异常退出导致析构函数未执行的情况，因此（1）正常使用return结束函数（2）使用异常处理机制处理异常

- exit()和abort()函数均能退出程序，但均属于非正常退出

  - exit()退出时还会执行收工函数，会析构全局对象
  - abort()退出时不会执行收工函数，不会析构全局对象
  - exit和abort均不会析构当前函数已经构造的局部对象

  正确使用的exit和abort的方式是：在使用exit退出程序前主动析构局部对象，在使用abort退出程序前主动析构全局对象和局部对象

- cpp文件也可以同h文件一样被#include，但是不提倡，因为可能被include多次
- 若显式调用析构函数后隐式析构函数正常执行，则可能出现反复析构的情况。为了防止反复析构，应该在析构后设置已经析构的标志，如指针的置空，在析构前判断是否为空
- **操作系统允许内存反复释放，但不允许文件和设备多次析构关闭**

```c++
struct STRING{
    char*s;
    STRING(const char*);
    ~STRING();
}
STRING::STRING(const char*s){
    this.s = (char*)malloc(sizeof(char)*(strlen(s)+1));
    strcpy(this.s,s);
}
STRING::~STRING(){
    if(0==s) return ;
    free(s);
    s=0;	//置空,析构标志
}
```

- 对象在其生命期结束时自动进行析构，且对象的自动析构顺序和其创建顺序相反
- **自动生成拷贝构造、移动构造及没有显式形参的构造函数的条件**——没有为类自定义任何构造函数，（+以下条件之一）：（1）该类自定义或者继承了虚函数或者纯虚函数，（2）定义了只读或者引用数据成员但没有指定默认值，（3）该类的对象成员或积累必须用实参调用构造函数初始化

- **自动生成析构函数条件**——该类没有定义析构函数（+以下之一）（1）该类的基类或者对象成员存在析构函数，（2）该类继承了或者自定义了虚函数或者纯虚函数

- delete可用于释放指针指向的内存外，还可用于删除编译能够生成的函数成员：如构造函数，析构函数和赋值运算函数

- 使用delete和default禁止自动生成相关函数和接受自动生成

```c++
struct {
    int x=0;
    A()=delete;	//禁止产生无参构造
    A(int m):x(m){}
    A(const A&a)=default;	//接受编译生成的浅拷贝构造函数A(const A &)，A没有指针成员，浅拷贝即可
}
int main(){
    A x(2);
    A y(x);	//浅拷贝构造
    //A z;报错，会调用A()构造函数
    A v();	//不报错，这里是说明了外部非成员函数，返回值为A ***
}
```

- 在类A没有自定义任何构造函数、析构函数、赋值运算函数的情况下，编译程序会自动为类生成6个成员函数：
  - **A()、A(const A&)、A(A &&)、A&operator=(const A&)、A&operator=(A &&)、~A()**



## 2.成员访问权限及突破方法

访问权限：**private、protected、public**

- class定义的类默认为private，struct或union定义的类默认为public（可更改）

**友元函数**

- 不管什么访问权限的成员都可以被该类的友元函数访问
- 对类的成员的访问主要包括：
  - （1）类型成员的使用
  - （2）数据成员的取值、赋值、取地址以及取内容等
  - （3）函数成员的调用以及取函数成员的入口地址等（构造函数不能显式调用，不能获取构造函数的入口地址）

---

构造函数也能被定义为private或者protected权限，即使是private类型，也能在友元函数中进行对象的构造

- C++的封装能够阻止无意识的越权访问但不能阻止有意识地越权访问，C++的强行转换可以做到这一点（特洛伊木马方式：用于原类结构相同的类型将现有类进行强转，而原本的private成员设置为public）

```C++
class USER{
    char passwd[10];
   public:
   	char name[10];
    USER(const char*user);
}
//定义另一个类，结构与USER相似
struct TROJAN_HORSE{
    char passwd[10],name[10];
}
void main(){
    USER w("Wang");
    for(int i = 0;i < 10;i ++){
        cout << ((TORJAN_HORES*)&w)->passwd[i];	//输出密码信息
    }
}
```

## 3.内联、匿名类及位段

- 类体内定义了函数体的任何函数成员都会自动成为内联函数。类体外使用inline关键字也可以定义内联函数。内联函数通常是函数体较小的函数，不满足条件的内联函数会内联失败
- 在调用内联函数前，若内联函数仅完成声明，还没有定义，则会内联失败
- 若定义了一个带有默认参数值的构造函数，则会形成多个不同参数的构造函数

---

**匿名类**

- 没有类名，不可以定义构造、析构函数（自动生成无参构造），函数成员不可以在类体外定义(默认为内联)

- 若使用struct定义类，且满足前面提到的条件，则会自动生成构造函数，否则不会（兼容C）；若函数成员定义了虚函数，则自动内联会失败

---

**无对象的匿名联合**

- 对于无对象的匿名联合，C++完全兼容C语言定义及其用法，没有进行扩展
- 无对象匿名联合具有如下特点：
  - （1）必须定义储存位置特性static
  - （2）只能定义公开实例数据成员
  - （3）其实例数据成员和联合本身的作用域相同
  - （4）所有的实例数据成员共享储存空间

**

---

**局部类**

- 类体或函数体中定义的类

- 局部类的函数成员只能在类体中定义函数体，成为内联函数，内联可能失败



## 4.new 和delete运算符

new —— 分配内存，调用构造函数构造对象

delete —— 调用析构函数析构对象，释放内存

- 编译器不会自动调用new产生的对象的析构函数，必须由程序员使用delete进行析构
- **delete[]** 可用于析构数组中的所有对象，并释放对象数组所占用的内存，即使是单个对象，创建时可使用[1]表示分配长度为1的数组，之后也可以使用delete[]进行析构

**

## 5.隐含参数this

- 类的实例数据成员比静态数据成员多了一个隐含参数this，this是实例函数成员的第一个参数，其类型与实例函数成员参数表后的修饰符有关，一般为指向此类的const指针。
- 析构函数或者构造函数的隐含参数类型之恩那个为C*const而不能是 const C const *或者 volatile C * const等。析构函数的参数列表只能为空，析构函数不可能有重载函数
- 隐含参数this是一个只读指针，不能修改



## 6.对象的构造与析构

- 若类A的成员中含有B类的实例数据成员，则若未定义构造函数，Ａ()会默认调用B的无参构造，若B没有午餐构造，则会报错
- 构造函数必须在其参数列表和":"之后（构造函数初始化位置）调用其基类或者虚基类的构造函数，初始化其只读和引用类型的示例数据成员，以及初始化类型为类的实例数据成员。
- 在构造函数中，应该按照顺序：虚基类、基类、实例数据成员进行初始化

- 实例数据成员可以定义为默认值，在构造函数中没有对其进行初始化时，会使用默认值对其进行初始化
-  若示例数据成员全为公开成员且没有定义构造函数，则可以使用{...}进行初始化（兼容C）



# 成员及成员指针

## 1.实例成员指针

- 实例成员指针是一种新的数据类型，指向实例成员，包含**实例数据成员指针**和实**例函数成员指针**

实例成员指针要和对象一起使用

- 实例数据成员的类型 **类型名::***

可在公开成员函数中，在满足一定条件的前提下返回非公开实例成员的地址，这样就可以通过实例成员指针访问非公开实例成员。

- 实例成员指针实质上是一个偏移量，使用实例成员指针访问成员时仍旧需要借助类对象

  **对象名 -> 实例成员指针**

- 实例成员指针不能移动（可能越权访问）也强制转换成其他类型（否则可能间接移动指针）



## 2.const、volatile和mutable

- 类的const成员必须在构造函数的初始化位置对其进行初始化

- 使用const修饰this参数时，表示不能修改this指向的对象的所有实例数据成员，但可以修改静态数据成员。volatile修饰this参数时，说明对象的每一个成员都出于易变状态，禁止对该对象的所有数据成员的访问进行优化
- 对this的修饰符不同，也能视为重载的不同函数。使用const修饰的函数也能被非const的对象调用（相容原则），但会优先调用更合适的函数成员实例函数成员
- 构造函数和虚构函数的this指针不能被const或者volatile修饰。（构造或者析构时，对象必须是可以被修改的、稳定的）

---

**mutable**

- mutable**只用于修饰实例数据成员**，提供了示例数据成员可被修改的机动能力。
- 对于只读对象的mutable是可以修改的（**可被修改的机动能力**）

## 3.静态数据成员

- 静态数据成员在物理上独立于对象分配内存，被类的所有对象共享，sizeof关键字计算的尺寸不包括静态数据成员
  - 局部类——作用域局限于函数中的类，其中不能定义静态数据成员，否则会造成静态数据成员的生存矛盾
  - 嵌套类——作用域局限于类体中的类

- 静态数据成员不可定义为位段类型（位段成员没有地址，无法独立分配内存，而静态数据成员需要在对象外独立分配内存）
- 静态数据成员在类体中仅仅是说明，因此可以include多次。在类体外定义静态数据成员时，只能在某个cpp代码中定义一次（定义时不需要再加static进行再次说明），非静态数据成员不能在外部进行定义

## 4.静态函数成员

- 构造函数、析构函数、虚函数、纯虚函数等函数不能定义为静态函数成员
- 静态函数成员没有this指针
- 局部类不能定义静态数据成员，但可以定义静态函数成员，必须在类体内定义，为inline函数

## 5.静态成员指针

- 普通类型的指针即可指向静态成员，即int*可指向static int类型的静态数据成员，int ( * )()类型的函数指针可以指向如static int A::f()的静态函数成员
- **成员指针也可以作为类的成员**

**



# 继承与构造

