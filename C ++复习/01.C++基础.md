# C++基础

## 1.C++关键字（2017标准）

| alignas    | continue     | friend    | register         | true     |
| ---------- | ------------ | --------- | ---------------- | -------- |
| alignof    | decltype     | goto      | reinterpret_cast | try      |
| asm        | default      | if        | return           | typedef  |
| auto       | delete       | inline    | short            | typeid   |
| bool       | double       | int       | signed           | typename |
| break      | do           | long      | sizeof           | union    |
| case       | dynamic_cast | mutable   | static           | unsigned |
| catch      | else         | namespace | static_assert    | using    |
| char       | enum         | new       | statuc_cast      | virtual  |
| char16_t   | explicit     | noexcept  | struct           | void     |
| char32_t   | export       | nullptr   | switch           | vplatile |
| class      | extern       | operator  | template         | wchar_t  |
| const      | false        | private   | this             | while    |
| constexpr  | float        | protected | thread_local     |          |
| const_cast | for          | public    | throw            |          |

- char 8位，表示ascii字符信息

- char16_t 16位，表示UTF-16字符信息，直接使用char16_t之后用cout不能直接输出中文字符，而是输出编码信息，char32_t同（取决于编译器类型）

- char32_t 32位，表示UTF-32信息

- wchar_t Windows扩展字符类型，可能被编译成char16_t或者char32_t

- 使用wcout输出汉字信息：建议使用wchar_t和wcout实现国际文字的输出
  1.导入locale库，2.输入前调用setlocale(LC_ALL,"chs"),3.使用wcout输出汉字信息

  注意：赋值时记得添加前缀转换符“u","U","L"

```c++
#include <iostream>
#include<locale>
using namespace std;

int main() {
	char16_t ch16 = u'马';
	char32_t ch32 = U'忠';
	wchar_t chw = L'平';	//加L转义
	setlocale(LC_ALL,"chs");
	wcout <<ch16<<" "<< ch32<<" "<<chw;	//输出39532 24544 平 (前两个是汉字编码)
	return 0;
}
```

- this和nullptr的类型随类的类型变化而变化，nullptr可以赋值任意类型的指针（表示空），this是任何类的对象的指针
- 某些单词有对应的可替代的关键字 && 与 and，||与 or，! 与 not，^ 与 xor

```c++
cout << not (14 > 12 and 43 < 5); //输出 1
```

## 2.预定义类型

- **类型名**

  void，bool，char，short，int，long，float，double

- **符号**

  signed，unsigned（默认有符号）

- **储存位置特性**

  auto -局部变量，在栈段分配内存（默认使用）（auto在C++中表示自动类型推定）

  register	-寄存器变量（尽量使用寄存器，寄存器不够用时与auto同义）

  static -静态变量，编译后在数据段内分配内存

  extern -全局变量，编译后在数据段内分配内存

- **储存可变特性**

  const

  constexpr

  volatile

  mutable

void*指针类型表示未知指针类型，可以指向任意类型的元素的地址。使用void *指针对指向的对象赋值时，需要指定类型(强转)

```c++
int a = 1;
void*p = &a;
*(int *)p = 6;	//强转成p，再进行赋值
```

sizeof运算符可获得类型占用的字节数

- 类型long double在不同编译器实现情况不一样，通常为12或16字节，也可能与double相同，国际标准只规定sizeof(long double) >= sizeof(double)

- sizeof运算符的参数可以为常数，参数为常数时，整数视作int类型，浮点数视作double类型

```c++
cout << sizeof(2)<<" "<<sizeof(3.4); //4 8
```

## 3.类型转换

算数运算时，可能会进行自动类型转换

- 类型不同的元素之间计算时会先转换成同一类型再进行计算，通常按照字节数增加的方式进行转换，确保没有精度损失
- 若两种字节数相同的数据
- 两种字节数相同的数据之间进行计算，一种无符号另一种有符号，则全先转换成**无符号数**，再进行计算。
- 所有浮点类型运算都按double类型进行计算。即使是两个float类型的数之间进行计算，也需要先转换成double再进行计算。
- 所有整型数运算（bool，char，short）类型运算都先转换成int类型再进行计算
- 赋值时若左边类型字节数较小，则会出现切断操作，从而丢失部分数据。浮点数会进行四舍五入，丢失精度。整型数会截断高位。
- 低字节数赋给高字节变量，有符号数会按符号位进行扩展，无符号数直接扩展。
- 转换路线——char->unsigned char->short->unsigned short->int->unsigned int->long->unsigned long->float->double->long double

有时也会出现强制类型转换：

- 高字节值赋给低字节——阶段操作
- 也可以显式强行转换

常量表达式会在编译时进行计算，不会影响运行性能。

## 4.预定义类型

###### 1.bool

- 占用1字节，仅有true，false两种常量，C++通常将true视作1，false视作0

###### 2.char

- 1字节，字符常量可用**‘\12’**的形式表示，或者可以用八进制**'\027'**、16进制**'\x27'**

- 对char16_t赋值时，常量需要加前缀u，对char32_t要加U，对wchar_t要加L

---

常量数字在书写时需要注意是否超过int类型范围，否则需要添加后缀：U--无符号，L--长整型，UL或LU--无符号长整型

常量数字通常也可以添加前缀：0--八进制，0x--16进制

对于浮点类型数通常也有加后缀的写法：f--float类型，L--long double类型，也可以使用科学计数法：0.34E-10

## 5.变量及类型解析

变量说明的一般形式为：

​	**extern存储可变特性 类型名 变量名;**

- extern表示变量说明

储存可变特性：const、constexpr、volatile、mutable

| const     |                                               |
| --------- | --------------------------------------------- |
| constexpr |                                               |
| volatile  | 易变型变量，可能在其他进程进行修改            |
| mutable   | mutable通常只在extern不出现时说明实例数据成员 |

- const volatile/constexpr volatile表示变量不会在当前进程中进行修改但可能在其他进程中进行修改

- 同一变量或函数可以被重复说明多次，但不可以被重复定义多次，通常变量函数说明放在.h文件中，可以被多个cpp文件重复include，而若.h文件中出现了变量定义，则不能被多个cpp文件include



变量定义的一般形式：

​	**储存位置特性 储存可变特性 类型名 变量名 = 初始值;**

- 常量表达式——编译时可计算得到结果的表达式（sizeof关键字也是常量表达式）
- 提倡在一个cpp文件中定义变量，在h文件和其他cpp文件中用extern说明该变量
- 模块变量——带static关键字修饰的变量，只能在当前文件中访问（文件作用域）
- **const**与**constexpr**均可用于修饰只读变量
  - const修饰的只读变量可以使用非常量表达式来初始化，也可以用常量
  - constexpr关键字修饰的只读变量必须使用常量表达式来初始化，让修饰的东西在编译期就完成，而不必等到运行期；constexpr不可用于修饰函数参数，但可用于任何非虚函数的前面，这样定义的函数默认当作inline函数，并比inline函数有更强的代码优化功能。
  - 在C中，const只有只读的作用，而在C++中承担了常量的作用，因此C++将其拆分，把常量的作用分给constexpr
- **inline**用于定义**函数外部变量**或**函数外部静态变量**、**类内部的静态数据成员**，在函数内部和复合语句内部不能定义inline变量，类内部也不能定义inline实例数据成员
  - inline用于定义函数外部变量其默认的作用域和函数外部静态变量一样，都是局限于当前代码文件——不同代码文件可以定义同名的inline函数外部变量和函数外部静态变量

- 全局变量和模块变量由开工函数初始化，由收工函数销毁。编译完成后，程序执行的顺序是——开工函数、main函数、收工函数。若使用abort()函数退出，则不执行收工函数

```c++
#include<stdio.h>
int m = scanf("%d",&m);
const int n = m + 3;	//m,n在开工函数中执行初始化，因此在main函数执行之前就会要求输入m的值，即使main函数为空，也可以在开工函数中调用其他函数（甚至可以调用main函数，但必须在全局变量或者模块变量的初始化语句中）
void mian(){}
```

- 开工函数会遵循初始化顺序执行全局变量或者模块变量的初始化语句，在同一项目中不同cpp文件的初始化语句均会按照顺序依次执行（VS会默认将无用的cpp一起编译投入执行，对cpp文件右键->属性->配置属性->常规->从生成中排除设置为是，则可不编译连接相应cpp文件）

```C++
#include <iostream>
#include<windows.h>
#include <time.h>
using namespace std;
int sleep(int times) {
	printf("wait\n");
	Sleep(times);
	return 0;
}
time_t mt1 = time(NULL);
unsigned int r1 = sleep(1000);
time_t mt2 = time(NULL);
unsigned int r2 = sleep(1000);
time_t mt3 = time(NULL);
int main()
{
	printf("main begin\n");
	cout << mt1 << endl;
	cout << mt2 << endl;
	cout << mt3 << endl;
	return 0;
}
//输出（在每个wait之后停顿了1s）
/*
wait
wait
main begin
1646478429
1646478430
1646478431
*/
```

- .h文件开始的#pragma once可避免同一个文件被include多次

- 为了避免同一个头文件被包含（include）多次，C/C++中有两种宏实现方式：一种是**#ifndef**方式；另一种是**#pragma once**方式。

  - **#ifndef **方式 ——#ifndef的方式受**C/C++语言标准支持**。它不仅可以保证同一个文件不会被包含多次，也能保证内容完全相同的两个文件（或者代码片段）不会被不小心同时包含。当然，缺点就是如果不同头文件中的宏名不小心“撞车”，可能就会导致你看到头文件明明存在，但编译器却硬说找不到声明的状况——这种情况有时非常让人郁闷。针对**语句段**。**宏名字不能冲突**

    ```c++
    //#ifndef方式 
    #ifndef  __SOMEFILE_H__
    #define   __SOMEFILE_H__
     ... ... // 声明、定义语句
    #endif
    ```

    

  - **#pragma once** 方式——\#pragma once 一般由**编译器提供**保证：同一个文件不会被包含多次。注意这里所说的“同一个文件”是指物理上的一个文件，而不是指内容相同的两个文件。无法对一个头文件中的一段代码作pragma once声明，而只能**针对文件**。

  - ```C++
    #pragma once
    ... ... // 一些声明语句
    ```

- **volatile**说明易变变量，用于进程间或者线程间协同的变量应该定义为易变变量，**遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化(保证每一次从储存变量的内存中读取，而不是从储存其暂时值的寄存器或栈中读取)，从而可以提供对特殊地址的稳定访问**

  ```c++
  volatile int i = 10;int a = i;....int b = i;
  ```

- volatile指出某变量i是随时可能发生变化的，**每次使用它的时候必须从i的地址中读取**，因而编译器生成的汇编代码会重新从i的地址读取数据放在b中，而假如编译器优化的做法是，由于编译器发现两次从i读取数据的代码之间没有对i进行过操作，它会自动把上次读到的数据放在b中，而不是重新从i里面读这样以来如果i是一个寄存器变量或者表示一个端口数据就容易出错，所以说**volatile可以保证对特殊地址的稳定访问**。

- 易变变量可以设置为const只读变量，表示当前线程/进程对变量拥有只读权限

  ```C++
  volatile const int vc = 2;	//可用constexpr替换const，volatile与const的位置可交换， 
  ```

  

---

## 6.指针

- 32位X86模式编译的程序来说，指针类型分配4个字节的内存单元；X64编译模式分配8个字节的内存单元
- 指针的初始化可用nullptr进行初始化

```c++
int * p = nullptr;
int *r = (int*)0;	//相当于用nullptr进行初始化
int *q(nullptr);	//也是一种用nullptr初始化的方式，当然nullptr也可以用其他实体替代
int *nump(&num);
```



## 7.类型表达式解析

- 类型表达式的解析原则

（1）优先解析优先级高得运算符

（2）两个符号运算级相同时，按照运算符得结合方向进行解析

- 优先级最高的是16级，结合方式均为

```c++
括号、函数调用、类型转换	()
数组下标				[]
类class、struct或union成员	-> . 
```

- 15级的运算符次之，结合方式均为**自右向左**

```c++
单目逻辑运算符 !(逻辑反) ~(按位反)
自增自减操作 ++ --
取址运算&    取内容运算（也包含指针的解释） *
单目加减
内存操作 new delete sizeof()
```

- 14级运算符只有类运算符

```c++
直接选域成员指针	.*
间接选域成员指针	->*
```

- 之后是算术运算符（13~12级），乘除取模优先于加减
- 11级，字位运算——左移<<，右移>>
- 10级：大小关系逻辑运算>,>=……，9级：等于==，不等于!=
- 8~6级：按位与&，按位异或^，按位或|
- 5~4级，逻辑与&&，逻辑或||，**逻辑与优先级高于逻辑或**
- 3级：三元运算符 xx?a : b
- 2级：赋值号= 自反赋值 op= **自右向左**
- 1级：逗号 ,

对类型的解析需要特别注意符号优先级

例：

```c++
int *y[10][20];//[]优先级最高，从左至右结合性，先解释[10],再解释[20],然后解释*,最后解释int
//（1）y是一个含有10个元素的数组，（2）数组中的每一个元素是一个含有20个元素的数组，（3）每一个元素是一个指针，（4）每个指针指向一个int类型的地址
//综上：y是一个由int类型指针元素组成的数组
int va1=1;
y[0][0] = &va1;
//访问va1时使用
*y[0][0] = 10;

int (*z)[10][20];//()优先级也比较高，从左向右依次解析，先解释*，再解释[10],再解释[20],最后解释int
//(1)z是一个指针，（2）z指向的元素是一个含有10个元素的数组，（3）数组中的每一个元素是一个含有20个元素的数组，（4）数组中的元素是int类型的
//综上：z是一个指针，指向的元素类型为含有40个元素的int类型数组
int v[2][3] = { 1,2,3,4,5,6 };
z = &v;
//访问v[0][0]时使用
(*z)[0][0] = 10;
```

- const在不同位置时有着不同的涵义

```c++
const char* s = &a;//注意解释顺序：s为一个指针，指向一个const char的变量
//s本身可以修改,不需要初始化，但不能修改s指向的位置的元素（X），考虑到C++变量类型的向下兼容性，const类型的指针可以指向非const类型变量，也即不可通过s修改a，但可以直接用a修改a本身（a不为只读变量）
char * const s = &a;//s为一个只读变量，s是一个指针，指向char类型变量
//s为只读，需要初始化，可以通过s修改a
const char*const s = &a;
```

- C++允许将可写实体的地址或者指针赋值给只读实体的指针变量，反之不可
- C++允许将可写实体的地址赋给指向volatile易变实体的指针，但不允许将volatile易变实体的地址赋值给指向可写实体的指针



## 8.指针偏移量的自适应

- 指针变量的增减会自动乘上其表示的元素的字长，自动变成指向下一个相同类型的元素
- 若指针指向的类型不确定时（void*类型指针），不能进行指针偏移，也不能用p对指向的实体进行修改，但可以强转后进行偏移和修改

```c++
int nums[3] = {1,2,3};
void *p = &nums[0];
p = (int*)p + 1;	//强转后偏移
*(int*)p = 1;	//强转后修改
```

## 9.字符串、数组

- 常量字符串的默认类型为**const char[n]**(n = length + 1)或者**const char***,即常量字符串出现在代码中间时，其实质是一个已经完成内存分配和初始化的一片内存的const char*类型的地址，可以用该地址进行进一步的操作。
- Ｃ++中一维数组可以视作单重指针，高维数组可视为高维指针，如**char* * argv**等价于**char * argv[]**等价于**char argv [] []**

```c++
cout<<*"abcdef";	//将输出第一个字母a,如果不使用*，则cout输出流会将其视为用%s输出一个字符串
cout << *("abcdef"+1);	//将输出字母b（指针偏移）
//也可以用数组的方式进行访问
cout << "abcdef"[2];	//输出c
```

- 注意字符串中的每一个字符都是const char类型，因此不能通过字符串常量作为指针对字符串中的元素进行修改，但可以强转后修改，C++编写对于程序员来说具有很强的可操作性，事实上，只读变量对于C++程序员来说更多是一种提示作用，而不是强制性作用

```c++
((char*)"abcdef")[1] = 'a';
//对于其他的const类型，也可以进行修改
const char ch = 'a';
*(char*)(&ch) = 'b';	//强转后修改（某些IDE中强行修改可能不会生效）
```

- C++为char16_t和char32_t提供了对应的字符串类u16string和u32string，赋值常量时，分别需要添加前缀u和U

```c++
u16string s16(u"ABC");
u32string s32(U"ABC");
```

- C++规定new的数组的第一维可以是动态的

```c++
int x = 1;
int (*q)[10][20] = new int[x][10][20];
```

## 10.有址引用变量

- 可以使用运算符&定义和声明有址引用，&出现在声明或者定义中时，表示声明定义变量、函数参数或者函数的返回值为有址引用。当&出现在表达式中的变量前时，表示获取该变量的地址
- 有址引用变量必须在定义时初始化（作为参数列表类型时不需要初始化），必须指明其引用的实体，有址引用变量和被引用的实体绑定后就不能再修改（使用有址引用变量进行赋值会等同于使用被引用的变量进行赋值）。
- 由于有址引用变量的严格绑定属性，可以将有址引用变量视作给被引用变量取的别名，使用该别名与使用原变量名没有区别

```c++
int x = 3;
int &z = x;
```

- 有址引用的实质：
  - 有址引用是一个**只读指针**（占用4字节空间（32bit环境）或8字节空间（64bit环境）），编译成汇编语言时，确实被编译成指针形式

- 有址引用可代替指针，封装成函数后可对局部变量进行修改

```c++
void swap(int &a,int &b){
    a = a + b;
    b = a - b;
    a = a - b;
}
void main(){
    int a = 1,b = 2;
    swap(a,b);//交换两个变量中储存的值
}
//swap等同于如下C代码,该函数传参数时就需要传指针了
void swap_C(int*a,int *b){
    *a = *a + *b;
    *b = *a - *b;
    *a = *a - *b;
    //也可使用异或操作交换两个整型数的值：a=a^b;b=a^b;a=a^b;
}
void main(){
    int a = 1,b = 2;
    swap_C(&a,&b);//交换两个变量中储存的值
}
```

- 有址引用也遵循向下兼容原则，对于关键字volatile声明的易变变量和const声明的常量均为如此

## 11.传统左值与传统右值

- 传统左值
  - C语言定义中能够出现在赋值号左边的变量或者表达式（定义）
  - 传统左值必定是分配了内存的、有地址的
  - 传统左值使用时可作为传统右值
- 传统右值
  - C语言定义中**只能**出现在赋值号右边的变量或者表达式（定义）
  - 传统右值中，有一部分是有址的，如只读变量；另一部分无址，如常量

- **有址引用变量**可以说明为传统左值或者传统右值，没用const修饰的有址引用变量为有址传统左值，使用const修饰的有址引用变量为传统右值

- 遵循向下兼容原则，传统右值引用变量同样可以用传统左值引用变量初始化

```c++
int a = 1;
const int&aa=a;	//使用传统左值变量初始化传统右值有址引用变量
const int &bb = a ++;	//可使用自增自减后的数进行赋值，引用变量仍为a
//在引用变量中，const int &与int const &等同，不能写成int &const,这样编译器会自动识别为无效const，解释其为int &
```

- ”有址“实体——分配了内存单元有地址的实体，除了有名无址的位段成员外，任何有名的变量、函数参数、返回值为”&”引用的函数调用都是有址的。new产生的实体也是有址的，它们可以被有址引用变量，有址引用形参，返回值为“&”引用的函数调用所引用。

```c++
int f();	//返回值储存在寄存器中，函数调用f()不能有址引用变量引用
int &g();	//返回值有址，可以被传统左值有址引用变量引用。由于兼容性，也可以被传统右值有址引用变量引用
const int &h();	//返回值有址，可以被传统右值有址引用变量引用
```

- **右值引用**/传统右值的引用

```c++
const int &w = 7;
int && w = 7;	//等同于上一句
```

- 右值有址引用可以引用右值或常量，编译程序会自动生成一个匿名变量，在度内存中为该变量分配内存，右值或常量用于初始化匿名变量，之后再用右值有址引用变量引用该匿名变量。

```C++
int a = 1;
int* const tt = &a;
int * &t = &a;	//报错：非常量引用的初始值必须为左值
int*const & t = &a;	//解决上述报错
int * && t = &a;	//右值引用，编译器自动将右值信息&a赋值到某一位置并使用右值引用t引用它
```

- 局部变量如果使用外围局部变量指针进行引用，在作用域栈弹出后，编译器也可能优化相关内存使用，将外围局部变量引用的地址保留，但原本的内部局部变量本身不能再使用

```C++
int *b;
if(true){
    int c = 1;
    *b = &c;	
    int d = 2;
    &d;//只要见到取址符号&，作用域栈弹出后，仍然会保留相关内存（Visual Studio）。
}
cout <<*b;
```

- 引用变量视作与被引用变量共享内存，逻辑上不分配内存，故不能使用多重引用变量。int && a 表示右值引用，而不是二重引用

```c++
int *& a = b;	//引用指针的引用变量
int &*c;	//不允许指向引用变量的指针

int a = 0;
int &b = a;
int &c = b;	//传递引用，汇编后c与b指向相同的地址，实际上c引用了a
```

- 被引用的传统左值类型变量一定要和有址引用变量引用的类型一致，否则编译器会执行类型转换，执行类型转换后，会形成传统右值，而传统右值不能用于初始化左值引用变量

```c++
int m=0;
short &n=(short)m;	//报错，m转换为short类型后，结果为无址传统右值，而n要引传统左值
short &&s = m;	//可用无址引用变量进行引用
short const &t = m;	//可用右值引用进行引用
```

- 无址引用变量 &&
- 无址引用只能引用储存于缓存或者寄存器中的无址表达式，不能引用储存于内存的有址表达式

```c++
int && x = 2;	//传统左值无址引用变量
const int && y = 2; //传统右值无址引用变量
//无址引用变量是有址的，可以被有址引用变量引用（引用的是地址信息，不是该无址引用变量）
int &r = x;
//无址引用类型也通常用于作为参数列表定义常量参数传递
int f(int &&x);	//定义常量参数
int f(int &x);
f(2)//存在上述两个重载函数时,f(2)会优先调用第一个函数
```

- 无址引用变量、有址引用变量本身不能再被引用，即没有下述类型：int & &,int && &,int & &&,int && &&;
- c++的强制类型转换无所不能，可使无址引用变量通过强制类型转换引用有址表达式、有址引用类型的表达式和无址引用类型的表达式

```c++
int a = 0;
int && b = (int)a;	//强转后储存在寄存器中，是无址右值，可被无址右值引用变量引用
```

- 前置++、前置--、赋值运算的结果为左值，p不指向const实体时，*p也是左值，这些左值的结果及原始的未经运算的变量都是有址的。

## 12.枚举类型

- 枚举类型值的实质为int类型

```c++
enum WEEKDAY{Sun,Mon,Tue,Wed,Thu,Fri,Sat};
WEEKDAY w1 = Sun;	//创建枚举变量
WEEKDAY w2(Mon);	//构造函数形式创建枚举变量
```

- 枚举元素和枚举类型名的作用域相同，枚举元素的关联值可指定，默认从0开始，后续枚举元素默认依次+1。不允许枚举元素的名称相同，但允许枚举元素的关联值相同
- 也可以使用enum class或者enum struct关键字定义枚举类型，若如此，访问枚举元素时需要使用限定名

```c++
enum class WEEKDAYS{Mon,Tue,Wed,Thu,Fri};
enum struct WEEKENDS{Sat,Sun};
WEEKDAYS wd1(WEEKDAYS::Mon);	//带限定名的访问 
```

- 枚举元素进行输出，使用%d会输出int类型值，若使用cout<<输出，则需要先重载运算符"<<"

```c++
#include <iostream>
using namespace std;
typedef enum class WEEKDAYS {Mon,Tue,Wed}WEEKDAYS;
//重载运算符
istream& operator >> (istream& is, WEEKDAYS& myW) { //重载运算符 >>
	int k = 0;
	cin >> k;
	switch (k) {
	case 0:
		myW = WEEKDAYS::Mon;
		break;
	case 1:
		myW = WEEKDAYS::Tue;
		break;
	case 2:
		myW = WEEKDAYS::Wed;
		break;
	default:
		cout << "Invalid Input!" << endl;
	}
	return is;
}
ostream& operator<<(ostream& os, const WEEKDAYS myW) { //重载运算符 <<
	string s;
	switch (myW)
	{
	case WEEKDAYS::Mon:
		s = "Monday";
		break;
	case WEEKDAYS::Tue:
		s = "Tuesday";
		break;
	case WEEKDAYS::Wed:
		s = "Wednesday";
		break;
	default:
		s = "error";
		break;
	}
	os << s << endl;
	return os;
}

int main() {
	WEEKDAYS w1(WEEKDAYS::Mon);
	cin >> w1;
	cout << w1 << endl;
	return 0;
}
```

- 即使使用了关键字extern，若对变量进行了初始化，也应视作变量定义而非声明

```c++
extern int h = 0;	//变量定义，该定义只能在函数体外进行
extern int i;	//声明
```

- 局部变量不会初始化，静态变量或者全局变量会初始化为0，局部变量分配在栈上，静态变量分配在数据段中
- 使用初始值初始化局部auto数组时，初始值从数据段复制至栈段内存，最终使用的是数组在栈段分配的内存。

```c++
void main(){
    int array [1024]={1};	//1024个初始值保存在数据段，用于对数组初始化。数组的内存会同时在数据段和栈段中分配（暗中使用了数据段的内存）
}
```

- 注意：上述数组的初始化可能会占用大量的数据段空间，此时可能数据段没有足够内存存放其他全局静态变量，这样的程序编译时会通过，但在连接阶段会报连接错误。 —— 原因很可能是无法将全局或静态变量装配到内存已经用完的数据段。这种错误对于没有经验的程序员来说，简直就是一个无法解决的问题。

## 13.运算符及表达式

- 赋值运算的结果为左值，因此可以对赋值的结果再次赋值

```c++
int a=0;
(a=1)=2;
```

- 当=操作符被重载后，上述操作也可能是有意义的。
- 对于运算，需要严格注意运算符的优先级与结合方式
- 关系运算的结果为true或者false，它们实际的值分别为1和0

```c++
int x=1,y=2,z=3;
z>x>y;	//自左向右依次运算，相当于(z>x)>y,z>x的结果为true，即为1，转化为1>y,最终结果为false(0)
```

- 在使用运算表达式时需要严格注意表达式顺序，不可按数学表达式进行书写

## 14.结构与联合

- C语言中，结构体的成员相当于是一个public的成员，可被任意函数访问。定义结构体变量时，变量的成员一般都是按照顺序分配内存的。
- 联合union也可用于定义复杂的类型，但联合的每个数据成员不独立分配内存，而是共享内存，共享的内存大小取决于字节数最多的那一个成员。对某一个成员值的修改将会影响到其他的成员
- 对联合变量用{...}进行初始化时，会默认初始化第一个变量
- 结构、联合和类的数据成员都可以定义为位段类型，位段类型必须是字节数小于或等于long long类型的简单类型，如有符号或无符号的char、short、int、long、long long、枚举类型等。指针类型不能定义为位段类型（指针类型的字节数是固定的）

## 15.asm和static_assert语句

- 关键字_asm可在C语言或者C++程序厚葬插入汇编代码。用于完成高级语言难以完成的功能。如使用asm可调用操作系统的终端服务程序，或将某个寄存器的值设置为特定值等。

```C++
#include <stdio.h>
void f(){
    _asm mov EAX,3
}
void main(void){
    int(*pf)()=(int(*)())f;	//强制转换为有返回值的类型
    printf("return = %d",(*pf)());
    _asm mov EAX,0;
}
```

- 关键字static_assert用于提供断言服务，即仅在编译时判定执行条件是否满足，如不满足，则通过编译输出相关信息。使用格式为 **static_assert( 条件表达式,“输出信息” )**条件表达式必须在编译时可计算的布尔值结果

## 16.函数

- 省略参数形式

```c++
long sum (int n,...){
    //省略参数可以使用指针进行访问
    long s=0;int *p=&n+1;
    for(int k = 0;k < n;k ++){
        s += p[k];
    }
    return s;
}
```

- return 的值只要相容即可，不需要严格等同

- C++文件声明使用C库函数

```C++
extern "C" long func(int n);	//extern "C"说明库函数原型源于C语言的函数库
```

- 在说明或定义函数的参数时，可以指定参数的默认值每当调用函数没有传递实参时，就使用默认的缺省值作为实参值。参数的默认值可以是任意表达式，但式中不能出现同意参数表中的参数，因为国际标准的C++没有规定参数的计算顺序。
- 定义默认参数时，有默认值的参数应该放在无默认值参数的右边，调用时才不会产生二义性



## 17.语句

- 当goto语句从外层作用域向内层作用域转移时，标号必须在内层所有局部变量的定义及其初始化之前。（不提倡该用法）



## 18.函数重载

- 函数名相同但参数列表不同的若干函数称为重载函数

## 19.inline及constexpr函数

- static关键字可定义静态函数，其作用域为当前文件，不同文件中可以定义原型相同的静态函数或变量。不加static则函数为全局作用域，能被整个程序访问
- **inline**也可以授权被定义变量获得文件作用域，C++17标准下，inline也可以用于说明静态模块变量，这种变量可能被优化掉，其作用域相当于static局限于当前代码文件。
- 通过inline定义的函数成为内联函数，内联函数的作用域仅限于当前文件。由编译器将函数调用指令替换为函数体计算指令，降低调用开销，提高执行效率。
- **函数体的指令很少，调用开销很大时，将函数定义为内联函数可以提高程序的执行效率**，如函数体很长，并且该函数在程序中的多个位置被调多次，则内敛后可能更低效

- 内联函数内部不应该出现分支、循环、多分支和函数调用等引起转移的语句，否则，编译程序还是会将其编译成调用指令，而不是用函数体指令替换每个调用（内联失败）。此外，若内联函数的定义出现在内联函数的调用之后，或者用其他函数访问了内联函数的入口地址，或者内联的函数成员为虚函数或者纯虚函数，都会导致内联失败
- 内联函数同样具有static相同的作用域，其他文件不能访问，main函数不能定义为inline函数
- 内联函数也能进行重载或参数省略等

- **constexpr**定义的函数默认是inline函数，其优化程序较内联函数更高，定义constexpr的函数要求也更高（不满足下述会报错）
  - constexpr函数中不能有goto、不能有try
  - 不能调用非constexpr函数（如printf等）
  - 不能定义static变量，线程本地变量等永久期限变量

- main函数也不能定义为constexpr类型

```c++
constexpr int f(int x){	//constexpr修饰函数，不表示返回值为右值
    return x + 2;
}
```

## 20.线程互斥及线程本地变量

- 线程之间需要共享一个互斥锁变量，被锁住的线程代码不能并发执行，即一旦进入这段代码就必须执行到开锁，期间不会有其他线程进入到执行状态

- 类**std::mutex**可以用来定义互斥锁变量，提供了加锁lock()和开锁unlock()方法，以便于锁住一段代码

- 有两种方式锁住一段代码：

  - （1）基于作用域的**std::lock_guard**，当作用域结束时自动解锁。
  - （2）基于致命区的加锁与开锁，由加锁与开锁锁住一段致命代码。一旦致命区的代码出现异常，就会转移到异常处理程序，从而没有机会执行开锁操作，这将导致其他线程无法运行

- 主函数main在使用**std::thread**类创建线程对象后，该线程便会启动和执行被线程对象关联的函数，而主函数也会作为主线程继续执行。最好**保证主线程在其他线程结束之后再结束**。

  - 在main中调用其他线程对象的**join()**函数就能使main函数等待该线程对象结束，如果希望main函数提前结束一个正在运行的线程，则可直接析构该线程的对象

- **线程本地变量**——**thread_local**

  - 使用thread_local定义的变量为线程本地变量，在每个线程对象启动后，线程对象会为其分配内存并初始化或者调用构造函数，从而使每个线程的对象启动后都有**独立隔离**的关于该变量的内存，不会使程序因线程共享访问而出现不可预料的执行状态

  - 线程本地变量看起来像全局变量，但每个线程都有一个内存备份，相当于线程自己的变量

```c++
#include<iostream>
#include <thread>
#include<mutex>
using namespace std;
std::mutex mtx;	//共享锁变量，用于线程实现互斥执行

struct S {
	int i = 0;
	S() {
		mtx.lock();//加锁
		cout << "S() called,i = " << i << endl;
		mtx.unlock();//开锁
	}
};
thread_local S gs;	//线程本地变量
void foo() {
	mtx.lock();
	gs.i += 1;
	cout << "In foo,gs is at " << &gs << " ,gs.i = " << gs.i << endl;
	mtx.unlock();
}
void bar() {
	std::lock_guard<std::mutex> lock(mtx);	//加锁，直到当前作用域结束
	gs.i += 4;
	cout << "In bar,gs is at " << &gs << " ,gs.i = " << gs.i << endl;
	//std::lock_guard<std::mutex> unlock(mtx);//即使由于异常，该行代码没有执行，也会解锁
}
int main() {
	std::thread a(foo), b(bar);	//创建两个线程对象
	a.join();
	b.join();
	cout << "In main,gs is at " << &gs << " ,gs.i = " << gs.i << endl;
}
//输出
/*
S() called,i = 0
S() called,i = 0
S() called,i = 0	//创建了两个线程本地变量
In foo,gs is at 000001831965DB18 ,gs.i = 1
In bar,gs is at 000001831965DB48 ,gs.i = 4
In main,gs is at 00000183196538A8 ,gs.i = 0
*/
```

## 21.作用域

- 函数外使用static定义模块静态变量或模块函数，函数内使用static定义函数静态变量（模块作用域）

- 全局变量或者模块变量默认初始化为0
- 若存在全局变量或函数同名的模块静态变量或函数，将优先访问作用域更小的模块静态变量或者函数。**作用域越小，访问优先级越高**。
- 其他模块定义的全局变量可在当前文件中使用extern说明后进行访问



- C++会自动对局部变量进行优化，尽量使更多的局部变量使用空闲的寄存器，定义的register变量也会在寄存器数量不足的时候自动转为auto变量
- 

## 22.生命期

生命期——常量、变量生存活动的时间范围

作用域——常量、变量可被访问的空间范围

- 全局变量的生命期和作用域均为整个程序（时/空）范围

- 静态模块变量的生命期自其**第一次被访问**时开始，直到整个程序运行结束为止
- 函数内定义的静态函数变量，作用域为函数内，生命期为从该函数第一次被调用时开始，直到整个程序运行结束为止。

```c++
#include <iostream>

using namespace std;

extern void f();
int main() {
	f();f();f();f();
	return 0;
}
void f() {
	static int a=0;//只初始化一次，变量一直存在，可用于函数调用次数的计数
	cout << "a = " << ++a << endl;
}
//输出
/*
a = 1
a = 2
a = 3
a = 4
*/
```

- 当右值被引用从而创建匿名变量时，该右值的生命期也会有所变化（与引用变量相同）

- 随着类型反射概念的移入，类型生命期的相关概念会发生很大变化

